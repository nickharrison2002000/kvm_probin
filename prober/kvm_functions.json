{
  "memory_read": [
    {
      "function": "guest_cpuid_hasstructkvm_vcpuvcpuunsignedintx86_featureconststructcpuid_regcpuidx86_feature_cpuidx86_featurestructkvm_cpuid_entry2entryu32regXSAVESisaspecialsnowflakeDuetolackofadedicatedinterceptonSVMKVMmustassumethatXSAVESandthusXRSTORSisusablebytheguestifthehostsupportsXSAVESandXSAVEisexposedtotheguestBecausetheguestcanexecuteXSAVESandXRSTORSiecanindirectlyconsumeXSSKVMmustensureXSSiszeroedwhenrunningtheguestiemustsetXSAVESinvCPUcapabilitiesButtorejectdirectXSSreadsandwritestominimizethevirt",
      "signature": "guest_cpuid_hasstructkvm_vcpuvcpuunsignedintx86_featureconststructcpuid_regcpuidx86_feature_cpuidx86_featurestructkvm_cpuid_entry2entryu32regXSAVESisaspecialsnowflakeDuetolackofadedicatedinterceptonSVMKVMmustassumethatXSAVESandthusXRSTORSisusablebytheguestifthehostsupportsXSAVESandXSAVEisexposedtotheguestBecausetheguestcanexecuteXSAVESandXRSTORSiecanindirectlyconsumeXSSKVMmustensureXSSiszeroedwhenrunningtheguestiemustsetXSAVESinvCPUcapabilitiesButtorejectdirectXSSreadsandwritestominimizethevirt",
      "file": "arch/x86/kvm/cpuid.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_cpu_capsNR_KVM_CPU_CAPS__read_mostly",
      "signature": "kvm_cpu_capsNR_KVM_CPU_CAPS__read_mostly",
      "file": "arch/x86/kvm/cpuid.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_msr_read",
      "signature": "int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_vapic_msr_read",
      "signature": "int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_readable_reg_mask",
      "signature": "u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "int kvm_read_guest_virt(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception); int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception); int handle_ud(struct kvm_vcpu *vcpu); void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu, struct kvm_queued_exception *ex); int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata); void kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code); int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type, void *insn, int insn_len); int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, int emulation_type, void *insn, int insn_len); fastpath_t handle_fastpath_wrmsr(struct kvm_vcpu *vcpu); fastpath_t handle_fastpath_wrmsr_imm(struct kvm_vcpu *vcpu, u32 msr, int reg); fastpath_t handle_fastpath_hlt(struct kvm_vcpu *vcpu); fastpath_t handle_fastpath_invd(struct kvm_vcpu *vcpu); extern struct kvm_caps kvm_caps; extern struct kvm_host_values kvm_host; extern bool enable_pmu; /* * Get a filtered version of KVM's supported XCR0 that strips out dynamic * features for which the current process doesn't (yet)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "long kvm_register_read(struct kvm_vcpu *vcpu, int reg)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read_raw",
      "signature": "kvm_register_read_raw",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size, unsigned int port, void *data, unsigned int count, int in); static inline bool user_exit_on_hypercall(struct kvm *kvm, unsigned long hc_nr)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virt",
      "signature": "read_guest_virt",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "KVM_HdefinedTRACE_HEADER_MULTI_READ",
      "signature": "KVM_HdefinedTRACE_HEADER_MULTI_READ",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_apic_read",
      "signature": "kvm_apic_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read",
      "signature": "kvm_msr_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read_ex",
      "signature": "kvm_msr_read_ex",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_cr_read",
      "signature": "kvm_cr_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "return kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val, sizeof(*val)); } static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_msr_read",
      "signature": "int kvm_lapic_msr_read(struct kvm_lapic *apic, u32 reg, u64 *data); static int kvm_lapic_msr_write(struct kvm_lapic *apic, u32 reg, u64 data); static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_make_requestKVM_REQ_APF_READY",
      "signature": "kvm_make_requestKVM_REQ_APF_READY",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_readable_reg_mask",
      "signature": "u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_lapic_readable_reg_mask",
      "signature": "KVM_INTERNALkvm_lapic_readable_reg_mask",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_reg_read",
      "signature": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len, void *data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_apic_read",
      "signature": "kvm_apic_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_icr_read",
      "signature": "u64 kvm_x2apic_icr_read(struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_icr_writeapickvm_x2apic_icr_read",
      "signature": "kvm_x2apic_icr_writeapickvm_x2apic_icr_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_unlock",
      "signature": "kvm_vcpu_srcu_read_unlock",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_lock",
      "signature": "kvm_vcpu_srcu_read_lock",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_msr_read",
      "signature": "int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_vapic_msr_read",
      "signature": "int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "read_emulatedstructx86_emulate_ctxtctxtunsignedlongaddrvoiddestunsignedsizeintrcstructread_cachemcctxtmem",
      "signature": "read_emulatedstructx86_emulate_ctxtctxtunsignedlongaddrvoiddestunsignedsizeintrcstructread_cachemcctxtmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "em_lgdt_lidtstructx86_emulate_ctxtctxtboollgdtstructdesc_ptrdesc_ptrintrcifctxtmodeX86EMUL_MODE_PROT64ctxtop_bytes8rcread_descriptorctxtctxtsrcaddrmem",
      "signature": "em_lgdt_lidtstructx86_emulate_ctxtctxtboollgdtstructdesc_ptrdesc_ptrintrcifctxtmodeX86EMUL_MODE_PROT64ctxtop_bytes8rcread_descriptorctxtctxtsrcaddrmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "em_fxrstorstructx86_emulate_ctxtctxtstructfxregs_statefx_stateintrcsize_tsizerccheck_fxsrctxtifrcX86EMUL_CONTINUEreturnrcsizefxstate_sizectxtrcsegmented_read_stdctxtctxtmemopaddrmem",
      "signature": "em_fxrstorstructx86_emulate_ctxtctxtstructfxregs_statefx_stateintrcsize_tsizerccheck_fxsrctxtifrcX86EMUL_CONTINUEreturnrcsizefxstate_sizectxtrcsegmented_read_stdctxtctxtmemopaddrmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "ifctxtmemoptypeOP_REGctxtmemopaddrregdecode_registerctxtctxtmodrm_rmtruefetch_register_operandctxtmem",
      "signature": "ifctxtmemoptypeOP_REGctxtmemopaddrregdecode_registerctxtctxtmodrm_rmtruefetch_register_operandctxtmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "ifctxtsrc2typeOP_MEMrcsegmented_readctxtctxtsrc2addrmem",
      "signature": "ifctxtsrc2typeOP_MEMrcsegmented_readctxtctxtsrc2addrmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_sse_reg",
      "signature": "kvm_read_sse_reg",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_mmx_reg",
      "signature": "kvm_read_mmx_reg",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0_bits",
      "signature": "ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "ulong kvm_read_cr0(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4_bits",
      "signature": "ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "ulong kvm_read_cr3(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "ulong kvm_read_cr4(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_edx_eax",
      "signature": "u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_lname_read",
      "signature": "kvm_lname_read",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read_raw",
      "signature": "long kvm_register_read_raw(struct kvm_vcpu *vcpu, int reg)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "long kvm_rip_read(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsp_read",
      "signature": "long kvm_rsp_read(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_pdptr_read",
      "signature": "u64 kvm_pdptr_read(struct kvm_vcpu *vcpu, int index)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_pmu_emulated_event_selectors__read_mostly",
      "signature": "kvm_pmu_emulated_event_selectors__read_mostly",
      "file": "arch/x86/kvm/pmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pmu_opskvm_pmu_ops__read_mostly",
      "signature": "kvm_pmu_opskvm_pmu_ops__read_mostly",
      "file": "arch/x86/kvm/pmu.c",
      "category": "memory_read"
    },
    {
      "function": "load_pdptrsstructkvm_vcpuvcpuunsignedlongcr3structkvm_mmummuvcpuarchwalk_mmugfn_tpdpt_gfncr3PAGE_SHIFTgpa_treal_gpaintiintretu64pdpteARRAY_SIZEmmupdptrsIftheMMUisnestedCR3holdsanL2GPAandneedstobetranslatedtoanL1GPAreal_gpakvm_translate_gpavcpummugfn_to_gpapdpt_gfnPFERR_USER_MASKPFERR_WRITE_MASKNULLifreal_gpaINVALID_GPAreturn0NotetheoffsetPDPTRsare32bytealignedwhenusingPAEpagingretkvm_vcpu_read_guest_pagevcpugpa_to_gfnreal_gpa",
      "signature": "load_pdptrsstructkvm_vcpuvcpuunsignedlongcr3structkvm_mmummuvcpuarchwalk_mmugfn_tpdpt_gfncr3PAGE_SHIFTgpa_treal_gpaintiintretu64pdpteARRAY_SIZEmmupdptrsIftheMMUisnestedCR3holdsanL2GPAandneedstobetranslatedtoanL1GPAreal_gpakvm_translate_gpavcpummugfn_to_gpapdpt_gfnPFERR_USER_MASKPFERR_WRITE_MASKNULLifreal_gpaINVALID_GPAreturn0NotetheoffsetPDPTRsare32bytealignedwhenusingPAEpagingretkvm_vcpu_read_guest_pagevcpugpa_to_gfnreal_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt_helpergva_taddrvoidvalunsignedintbytesstructkvm_vcpuvcpuu64accessstructx86_exceptionexceptionstructkvm_mmummuvcpuarchwalk_mmuvoiddatavalintrX86EMUL_CONTINUEwhilebytesgpa_tgpammugva_to_gpavcpummuaddraccessexceptionunsignedoffsetaddrPAGE_SIZE1unsignedtoreadminbytesunsignedPAGE_SIZEoffsetintretifgpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULTretkvm_vcpu_read_guest_pagevcpugpa",
      "signature": "kvm_read_guest_virt_helpergva_taddrvoidvalunsignedintbytesstructkvm_vcpuvcpuu64accessstructx86_exceptionexceptionstructkvm_mmummuvcpuarchwalk_mmuvoiddatavalintrX86EMUL_CONTINUEwhilebytesgpa_tgpammugva_to_gpavcpummuaddraccessexceptionunsignedoffsetaddrPAGE_SIZE1unsignedtoreadminbytesunsignedPAGE_SIZEoffsetintretifgpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULTretkvm_vcpu_read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_fetch_guest_virtstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionstructkvm_vcpuvcpuemul_to_vcpuctxtstructkvm_mmummuvcpuarchwalk_mmuu64accesskvm_x86_callget_cplvcpu3PFERR_USER_MASK0unsignedoffsetintretInlinekvm_read_guest_virt_helperforspeedgpa_tgpammugva_to_gpavcpummuaddraccessPFERR_FETCH_MASKexceptionifunlikelygpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULToffsetaddrPAGE_SIZE1ifWARN_ONoffsetbytesPAGE_SIZEbytesunsignedPAGE_SIZEoffsetretkvm_vcpu_read_guest_pagevcpugpa",
      "signature": "kvm_fetch_guest_virtstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionstructkvm_vcpuvcpuemul_to_vcpuctxtstructkvm_mmummuvcpuarchwalk_mmuu64accesskvm_x86_callget_cplvcpu3PFERR_USER_MASK0unsignedoffsetintretInlinekvm_read_guest_virt_helperforspeedgpa_tgpammugva_to_gpavcpummuaddraccessPFERR_FETCH_MASKexceptionifunlikelygpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULToffsetaddrPAGE_SIZE1ifWARN_ONoffsetbytesPAGE_SIZEbytesunsignedPAGE_SIZEoffsetretkvm_vcpu_read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virtstructkvm_vcpuvcpugva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionu64accesskvm_x86_callget_cplvcpu3PFERR_USER_MASK0FIXMEthisshouldcallhandle_emulation_failureifX86EMUL_IO_NEEDEDisreturnedbutourcallersarenotreadyforthatandtheyblindlycallkvm_inject_page_faultEnsurethattheyatleastdonotleakuninitializedkernelstackmemoryintocr2anderrorcodememsetexception0sizeofexceptionreturnkvm_read_guest_virt",
      "signature": "kvm_read_guest_virtstructkvm_vcpuvcpugva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionu64accesskvm_x86_callget_cplvcpu3PFERR_USER_MASK0FIXMEthisshouldcallhandle_emulation_failureifX86EMUL_IO_NEEDEDisreturnedbutourcallersarenotreadyforthatandtheyblindlycallkvm_inject_page_faultEnsurethattheyatleastdonotleakuninitializedkernelstackmemoryintocr2anderrorcodememsetexception0sizeofexceptionreturnkvm_read_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "emulator_read_stdstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionboolsystemstructkvm_vcpuvcpuemul_to_vcpuctxtu64access0ifsystemaccessPFERR_IMPLICIT_ACCESSelseifkvm_x86_callget_cplvcpu3accessPFERR_USER_MASKreturnkvm_read_guest_virt",
      "signature": "emulator_read_stdstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionboolsystemstructkvm_vcpuvcpuemul_to_vcpuctxtu64access0ifsystemaccessPFERR_IMPLICIT_ACCESSelseifkvm_x86_callget_cplvcpu3accessPFERR_USER_MASKreturnkvm_read_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_emulatestructkvm_vcpuvcpugpa_tgpavoidvalintbytesreturnkvm_vcpu_read_guestvcpugpa",
      "signature": "read_emulatestructkvm_vcpuvcpugpa_tgpavoidvalintbytesreturnkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_exit_mmiostructkvm_vcpuvcpugpa_tgpavoidvalintbytestrace_kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIEDbytesgpa",
      "signature": "read_exit_mmiostructkvm_vcpuvcpugpa_tgpavoidvalintbytestrace_kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIEDbytesgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "emulator_read_write_onepageunsignedlongaddrvoidvalunsignedintbytesstructx86_exceptionexceptionstructkvm_vcpuvcpuconststructread_write_emulator_opsopsgpa_tgpainthandledretboolwriteopswritestructkvm_mmio_fragmentfragstructx86_emulate_ctxtctxtvcpuarchemulate_ctxtIftheexitwasduetoaNPFwemayalreadyhaveaGPA",
      "signature": "emulator_read_write_onepageunsignedlongaddrvoidvalunsignedintbytesstructx86_exceptionexceptionstructkvm_vcpuvcpuconststructread_write_emulator_opsopsgpa_tgpainthandledretboolwriteopswritestructkvm_mmio_fragmentfragstructx86_emulate_ctxtctxtvcpuarchemulate_ctxtIftheexitwasduetoaNPFwemayalreadyhaveaGPA",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_update_cpu_dirty_loggingstructkvmkvmboolenableintnr_slotsifkvmarchcpu_dirty_log_sizereturnnr_slotsatomic_readkvmnr_mem",
      "signature": "kvm_mmu_update_cpu_dirty_loggingstructkvmkvmboolenableintnr_slotsifkvmarchcpu_dirty_log_sizereturnnr_slotsatomic_readkvmnr_mem",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_writestructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledwrite_emultorread_write_mmiovcpugpa",
      "signature": "kvm_sev_es_mmio_writestructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledwrite_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_readstructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledread_emultorread_write_mmiovcpugpa",
      "signature": "kvm_sev_es_mmio_readstructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledread_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0_bits",
      "signature": "kvm_read_cr0_bits",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_edx_eax",
      "signature": "kvm_read_edx_eax",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "kvm_read_guest",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt_helper",
      "signature": "int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes, struct kvm_vcpu *vcpu, u64 access, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "int kvm_read_guest_virt(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_offset_cached",
      "signature": "kvm_read_guest_offset_cached",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_capskvm_caps__read_mostly",
      "signature": "kvm_capskvm_caps__read_mostly",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_host_valueskvm_host__read_mostly",
      "signature": "kvm_host_valueskvm_host__read_mostly",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x86_opskvm_x86_ops__read_mostly",
      "signature": "kvm_x86_opskvm_x86_ops__read_mostly",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_cr0vcpukvm_read_cr0_bits",
      "signature": "kvm_set_cr0vcpukvm_read_cr0_bits",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_xcrvcpukvm_rcx_readvcpukvm_read_edx_eax",
      "signature": "kvm_set_xcrvcpukvm_rcx_readvcpukvm_read_edx_eax",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read",
      "signature": "int kvm_msr_read(struct kvm_vcpu *vcpu, u32 index, u64 *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_msr_read",
      "signature": "int kvm_emulate_msr_read(struct kvm_vcpu *vcpu, u32 index, u64 *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNAL__kvm_emulate_msr_read",
      "signature": "KVM_INTERNAL__kvm_emulate_msr_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_allowedvcpuindexKVM_MSR_FILTER_READ",
      "signature": "kvm_msr_allowedvcpuindexKVM_MSR_FILTER_READ",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_msr_read",
      "signature": "KVM_INTERNALkvm_emulate_msr_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read_ex",
      "signature": "kvm_msr_read_ex",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_rdmsrvcpukvm_rcx_read",
      "signature": "kvm_emulate_rdmsrvcpukvm_rcx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_wrmsrvcpukvm_rcx_read",
      "signature": "kvm_emulate_wrmsrvcpukvm_rcx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_wrmsrvcpumsrkvm_register_read",
      "signature": "kvm_emulate_wrmsrvcpumsrkvm_register_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_l1_tsc",
      "signature": "KVM_INTERNALkvm_read_l1_tsc",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_msr_read",
      "signature": "return kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data); case MSR_IA32_TSC_DEADLINE: msr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu); break; case MSR_IA32_TSC_ADJUST: msr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr; break; case MSR_IA32_MISC_ENABLE: msr_info->data = vcpu->arch.ia32_misc_enable_msr; break; case MSR_IA32_SMBASE: if (!IS_ENABLED(CONFIG_KVM_SMM) || !msr_info->host_initiated) return 1; msr_info->data = vcpu->arch.smbase; break; case MSR_SMI_COUNT: msr_info->data = vcpu->arch.smi_count; break; case MSR_IA32_PERF_STATUS: /* TSC increment by tick */ msr_info->data = 1000ULL; /* CPU multiplier */ msr_info->data |= (((uint64_t)4ULL) << 40); break; case MSR_EFER: msr_info->data = vcpu->arch.efer; break; case MSR_KVM_WALL_CLOCK: if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE)) return 1; msr_info->data = vcpu->kvm->arch.wall_clock; break; case MSR_KVM_WALL_CLOCK_NEW: if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2)) return 1; msr_info->data = vcpu->kvm->arch.wall_clock; break; case MSR_KVM_SYSTEM_TIME: if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE)) return 1; msr_info->data = vcpu->arch.time; break; case MSR_KVM_SYSTEM_TIME_NEW: if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2)) return 1; msr_info->data = vcpu->arch.time; break; case MSR_KVM_ASYNC_PF_EN: if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF)) return 1; msr_info->data = vcpu->arch.apf.msr_en_val; break; case MSR_KVM_ASYNC_PF_INT: if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT)) return 1; msr_info->data = vcpu->arch.apf.msr_int_val; break; case MSR_KVM_ASYNC_PF_ACK: if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT)) return 1; msr_info->data = 0; break; case MSR_KVM_STEAL_TIME: if (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME)) return 1; msr_info->data = vcpu->arch.st.msr_val; break; case MSR_KVM_PV_EOI_EN: if (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI)) return 1; msr_info->data = vcpu->arch.pv_eoi.msr_val; break; case MSR_KVM_POLL_CONTROL: if (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL)) return 1; msr_info->data = vcpu->arch.msr_kvm_poll_control; break; case MSR_IA32_P5_MC_ADDR: case MSR_IA32_P5_MC_TYPE: case MSR_IA32_MCG_CAP: case MSR_IA32_MCG_CTL: case MSR_IA32_MCG_STATUS: case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1: case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1: return get_msr_mce(vcpu, msr_info->index, &msr_info->data, msr_info->host_initiated); case MSR_IA32_XSS: if (!msr_info->host_initiated && !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES)) return 1; msr_info->data = vcpu->arch.ia32_xss; break; case MSR_K7_CLK_CTL: /* * Provide expected ramp-up count for K7. All other * are set to zero, indicating minimum divisors for * every field. * * This prevents guest kernels on AMD host with CPU * type 6, model 8 and higher from exploding due to * the rdmsr failing. */ msr_info->data = 0x20000000; break; #ifdef CONFIG_KVM_HYPERV case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15: case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER: case HV_X64_MSR_SYNDBG_OPTIONS: case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4: case HV_X64_MSR_CRASH_CTL: case HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT: case HV_X64_MSR_REENLIGHTENMENT_CONTROL: case HV_X64_MSR_TSC_EMULATION_CONTROL: case HV_X64_MSR_TSC_EMULATION_STATUS: case HV_X64_MSR_TSC_INVARIANT_CONTROL: return kvm_hv_get_msr_common(vcpu, msr_info->index, &msr_info->data, msr_info->host_initiated); #endif case MSR_IA32_BBL_CR_CTL3: /* This legacy MSR exists but isn't fully documented in current * silicon. It is however accessed by winxp in very narrow * scenarios where it sets bit #19, itself documented as * a \"reserved\" bit. Best effort attempt to source coherent * read data here should the balance of the register be * interpreted by the guest: * * L2 cache control register 3: 64GB range, 256KB size, * enabled, latency 0x1, configured */ msr_info->data = 0xbe702111; break; case MSR_AMD64_OSVW_ID_LENGTH: if (!guest_cpu_cap_has(vcpu, X86_FEATURE_OSVW)) return 1; msr_info->data = vcpu->arch.osvw.length; break; case MSR_AMD64_OSVW_STATUS: if (!guest_cpu_cap_has(vcpu, X86_FEATURE_OSVW)) return 1; msr_info->data = vcpu->arch.osvw.status; break; case MSR_PLATFORM_INFO: if (!msr_info->host_initiated && !vcpu->kvm->arch.guest_can_read_msr_platform_info) return 1; msr_info->data = vcpu->arch.msr_platform_info; break; case MSR_MISC_FEATURES_ENABLES: msr_info->data = vcpu->arch.msr_misc_features_enables; break; case MSR_K7_HWCR: msr_info->data = vcpu->arch.msr_hwcr; break; #ifdef CONFIG_X86_64 case MSR_IA32_XFD: if (!msr_info->host_initiated && !guest_cpu_cap_has(vcpu, X86_FEATURE_XFD)) return 1; msr_info->data = vcpu->arch.guest_fpu.fpstate->xfd; break; case MSR_IA32_XFD_ERR: if (!msr_info->host_initiated && !guest_cpu_cap_has(vcpu, X86_FEATURE_XFD)) return 1; msr_info->data = vcpu->arch.guest_fpu.xfd_err; break; #endif case MSR_IA32_U_CET: case MSR_IA32_PL0_SSP ... MSR_IA32_PL3_SSP: kvm_get_xstate_msr(vcpu, msr_info); break; default: if (kvm_pmu_is_valid_msr(vcpu, msr_info->index)) return kvm_pmu_get_msr(vcpu, msr_info); return KVM_MSR_RET_UNSUPPORTED; } return 0; } EXPORT_SYMBOL_FOR_KVM_INTERNAL(kvm_get_msr_common); /* * Read or write a bunch of msrs. All parameters are kernel addresses. * * @return number of msrs set successfully. */ static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs, struct kvm_msr_entry *entries, int (*do_msr)(struct kvm_vcpu *vcpu, unsigned index, u64 *data))",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_CAP_READONLY_MEM",
      "signature": "KVM_CAP_READONLY_MEM",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_has_readonly_mem",
      "signature": "kvm_arch_has_readonly_mem",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_ready_for_interrupt_injection",
      "signature": "int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_lock",
      "signature": "kvm_vcpu_srcu_read_lock",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_unlock",
      "signature": "kvm_vcpu_srcu_read_unlock",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_iodevice_read",
      "signature": "kvm_iodevice_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_io_bus_read",
      "signature": "kvm_io_bus_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_read",
      "signature": "gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_mmu_gva_to_gpa_read",
      "signature": "KVM_INTERNALkvm_mmu_gva_to_gpa_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_virt",
      "signature": "KVM_INTERNALkvm_read_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_writevcpukvm_rip_read",
      "signature": "kvm_rip_writevcpukvm_rip_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_cr0vcpumk_cr_64kvm_read_cr0",
      "signature": "kvm_set_cr0vcpumk_cr_64kvm_read_cr0",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_cr4vcpumk_cr_64kvm_read_cr4",
      "signature": "kvm_set_cr4vcpumk_cr_64kvm_read_cr4",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read_raw",
      "signature": "return kvm_register_read_raw(emul_to_vcpu(ctxt), reg); } static void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "return kvm_rip_read(vcpu); } int kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbx_read",
      "signature": "kvm_rbx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsi_read",
      "signature": "kvm_rsi_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_check_requestKVM_REQ_APF_READY",
      "signature": "kvm_check_requestKVM_REQ_APF_READY",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdi_read",
      "signature": "kvm_rdi_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsp_read",
      "signature": "kvm_rsp_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbp_read",
      "signature": "kvm_rbp_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r8_read",
      "signature": "kvm_r8_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r9_read",
      "signature": "kvm_r9_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r10_read",
      "signature": "kvm_r10_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r11_read",
      "signature": "kvm_r11_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r12_read",
      "signature": "kvm_r12_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r13_read",
      "signature": "kvm_r13_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r14_read",
      "signature": "kvm_r14_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r15_read",
      "signature": "kvm_r15_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pdptr_read",
      "signature": "kvm_pdptr_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_is_bspvcpukvm_rip_read",
      "signature": "kvm_vcpu_is_bspvcpukvm_rip_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3vcpukvm_read_cr4",
      "signature": "kvm_read_cr3vcpukvm_read_cr4",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MR_FLAGS_ONLYnew_flagsKVM_MEM_READONLY",
      "signature": "KVM_MR_FLAGS_ONLYnew_flagsKVM_MEM_READONLY",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_async_pf_ready",
      "signature": "kvm_async_pf_ready",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_make_requestKVM_REQ_APF_READY",
      "signature": "kvm_make_requestKVM_REQ_APF_READY",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes, void *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_sev_es_mmio_read",
      "signature": "KVM_INTERNALkvm_sev_es_mmio_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_pagevcpugpa_to_gfnreal_gpa",
      "signature": "read_guest_pagevcpugpa_to_gfnreal_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virt_helpergva",
      "signature": "read_guest_virt_helpergva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_pagevcpugpa",
      "signature": "read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virt",
      "signature": "read_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_emulatestructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_write_emulatestructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_write_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_write_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_emulatestructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_emulatestructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpugpa",
      "signature": "read_guestvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "READ_UNSATISFIEDbytesgpa",
      "signature": "READ_UNSATISFIEDbytesgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_emulatevcpugpa",
      "signature": "read_write_emulatevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_mmiovcpugpa",
      "signature": "read_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_exit_mmiovcpugpa",
      "signature": "read_write_exit_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virtvcpugva",
      "signature": "read_guest_virtvcpugva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_emultorread_write_mmiovcpugpa",
      "signature": "read_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_sse_reg",
      "signature": "void kvm_read_sse_reg(int reg, sse128_t *data)",
      "file": "arch/x86/kvm/fpu.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_mmx_reg",
      "signature": "void kvm_read_mmx_reg(int reg, u64 *data)",
      "file": "arch/x86/kvm/fpu.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_pic_read_irq",
      "signature": "int kvm_pic_read_irq(struct kvm *kvm)",
      "file": "arch/x86/kvm/i8259.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read_raw",
      "signature": "kvm_register_read_raw",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read",
      "signature": "kvm_msr_read",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pic_read_irq",
      "signature": "int kvm_pic_read_irq(struct kvm *kvm); void kvm_pic_update_irq(struct kvm_pic *s); int kvm_pic_set_irq(struct kvm_kernel_irq_routing_entry *e, struct kvm *kvm, int irq_source_id, int level, bool line_status); int kvm_setup_default_ioapic_and_pic_routing(struct kvm *kvm); int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip); int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip); static inline int irqchip_full(struct kvm *kvm)",
      "file": "arch/x86/kvm/irq.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_setup_tsc_pagestructkvmkvmstructpvclock_vcpu_time_infohv_clockstructkvm_hvhvto_kvm_hvkvmu32tsc_sequ64gfnBUILD_BUG_ONsizeoftsc_seqsizeofhvtsc_reftsc_sequenceBUILD_BUG_ONoffsetofstructms_hyperv_tsc_pagetsc_sequence0guardmutexhvhv_lockifhvhv_tsc_page_statusHV_TSC_PAGE_BROKENhvhv_tsc_page_statusHV_TSC_PAGE_SEThvhv_tsc_page_statusHV_TSC_PAGE_UNSETreturnifhvhv_tsc_pageHV_X64_MSR_TSC_REFERENCE_ENABLEreturngfnhvhv_tsc_pageHV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFTBecausetheTSCparametersonlyvarywhenthereisachangeinthemasterclockdonotbotherwithcachingifunlikelykvm_read_guestkvmgfn_to_gpagfntsc_seqsizeoftsc_seqgotoout_erriftsc_seqtsc_page_update_unsafehvifkvm_read_guestkvmgfn_to_gpa",
      "signature": "kvm_hv_setup_tsc_pagestructkvmkvmstructpvclock_vcpu_time_infohv_clockstructkvm_hvhvto_kvm_hvkvmu32tsc_sequ64gfnBUILD_BUG_ONsizeoftsc_seqsizeofhvtsc_reftsc_sequenceBUILD_BUG_ONoffsetofstructms_hyperv_tsc_pagetsc_sequence0guardmutexhvhv_lockifhvhv_tsc_page_statusHV_TSC_PAGE_BROKENhvhv_tsc_page_statusHV_TSC_PAGE_SEThvhv_tsc_page_statusHV_TSC_PAGE_UNSETreturnifhvhv_tsc_pageHV_X64_MSR_TSC_REFERENCE_ENABLEreturngfnhvhv_tsc_pageHV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFTBecausetheTSCparametersonlyvarywhenthereisachangeinthemasterclockdonotbotherwithcachingifunlikelykvm_read_guestkvmgfn_to_gpagfntsc_seqsizeoftsc_seqgotoout_erriftsc_seqtsc_page_update_unsafehvifkvm_read_guestkvmgfn_to_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_send_ipistructkvm_vcpuvcpustructkvm_hv_hcallhcstructkvm_vcpu_hvhv_vcputo_hv_vcpuvcpuu64sparse_bankshv_vcpusparse_banksstructkvmkvmvcpukvmstructhv_send_ipi_exsend_ipi_exstructhv_send_ipisend_ipiu64valid_bank_masku32vectorboolall_cpusiflapic_in_kernelvcpureturnHV_STATUS_INVALID_HYPERCALL_INPUTifhccodeHVCALL_SEND_IPIifhcfastifunlikelykvm_read_guestkvmhcingpa",
      "signature": "kvm_hv_send_ipistructkvm_vcpuvcpustructkvm_hv_hcallhcstructkvm_vcpu_hvhv_vcputo_hv_vcpuvcpuu64sparse_bankshv_vcpusparse_banksstructkvmkvmvcpukvmstructhv_send_ipi_exsend_ipi_exstructhv_send_ipisend_ipiu64valid_bank_masku32vectorboolall_cpusiflapic_in_kernelvcpureturnHV_STATUS_INVALID_HYPERCALL_INPUTifhccodeHVCALL_SEND_IPIifhcfastifunlikelykvm_read_guestkvmhcingpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "ifhcfastifunlikelykvm_read_guestkvmhcingpa",
      "signature": "ifhcfastifunlikelykvm_read_guestkvmhcingpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_hypercall_completestructkvm_vcpuvcpuu64resultu32tlb_lock_count0intretifhv_result_successresultis_guest_modevcpukvm_hv_is_tlb_flush_hcallvcpukvm_read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "signature": "kvm_hv_hypercall_completestructkvm_vcpuvcpuu64resultu32tlb_lock_count0intretifhv_result_successresultis_guest_modevcpukvm_hv_is_tlb_flush_hcallvcpukvm_read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hvcall_signal_eventstructkvm_vcpuvcpustructkvm_hv_hcallhcstructkvm_hvhvto_kvm_hvvcpukvmstructeventfd_ctxeventfdifunlikelyhcfastintretgpa_tgpahcingpaifgpa__alignof__hcingpa1offset_in_pagegpasizeofhcingpaPAGE_SIZEreturnHV_STATUS_INVALID_ALIGNMENTretkvm_vcpu_read_guestvcpugpa",
      "signature": "kvm_hvcall_signal_eventstructkvm_vcpuvcpustructkvm_hv_hcallhcstructkvm_hvhvto_kvm_hvvcpukvmstructeventfd_ctxeventfdifunlikelyhcfastintretgpa_tgpahcingpaifgpa__alignof__hcingpa1offset_in_pagegpasizeofhcingpaPAGE_SIZEreturnHV_STATUS_INVALID_ALIGNMENTretkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "return kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &hv_vcpu->vp_assist_page, sizeof(struct hv_vp_assist_page)); } EXPORT_SYMBOL_FOR_KVM_INTERNAL(kvm_hv_get_assist_page); static void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "return kvm_read_guest(kvm, hc->ingpa + hc->data_offset, data, cnt * sizeof(*data)); } static u64 kvm_get_sparse_vp_set(struct kvm *kvm, struct kvm_hv_hcall *hc, u64 *sparse_banks)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_sse_reg",
      "signature": "kvm_read_sse_reg",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_vapic_msr_read",
      "signature": "return kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata); case HV_X64_MSR_ICR: return kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata); case HV_X64_MSR_TPR: return kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata); case HV_X64_MSR_VP_ASSIST_PAGE: data = hv_vcpu->hv_vapic; break; case HV_X64_MSR_VP_RUNTIME: data = current_task_runtime_100ns() + hv_vcpu->runtime_offset; break; case HV_X64_MSR_SCONTROL: case HV_X64_MSR_SVERSION: case HV_X64_MSR_SIEFP: case HV_X64_MSR_SIMP: case HV_X64_MSR_EOM: case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: return synic_get_msr(to_hv_synic(vcpu), msr, pdata, host)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_hypercall_read_xmm",
      "signature": "void kvm_hv_hypercall_read_xmm(struct kvm_hv_hcall *hc)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r8_read",
      "signature": "kvm_r8_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbx_read",
      "signature": "kvm_rbx_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdi_read",
      "signature": "kvm_rdi_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsi_read",
      "signature": "kvm_rsi_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestkvmgfn_to_gpa",
      "signature": "read_guestkvmgfn_to_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestkvmhcingpa",
      "signature": "read_guestkvmhcingpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "signature": "read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpugpa",
      "signature": "read_guestvcpugpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pic_read_irq",
      "signature": "return kvm_pic_read_irq(v->kvm); /* PIC */ #endif WARN_ON_ONCE(!irqchip_split(v->kvm)); return get_userspace_extint(v); } EXPORT_SYMBOL_FOR_KVM_INTERNAL(kvm_cpu_get_extint); /* * Read pending interrupt vector and intack. */ int kvm_cpu_get_interrupt(struct kvm_vcpu *v)",
      "file": "arch/x86/kvm/irq.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_cpu_capsNR_KVM_CPU_CAPS__read_mostly",
      "signature": "kvm_cpu_capsNR_KVM_CPU_CAPS__read_mostly",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read",
      "signature": "kvm_msr_read",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "return kvm_read_cr3(vcpu) & (X86_CR3_LAM_U48 | X86_CR3_LAM_U57); } static inline void kvm_mmu_load_pgd(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_get_pcidvcpukvm_read_cr3",
      "signature": "kvm_get_pcidvcpukvm_read_cr3",
      "file": "arch/x86/kvm/mmu.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_xen_schedop_pollstructkvm_vcpuvcpuboollongmodeu64paramu64rstructsched_pollsched_pollevtchn_port_tportportsstructx86_exceptioneintiiflapic_in_kernelvcpuvcpukvmarchxenhvm_configflagsKVM_XEN_HVM_CONFIG_EVTCHN_SENDreturnfalseifIS_ENABLEDCONFIG_64BITlongmodestructcompat_sched_pollsp32SanitycheckthatthecompatstructdefinitioniscorrectBUILD_BUG_ONsizeofsp3216ifkvm_read_guest_virt",
      "signature": "kvm_xen_schedop_pollstructkvm_vcpuvcpuboollongmodeu64paramu64rstructsched_pollsched_pollevtchn_port_tportportsstructx86_exceptioneintiiflapic_in_kernelvcpuvcpukvmarchxenhvm_configflagsKVM_XEN_HVM_CONFIG_EVTCHN_SENDreturnfalseifIS_ENABLEDCONFIG_64BITlongmodestructcompat_sched_pollsp32SanitycheckthatthecompatstructdefinitioniscorrectBUILD_BUG_ONsizeofsp3216ifkvm_read_guest_virt",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_xen_hcall_evtchn_sendstructkvm_vcpuvcpuu64paramu64rstructevtchnfdevtchnfdstructevtchn_sendsendstructx86_exceptioneSanitycheckthisstructureisthesamefor32bitand64bitBUILD_BUG_ONsizeofsend4ifkvm_read_guest_virt",
      "signature": "kvm_xen_hcall_evtchn_sendstructkvm_vcpuvcpuu64paramu64rstructevtchnfdevtchnfdstructevtchn_sendsendstructx86_exceptioneSanitycheckthisstructureisthesamefor32bitand64bitBUILD_BUG_ONsizeofsend4ifkvm_read_guest_virt",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "kvm_read_guest_virt",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbx_read",
      "signature": "kvm_rbx_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsi_read",
      "signature": "kvm_rsi_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdi_read",
      "signature": "kvm_rdi_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbp_read",
      "signature": "kvm_rbp_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r10_read",
      "signature": "kvm_r10_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r8_read",
      "signature": "kvm_r8_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r9_read",
      "signature": "kvm_r9_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virt",
      "signature": "read_guest_virt",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virtvcpugva",
      "signature": "read_guest_virtvcpugva",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "avic_vcpu_putstructkvm_vcpuvcpuNotereadingthePhys",
      "signature": "avic_vcpu_putstructkvm_vcpuvcpuNotereadingthePhys",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_read"
    },
    {
      "function": "avic_vcpu_blockingstructkvm_vcpuvcpuifkvm_vcpu_apicv_activevcpureturnUnloadtheAVICwhenthevCPUisabouttoblock_before_thevCPUactuallyblocksNoteanyIRQsthatarrivebeforeIsRunning0willnotcauseanincompleteIPIvmexitonthesourcekvm_vcpu_check_blockhandlesthisbycheckingvIRRonelasttimebeforeblockingThememorybarrierimplicitinset_current_stateorderswritingIsRunning0beforereadingthevIRRTheprocessorneedsamatchingmem",
      "signature": "avic_vcpu_blockingstructkvm_vcpuvcpuifkvm_vcpu_apicv_activevcpureturnUnloadtheAVICwhenthevCPUisabouttoblock_before_thevCPUactuallyblocksNoteanyIRQsthatarrivebeforeIsRunning0willnotcauseanincompleteIPIvmexitonthesourcekvm_vcpu_check_blockhandlesthisbycheckingvIRRonelasttimebeforeblockingThememorybarrierimplicitinset_current_stateorderswritingIsRunning0beforereadingthevIRRTheprocessorneedsamatchingmem",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_read"
    },
    {
      "function": "snp_handle_ext_guest_reqstructvcpu_svmsvmgpa_treq_gpagpa_tresp_gpastructkvmkvmsvmvcpukvmu8msg_typeifsev_snp_guestkvmreturnEINVALifkvm_read_guestkvmreq_gpa",
      "signature": "snp_handle_ext_guest_reqstructvcpu_svmsvmgpa_treq_gpagpa_tresp_gpastructkvmkvmsvmvcpukvmu8msg_typeifsev_snp_guestkvmreturnEINVALifkvm_read_guestkvmreq_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "kvm_read_guest",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "kvm_sev_es_mmio_read",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestsvmvcpukvmscratch_gpa",
      "signature": "read_guestsvmvcpukvmscratch_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestkvmreq_gpa",
      "signature": "read_guestkvmreq_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_and_reset_apf_flags",
      "signature": "kvm_read_and_reset_apf_flags",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_READ",
      "signature": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_READ",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_skinitto_svmvcpuvmcbsaveripkvm_rax_read",
      "signature": "kvm_skinitto_svmvcpuvmcbsaveripkvm_rax_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_cr_read",
      "signature": "kvm_cr_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_drvcpudrkvm_register_read",
      "signature": "kvm_set_drvcpudrkvm_register_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "nested_svm_get_tdp_pdptrstructkvm_vcpuvcpuintindexstructvcpu_svmsvmto_svmvcpuu64cr3svmnestedctlnested_cr3u64pdpteintretNotenCR3isassumedtobe32bytealignedietheCPUignoresnCR340whenloadingPDPTEsfrommemoryretkvm_vcpu_read_guest_pagevcpugpa",
      "signature": "nested_svm_get_tdp_pdptrstructkvm_vcpuvcpuintindexstructvcpu_svmsvmto_svmvcpuu64cr3svmnestedctlnested_cr3u64pdpteintretNotenCR3isassumedtobe32bytealignedietheCPUignoresnCR340whenloadingPDPTEsfrommemoryretkvm_vcpu_read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "fori0inested_svm_nr_msrpm_merge_offsetsiconstintpnested_svm_msrpm_merge_offsetsinsvm_msrpm_merge_tl1_valgpa_tgpagpasvmnestedctlmsrpm_base_papsizeofl1_valifkvm_vcpu_read_guestvcpugpa",
      "signature": "fori0inested_svm_nr_msrpm_merge_offsetsiconstintpnested_svm_msrpm_merge_offsetsinsvm_msrpm_merge_tl1_valgpa_tgpagpasvmnestedctlmsrpm_base_papsizeofl1_valifkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "nested_svm_intercept_ioiostructvcpu_svmsvmunsignedportsizeiopm_lenu16valmasku8start_bitu64gpaifvmcb12_is_interceptsvmnestedctlINTERCEPT_IOIO_PROTreturnNESTED_EXIT_HOSTportsvmvmcbcontrolexit_info_116sizesvmvmcbcontrolexit_info_1SVM_IOIO_SIZE_MASKSVM_IOIO_SIZE_SHIFTgpasvmnestedctliopm_base_paport8start_bitport8iopm_lenstart_bitsize821mask0xf4sizestart_bitval0ifkvm_vcpu_read_guestsvmvcpugpa",
      "signature": "nested_svm_intercept_ioiostructvcpu_svmsvmunsignedportsizeiopm_lenu16valmasku8start_bitu64gpaifvmcb12_is_interceptsvmnestedctlINTERCEPT_IOIO_PROTreturnNESTED_EXIT_HOSTportsvmvmcbcontrolexit_info_116sizesvmvmcbcontrolexit_info_1SVM_IOIO_SIZE_MASKSVM_IOIO_SIZE_SHIFTgpasvmnestedctliopm_base_paport8start_bitport8iopm_lenstart_bitsize821mask0xf4sizestart_bitval0ifkvm_vcpu_read_guestsvmvcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsp_read",
      "signature": "kvm_rsp_read",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_pagevcpugpa",
      "signature": "read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpugpa",
      "signature": "read_guestvcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestsvmvcpugpa",
      "signature": "read_guestsvmvcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdp_mmu_read_spte",
      "signature": "u64 kvm_tdp_mmu_read_spte(tdp_ptep_t sptep)",
      "file": "arch/x86/kvm/mmu/tdp_iter.h",
      "category": "memory_read"
    },
    {
      "function": "host_pfn_mapping_levelstructkvmkvmgfn_tgfnconststructkvm_memory_slotslotintlevelPG_LEVEL_4Kunsignedlonghvaunsignedlongflagspgd_tpgdp4d_tp4dpud_tpudpmd_tpmdNoteusingthealreadyretrievedmemslotand__gfn_to_hva_memslotisnotsolelyforperformanceitsalsonecessarytoavoidthewritablecheckin__gfn_to_hva_manywhichwillalwaysfailonreadonlymemslotsduetogfn_to_hvaassumingwritesEarlierpagefaultstepshavealreadyverifiedtheguestisntwritingareadonlymemslothva__gfn_to_hva_memslotslotgfnDisableIRQstopreventconcurrentteardownofhostpagetablesegiftheprimaryMMUpromotesaPDtoahugepageandthenfreestheoriginalpagetablelocal_irq_saveflagsReadeachentryonceAsaboveanonleafentrycanbepromotedtoahugepage_during_thiswalkRereadingtheentrycouldsendthewalkintotheweeksegpd_leafreturnsfalseseestheoldvalueandthenpd_offsetwalksintothetargethugepageinsteadoftheoldpagetableseesthenewvaluepgdREAD_ONCEpgd_offsetkvmmmhvaifpgd_nonepgdgotooutp4dREAD_ONCEp4d_offsetpgdhvaifp4d_nonep4dp4d_presentp4dgotooutpudREAD_ONCEpud_offsetp4dhva",
      "signature": "host_pfn_mapping_levelstructkvmkvmgfn_tgfnconststructkvm_memory_slotslotintlevelPG_LEVEL_4Kunsignedlonghvaunsignedlongflagspgd_tpgdp4d_tp4dpud_tpudpmd_tpmdNoteusingthealreadyretrievedmemslotand__gfn_to_hva_memslotisnotsolelyforperformanceitsalsonecessarytoavoidthewritablecheckin__gfn_to_hva_manywhichwillalwaysfailonreadonlymemslotsduetogfn_to_hvaassumingwritesEarlierpagefaultstepshavealreadyverifiedtheguestisntwritingareadonlymemslothva__gfn_to_hva_memslotslotgfnDisableIRQstopreventconcurrentteardownofhostpagetablesegiftheprimaryMMUpromotesaPDtoahugepageandthenfreestheoriginalpagetablelocal_irq_saveflagsReadeachentryonceAsaboveanonleafentrycanbepromotedtoahugepage_during_thiswalkRereadingtheentrycouldsendthewalkintotheweeksegpd_leafreturnsfalseseestheoldvalueandthenpd_offsetwalksintothetargethugepageinsteadoftheoldpagetableseesthenewvaluepgdREAD_ONCEpgd_offsetkvmmmhvaifpgd_nonepgdgotooutp4dREAD_ONCEp4d_offsetpgdhvaifp4d_nonep4dp4d_presentp4dgotooutpudREAD_ONCEpud_offsetp4dhva",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "is_obsolete_rootstructkvmkvmhpa_troot_hpastructkvm_mmu_pagespifVALID_PAGEroot_hpareturnfalseWhenfreeingobsoleterootstreatrootsasobsoleteiftheydonthaveanassociatedshadowpageasitsimpossibletodetermineifsuchrootsarefreshorstaleThisdoesmeanKVMwillgetfalsepositivesandfreerootsthatdontstrictlyneedtobefreedbutsuchfalsepositivesarerelativelyrareaonlyPAEpagingandnestedNPThaverootswithoutshadowpagesoranyshadowpagingflavorwithadummyrootseenotebelowbremotereloadsduetoamem",
      "signature": "is_obsolete_rootstructkvmkvmhpa_troot_hpastructkvm_mmu_pagespifVALID_PAGEroot_hpareturnfalseWhenfreeingobsoleterootstreatrootsasobsoleteiftheydonthaveanassociatedshadowpageasitsimpossibletodetermineifsuchrootsarefreshorstaleThisdoesmeanKVMwillgetfalsepositivesandfreerootsthatdontstrictlyneedtobefreedbutsuchfalsepositivesarerelativelyrareaonlyPAEpagingandnestedNPThaverootswithoutshadowpagesoranyshadowpagingflavorwithadummyrootseenotebelowbremotereloadsduetoamem",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "ifbytes4bytes8rkvm_vcpu_read_guest_atomicvcpugpa",
      "signature": "ifbytes4bytes8rkvm_vcpu_read_guest_atomicvcpugpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytesgfn_tgfngpaPAGE_SHIFTstructkvm_mmu_pagespLIST_HEADinvalid_listu64entrygentryspteintnpteboolflushfalseWhenemulatingguestwritesensurethewrittenvalueisvisibletoanytaskthatishandlingpagefaultsbeforecheckingwhetherornotKVMisshadowingaguestPTEThisensureseitherKVMwillcreatethecorrectSPTEinthepagefaulthandlerorthistaskwillseeanonzeroindirect_shadow_pagesPairswiththesmp_mbinaccount_shadowedsmp_mbifvcpukvmarchindirect_shadow_pagesreturnwrite_lockvcpukvmmmu_lockgentrymmu_pte_write_fetch_gptevcpugpa",
      "signature": "kvm_mmu_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytesgfn_tgfngpaPAGE_SHIFTstructkvm_mmu_pagespLIST_HEADinvalid_listu64entrygentryspteintnpteboolflushfalseWhenemulatingguestwritesensurethewrittenvalueisvisibletoanytaskthatishandlingpagefaultsbeforecheckingwhetherornotKVMisshadowingaguestPTEThisensureseitherKVMwillcreatethecorrectSPTEinthepagefaulthandlerorthistaskwillseeanonzeroindirect_shadow_pagesPairswiththesmp_mbinaccount_shadowedsmp_mbifvcpukvmarchindirect_shadow_pagesreturnwrite_lockvcpukvmmmu_lockgentrymmu_pte_write_fetch_gptevcpugpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_sp_dirty_logging_enabledstructkvmkvmstructkvm_mmu_pagespstructkvm_memory_slotslotSkipthememslotlookupifdirtytrackingcantpossiblybeenabledasmemslotlookupsarerelativelyexpensiveIfamemslotupdateisinprogressreadinganincorrectvalueofkvmnr_memslots_dirty_loggingisnotaproblemifitisbecomingzeroKVMwilldoanunnecessarymemslotlookupifitisbecomingnonzerothepagewillbezappedunnecessarilyEitherwaythisonlyaffectsefficiencyinracysituationsandnotcorrectnessifatomic_readkvmnr_mem",
      "signature": "kvm_mmu_sp_dirty_logging_enabledstructkvmkvmstructkvm_mmu_pagespstructkvm_memory_slotslotSkipthememslotlookupifdirtytrackingcantpossiblybeenabledasmemslotlookupsarerelativelyexpensiveIfamemslotupdateisinprogressreadinganincorrectvalueofkvmnr_memslots_dirty_loggingisnotaproblemifitisbecomingzeroKVMwilldoanunnecessarymemslotlookupifitisbecomingnonzerothepagewillbezappedunnecessarilyEitherwaythisonlyaffectsefficiencyinracysituationsandnotcorrectnessifatomic_readkvmnr_mem",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0_bits",
      "signature": "kvm_read_cr0_bits",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4_bits",
      "signature": "kvm_read_cr4_bits",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "return kvm_read_cr3(vcpu); } static inline unsigned long kvm_mmu_get_guest_pgd(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rmap_lock_readonly",
      "signature": "long kvm_rmap_lock_readonly(struct kvm_rmap_head *rmap_head)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rmap_unlock_readonly",
      "signature": "void kvm_rmap_unlock_readonly(struct kvm_rmap_head *rmap_head, unsigned long old_val)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_async_page_ready",
      "signature": "void kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MEM_READONLY",
      "signature": "KVM_MEM_READONLY",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pdptr_read",
      "signature": "kvm_pdptr_read",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_atomic",
      "signature": "kvm_vcpu_read_guest_atomic",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicvcpugpa",
      "signature": "read_guest_atomicvcpugpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdp_mmu_read_spte",
      "signature": "kvm_tdp_mmu_read_spte",
      "file": "arch/x86/kvm/mmu/tdp_iter.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MMU_WARN_ONatomic64_read",
      "signature": "KVM_MMU_WARN_ONatomic64_read",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdp_mmu_read_spte",
      "signature": "kvm_tdp_mmu_read_spte",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_read"
    },
    {
      "function": "iflevelPG_LEVEL_4KmaskPTE_PREFETCH_NUMsizeofpt_element_t1base_gpapte_gpamaskindexpte_gpabase_gpasizeofpt_element_trkvm_vcpu_read_guest_atomicvcpubase_gpa",
      "signature": "iflevelPG_LEVEL_4KmaskPTE_PREFETCH_NUMsizeofpt_element_t1base_gpapte_gpamaskindexpte_gpabase_gpasizeofpt_element_trkvm_vcpu_read_guest_atomicvcpubase_gpa",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_atomic",
      "signature": "kvm_vcpu_read_guest_atomic",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicvcpubase_gpa",
      "signature": "read_guest_atomicvcpubase_gpa",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicvcpupte_gpa",
      "signature": "read_guest_atomicvcpupte_gpa",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "memory_read"
    },
    {
      "function": "sgx_gva_to_gpastructkvm_vcpuvcpugva_tgvaboolwritegpa_tgpastructx86_exceptionexifwritegpakvm_mmu_gva_to_gpa_writevcpugvaexelsegpakvm_mmu_gva_to_gpa_readvcpugva",
      "signature": "sgx_gva_to_gpastructkvm_vcpuvcpugva_tgvaboolwritegpa_tgpastructx86_exceptionexifwritegpakvm_mmu_gva_to_gpa_writevcpugvaexelsegpakvm_mmu_gva_to_gpa_readvcpugva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "handle_encls_ecreatestructkvm_vcpuvcpugva_tpageinfo_gvasecs_gvagva_tmetadata_gvacontents_gvagpa_tmetadata_gpacontents_gpasecs_gpaunsignedlongmetadata_hvacontents_hvasecs_hvastructsgx_pageinfopageinfostructsgx_secscontentsstructx86_exceptionexintrifsgx_get_encls_gvavcpukvm_rbx_readvcpu3232pageinfo_gvasgx_get_encls_gvavcpukvm_rcx_readvcpu40964096secs_gvareturn1CopythePAGEINFOtolocalmemoryitspointersneedtobetranslatedieweneedtodoadeepcopytranslaterkvm_read_guest_virtvcpupageinfo_gva",
      "signature": "handle_encls_ecreatestructkvm_vcpuvcpugva_tpageinfo_gvasecs_gvagva_tmetadata_gvacontents_gvagpa_tmetadata_gpacontents_gpasecs_gpaunsignedlongmetadata_hvacontents_hvasecs_hvastructsgx_pageinfopageinfostructsgx_secscontentsstructx86_exceptionexintrifsgx_get_encls_gvavcpukvm_rbx_readvcpu3232pageinfo_gvasgx_get_encls_gvavcpukvm_rcx_readvcpu40964096secs_gvareturn1CopythePAGEINFOtolocalmemoryitspointersneedtobetranslatedieweneedtodoadeepcopytranslaterkvm_read_guest_virtvcpupageinfo_gva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "handle_encls_einitstructkvm_vcpuvcpuunsignedlongsig_hvasecs_hvatoken_hvarflagsstructvcpu_vmxvmxto_vmxvcpugva_tsig_gvasecs_gvatoken_gvagpa_tsig_gpasecs_gpatoken_gpaintrettrapnrifsgx_get_encls_gvavcpukvm_rbx_readvcpu18084096sig_gvasgx_get_encls_gvavcpukvm_rcx_readvcpu40964096secs_gvasgx_get_encls_gvavcpukvm_rdx_readvcpu304512token_gva",
      "signature": "handle_encls_einitstructkvm_vcpuvcpuunsignedlongsig_hvasecs_hvatoken_hvarflagsstructvcpu_vmxvmxto_vmxvcpugva_tsig_gvasecs_gvatoken_gvagpa_tsig_gpasecs_gpatoken_gpaintrettrapnrifsgx_get_encls_gvavcpukvm_rbx_readvcpu18084096sig_gvasgx_get_encls_gvavcpukvm_rcx_readvcpu40964096secs_gvasgx_get_encls_gvavcpukvm_rdx_readvcpu304512token_gva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "kvm_read_guest_virt",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_read",
      "signature": "kvm_mmu_gva_to_gpa_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbx_read",
      "signature": "kvm_rbx_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virtvcpupageinfo_gva",
      "signature": "read_guest_virtvcpupageinfo_gva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "tdx_complete_mmio_readstructkvm_vcpuvcpuunsignedlongval0gpa_tgpaintsizegpavcpummio_fragments0gpasizevcpummio_fragments0lenmemcpyvalvcpurunmmiodatasizetdvmcall_set_return_valvcpuvaltrace_kvm_mmioKVM_TRACE_MMIO_READsizegpa",
      "signature": "tdx_complete_mmio_readstructkvm_vcpuvcpuunsignedlongval0gpa_tgpaintsizegpavcpummio_fragments0gpasizevcpummio_fragments0lenmemcpyvalvcpurunmmiodatasizetdvmcall_set_return_valvcpuvaltrace_kvm_mmioKVM_TRACE_MMIO_READsizegpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "tdx_mmio_readstructkvm_vcpuvcpugpa_tgpaintsizeunsignedlongvalifkvm_io_bus_readvcpuKVM_MMIO_BUSgpasizevalreturnEOPNOTSUPPtdvmcall_set_return_valvcpuvaltrace_kvm_mmioKVM_TRACE_MMIO_READsizegpa",
      "signature": "tdx_mmio_readstructkvm_vcpuvcpugpa_tgpaintsizeunsignedlongvalifkvm_io_bus_readvcpuKVM_MMIO_BUSgpasizevalreturnEOPNOTSUPPtdvmcall_set_return_valvcpuvaltrace_kvm_mmioKVM_TRACE_MMIO_READsizegpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "tdx_emulate_mmiostructkvm_vcpuvcpustructvcpu_tdxtdxto_tdxvcpuintsizewriterunsignedlongvalgpa_tgpasizetdxvp_enter_argsr12writetdxvp_enter_argsr13gpatdxvp_enter_argsr14valwritetdxvp_enter_argsr150ifsize1size2size4size8gotoerrorifwrite0write1gotoerrorTDGVPVMCALLMMIOallowsonlysharedGPAitmakesnosensetodoMMIOemulationforprivateGPAifvt_is_tdx_private_gpavcpukvmgpavt_is_tdx_private_gpavcpukvmgpasize1gotoerrorgpagpagfn_to_gpakvm_gfn_direct_bitsvcpukvmifwritertdx_mmio_writevcpugpasizevalelsertdx_mmio_readvcpugpa",
      "signature": "tdx_emulate_mmiostructkvm_vcpuvcpustructvcpu_tdxtdxto_tdxvcpuintsizewriterunsignedlongvalgpa_tgpasizetdxvp_enter_argsr12writetdxvp_enter_argsr13gpatdxvp_enter_argsr14valwritetdxvp_enter_argsr150ifsize1size2size4size8gotoerrorifwrite0write1gotoerrorTDGVPVMCALLMMIOallowsonlysharedGPAitmakesnosensetodoMMIOemulationforprivateGPAifvt_is_tdx_private_gpavcpukvmgpavt_is_tdx_private_gpavcpukvmgpasize1gotoerrorgpagpagfn_to_gpakvm_gfn_direct_bitsvcpukvmifwritertdx_mmio_writevcpugpasizevalelsertdx_mmio_readvcpugpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_edx_eax",
      "signature": "kvm_read_edx_eax",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_io_bus_read",
      "signature": "kvm_io_bus_read",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_BUG_ONatomic64_read",
      "signature": "KVM_BUG_ONatomic64_read",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdxtsc_offsettd_tdcs_exec_read64",
      "signature": "kvm_tdxtsc_offsettd_tdcs_exec_read64",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdxtsc_multipliertd_tdcs_exec_read64",
      "signature": "kvm_tdxtsc_multipliertd_tdcs_exec_read64",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "READ_UNSATISFIEDsizegpa",
      "signature": "READ_UNSATISFIEDsizegpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "vmcs_loadstructvmcsvmcsu64phys_addr__pavmcsifkvm_is_using_evmcsreturnevmcs_loadphys",
      "signature": "vmcs_loadstructvmcsvmcsu64phys_addr__pavmcsifkvm_is_using_evmcsreturnevmcs_loadphys",
      "file": "arch/x86/kvm/vmx/vmx_ops.h",
      "category": "memory_read"
    },
    {
      "function": "handle_ept_violationstructkvm_vcpuvcpuunsignedlongexit_qualificationvmx_get_exit_qualvcpugpa_tgpaEPTviolationhappenedwhileexecutingiretfromNMIblockedbyNMIbithastobesetbeforenextVMentryThereareerratathatmaycausethisbittonotbesetAAK134BY25ifto_vmxvcpuidt_vectoring_infoVECTORING_INFO_VALID_MASKenable_vnmiexit_qualificationINTR_INFO_UNBLOCK_NMIvmcs_set_bitsGUEST_INTERRUPTIBILITY_INFOGUEST_INTR_STATE_NMIgpavmcs_read64GUEST_PHYS",
      "signature": "handle_ept_violationstructkvm_vcpuvcpuunsignedlongexit_qualificationvmx_get_exit_qualvcpugpa_tgpaEPTviolationhappenedwhileexecutingiretfromNMIblockedbyNMIbithastobesetbeforenextVMentryThereareerratathatmaycausethisbittonotbesetAAK134BY25ifto_vmxvcpuidt_vectoring_infoVECTORING_INFO_VALID_MASKenable_vnmiexit_qualificationINTR_INFO_UNBLOCK_NMIvmcs_set_bitsGUEST_INTERRUPTIBILITY_INFOGUEST_INTR_STATE_NMIgpavmcs_read64GUEST_PHYS",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "handle_ept_misconfigstructkvm_vcpuvcpugpa_tgpaifvmx_check_emulate_instructionvcpuEMULTYPE_PFNULL0return1AnestedguestcannotoptimizeMMIOvmexitsbecausewehaveannGPAhereinsteadoftherequiredGPAgpavmcs_read64GUEST_PHYS",
      "signature": "handle_ept_misconfigstructkvm_vcpuvcpugpa_tgpaifvmx_check_emulate_instructionvcpuEMULTYPE_PFNULL0return1AnestedguestcannotoptimizeMMIOvmexitsbecausewehaveannGPAhereinsteadoftherequiredGPAgpavmcs_read64GUEST_PHYS",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "__vmx_handle_exitstructkvm_vcpuvcpufastpath_texit_fastpathstructvcpu_vmxvmxto_vmxvcpuunionvmx_exit_reasonexit_reasonvmx_get_exit_reasonvcpuu32vectoring_infovmxidt_vectoring_infou16exit_handler_indexFlushloggedGPAsPMLbufferthiswillmakedirty_bitmapmoreupdatedAnothergoodisinkvm_vm_ioctl_get_dirty_logbeforequeryingdirty_bitmapweonlyneedtokickallvcpusoutofguestmodeasifvcpusisinrootmodethePMLbuffermusthasbeenflushedalreadyNotePMLisneverenabledinhardwarewhilerunningL2ifenable_pmlis_guest_modevcpuvmx_flush_pml_buffervcpuKVMshouldneverreachthispointwithapendingnestedVMEnterMorespecificallyshortcircuitingVMEntrytoemulateL2duetoinvalidgueststateshouldneverhappenasthatmeansKVMknowinglyallowedanestedVMEnterwithaninvalidvmcs12MorebelowifKVM_BUG_ONvmxnestednested_run_pendingvcpukvmreturnEIOifis_guest_modevcpuPMLisneverenabledwhenrunningL2bailimmediatelyifaPMLfullexitoccursassomethingishorriblywrongifexit_reasonbasicEXIT_REASON_PML_FULLgotounexpected_vmexitThehostphysicaladdressesofsomepagesofguestmemoryareloadedintothevmcs02egvmcs12sVirt",
      "signature": "__vmx_handle_exitstructkvm_vcpuvcpufastpath_texit_fastpathstructvcpu_vmxvmxto_vmxvcpuunionvmx_exit_reasonexit_reasonvmx_get_exit_reasonvcpuu32vectoring_infovmxidt_vectoring_infou16exit_handler_indexFlushloggedGPAsPMLbufferthiswillmakedirty_bitmapmoreupdatedAnothergoodisinkvm_vm_ioctl_get_dirty_logbeforequeryingdirty_bitmapweonlyneedtokickallvcpusoutofguestmodeasifvcpusisinrootmodethePMLbuffermusthasbeenflushedalreadyNotePMLisneverenabledinhardwarewhilerunningL2ifenable_pmlis_guest_modevcpuvmx_flush_pml_buffervcpuKVMshouldneverreachthispointwithapendingnestedVMEnterMorespecificallyshortcircuitingVMEntrytoemulateL2duetoinvalidgueststateshouldneverhappenasthatmeansKVMknowinglyallowedanestedVMEnterwithaninvalidvmcs12MorebelowifKVM_BUG_ONvmxnestednested_run_pendingvcpukvmreturnEIOifis_guest_modevcpuPMLisneverenabledwhenrunningL2bailimmediatelyifaPMLfullexitoccursassomethingishorriblywrongifexit_reasonbasicEXIT_REASON_PML_FULLgotounexpected_vmexitThehostphysicaladdressesofsomepagesofguestmemoryareloadedintothevmcs02egvmcs12sVirt",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_ldt",
      "signature": "kvm_read_ldt",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0_bits",
      "signature": "kvm_read_cr0_bits",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_and_reset_apf_flags",
      "signature": "kvm_read_and_reset_apf_flags",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_READ",
      "signature": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_READ",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_readable_reg_mask",
      "signature": "kvm_lapic_readable_reg_mask",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rundebugarchdr7vmcs_readl",
      "signature": "kvm_rundebugarchdr7vmcs_readl",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_cr_read",
      "signature": "kvm_cr_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_cr_write0kvm_read_cr0_bits",
      "signature": "kvm_cr_write0kvm_read_cr0_bits",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_drvcpudrkvm_register_read",
      "signature": "kvm_set_drvcpudrkvm_register_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "nested_vmx_load_msrstructkvm_vcpuvcpuu64gpau32countu32istructvmx_msr_entryeu32max_msr_list_sizenested_vmx_max_atomic_switch_msrsvcpufori0icountiifWARN_ON_ONCEimax_msr_list_sizegotofailifkvm_vcpu_read_guestvcpugpa",
      "signature": "nested_vmx_load_msrstructkvm_vcpuvcpuu64gpau32countu32istructvmx_msr_entryeu32max_msr_list_sizenested_vmx_max_atomic_switch_msrsvcpufori0icountiifWARN_ON_ONCEimax_msr_list_sizegotofailifkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "nested_vmx_store_msrstructkvm_vcpuvcpuu64gpau32countu64datau32istructvmx_msr_entryeu32max_msr_list_sizenested_vmx_max_atomic_switch_msrsvcpufori0icountiifWARN_ON_ONCEimax_msr_list_sizereturnEINVALifread_and_check_msr_entryvcpugpa",
      "signature": "nested_vmx_store_msrstructkvm_vcpuvcpuu64gpau32countu64datau32istructvmx_msr_entryeu32max_msr_list_sizenested_vmx_max_atomic_switch_msrsvcpufori0icountiifWARN_ON_ONCEimax_msr_list_sizereturnEINVALifread_and_check_msr_entryvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "nested_msr_store_list_has_msrstructkvm_vcpuvcpuu32msr_indexstructvmcs12vmcs12get_vmcs12vcpuu32countvmcs12vm_exit_msr_store_countu64gpavmcs12vm_exit_msr_store_addrstructvmx_msr_entryeu32ifori0icountiifread_and_check_msr_entryvcpugpa",
      "signature": "nested_msr_store_list_has_msrstructkvm_vcpuvcpuu32msr_indexstructvmcs12vmcs12get_vmcs12vcpuu32countvmcs12vm_exit_msr_store_countu64gpavmcs12vm_exit_msr_store_addrstructvmx_msr_entryeu32ifori0icountiifread_and_check_msr_entryvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "fori0ivmcs12vm_entry_msr_load_countigpavmcs12vm_entry_msr_load_addrisizeofgifkvm_vcpu_read_guestvcpugpa",
      "signature": "fori0ivmcs12vm_entry_msr_load_countigpavmcs12vm_entry_msr_load_addrisizeofgifkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "forj0jvmcs12vm_exit_msr_load_countjgpavmcs12vm_exit_msr_load_addrjsizeofhifkvm_vcpu_read_guestvcpugpa",
      "signature": "forj0jvmcs12vm_exit_msr_load_countjgpavmcs12vm_exit_msr_load_addrjsizeofhifkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "handle_vmwritestructkvm_vcpuvcpustructvmcs12vmcs12is_guest_modevcpuget_shadow_vmcs12vcpuget_vmcs12vcpuunsignedlongexit_qualificationvmx_get_exit_qualvcpuu32instr_infovmcs_read32VMX_INSTRUCTION_INFOstructvcpu_vmxvmxto_vmxvcpustructx86_exceptioneunsignedlongfieldshortoffsetgva_tgvaintlenrThevaluetowritemightbe32or64bitsdependingonL1slongmodeandeventuallyweneedtowritethatintoafieldofseveralpossiblelengthsThecodebelowfirstzeroextendsthevalueto64bitvalueandthencopiesonlytheappropriatenumberofbitsintothevmcs12fieldu64value0ifnested_vmx_check_permissionvcpureturn1InVMXnonrootoperationwhentheVMCSlinkpointerisINVALID_GPAanyVMWRITEsetstheALUflagsforVMfailInvalidifvmxnestedcurrent_vmptrINVALID_GPAis_guest_modevcpuget_vmcs12vcpuvmcs_link_pointerINVALID_GPAreturnnested_vmx_failInvalidvcpuifinstr_infoBIT10valuekvm_register_readvcpuinstr_info30xfelselenis_64_bit_modevcpu84ifget_vmx_mem_addressvcpuexit_qualificationinstr_infofalselengvareturn1rkvm_read_guest_virtvcpugva",
      "signature": "handle_vmwritestructkvm_vcpuvcpustructvmcs12vmcs12is_guest_modevcpuget_shadow_vmcs12vcpuget_vmcs12vcpuunsignedlongexit_qualificationvmx_get_exit_qualvcpuu32instr_infovmcs_read32VMX_INSTRUCTION_INFOstructvcpu_vmxvmxto_vmxvcpustructx86_exceptioneunsignedlongfieldshortoffsetgva_tgvaintlenrThevaluetowritemightbe32or64bitsdependingonL1slongmodeandeventuallyweneedtowritethatintoafieldofseveralpossiblelengthsThecodebelowfirstzeroextendsthevalueto64bitvalueandthencopiesonlytheappropriatenumberofbitsintothevmcs12fieldu64value0ifnested_vmx_check_permissionvcpureturn1InVMXnonrootoperationwhentheVMCSlinkpointerisINVALID_GPAanyVMWRITEsetstheALUflagsforVMfailInvalidifvmxnestedcurrent_vmptrINVALID_GPAis_guest_modevcpuget_vmcs12vcpuvmcs_link_pointerINVALID_GPAreturnnested_vmx_failInvalidvcpuifinstr_infoBIT10valuekvm_register_readvcpuinstr_info30xfelselenis_64_bit_modevcpu84ifget_vmx_mem_addressvcpuexit_qualificationinstr_infofalselengvareturn1rkvm_read_guest_virtvcpugva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "kvm_read_guest_cached",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_offset_cached",
      "signature": "kvm_read_guest_offset_cached",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "kvm_read_guest_virt",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "kvm_read_guest",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pdptr_read",
      "signature": "kvm_pdptr_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_map_readonly",
      "signature": "kvm_vcpu_map_readonly",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_msr_read",
      "signature": "kvm_emulate_msr_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_nested_vmenterkvm_rip_read",
      "signature": "kvm_nested_vmenterkvm_rip_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsp_read",
      "signature": "kvm_rsp_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_drvcpu7vmcs_readl",
      "signature": "kvm_set_drvcpu7vmcs_readl",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpugpa",
      "signature": "read_guestvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_and_check_msr_entrystructkvm_vcpuvcpuu64gpa",
      "signature": "read_and_check_msr_entrystructkvm_vcpuvcpuu64gpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_and_check_msr_entryvcpugpa",
      "signature": "read_and_check_msr_entryvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virtvcpugva",
      "signature": "read_guest_virtvcpugva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_stats_read",
      "signature": "ssize_t kvm_stats_read(char *id, const struct kvm_stats_header *header, const struct _kvm_stats_desc *desc, void *stats, size_t size_stats, char __user *user_buffer, size_t size, loff_t *offset)",
      "file": "virt/kvm/binary_stats.c",
      "category": "memory_read"
    },
    {
      "function": "check_memory_region_flagsstructkvmkvmconststructkvm_userspace_memory_region2memu32valid_flagsKVM_MEM_LOG_DIRTY_PAGESifIS_ENABLEDCONFIG_KVM_GUEST_MEMFDvalid_flagsKVM_MEM_GUEST_MEMFDDirtyloggingprivatememoryisnotcurrentlysupportedifmemflagsKVM_MEM_GUEST_MEMFDvalid_flagsKVM_MEM_LOG_DIRTY_PAGESGUEST_MEMFDisincompatiblewithreadonlymemslotsaswritestoreadonlymemslotshaveemulatedMMIOnotpagefaultsemanticsandKVMdoesntallowemulatedMMIOforprivatememoryifkvm_arch_has_readonly_mem",
      "signature": "check_memory_region_flagsstructkvmkvmconststructkvm_userspace_memory_region2memu32valid_flagsKVM_MEM_LOG_DIRTY_PAGESifIS_ENABLEDCONFIG_KVM_GUEST_MEMFDvalid_flagsKVM_MEM_GUEST_MEMFDDirtyloggingprivatememoryisnotcurrentlysupportedifmemflagsKVM_MEM_GUEST_MEMFDvalid_flagsKVM_MEM_LOG_DIRTY_PAGESGUEST_MEMFDisincompatiblewithreadonlymemslotsaswritestoreadonlymemslotshaveemulatedMMIOnotpagefaultsemanticsandKVMdoesntallowemulatedMMIOforprivatememoryifkvm_arch_has_readonly_mem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_commit_memory_regionstructkvmkvmstructkvm_memory_slotoldconststructkvm_memory_slotnewenumkvm_mr_changechangeintold_flagsoldoldflags0intnew_flagsnewnewflags0UpdatethetotalnumberofmemslotpagesbeforecallingthearchhooksothatarchitecturescanconsumetheresultdirectlyifchangeKVM_MR_DELETEkvmnr_memslot_pagesoldnpageselseifchangeKVM_MR_CREATEkvmnr_memslot_pagesnewnpagesifold_flagsnew_flagsKVM_MEM_LOG_DIRTY_PAGESintchangenew_flagsKVM_MEM_LOG_DIRTY_PAGES11atomic_setkvmnr_memslots_dirty_loggingatomic_readkvmnr_mem",
      "signature": "kvm_commit_memory_regionstructkvmkvmstructkvm_memory_slotoldconststructkvm_memory_slotnewenumkvm_mr_changechangeintold_flagsoldoldflags0intnew_flagsnewnewflags0UpdatethetotalnumberofmemslotpagesbeforecallingthearchhooksothatarchitecturescanconsumetheresultdirectlyifchangeKVM_MR_DELETEkvmnr_memslot_pagesoldnpageselseifchangeKVM_MR_CREATEkvmnr_memslot_pagesnewnpagesifold_flagsnew_flagsKVM_MEM_LOG_DIRTY_PAGESintchangenew_flagsKVM_MEM_LOG_DIRTY_PAGES11atomic_setkvmnr_memslots_dirty_loggingatomic_readkvmnr_mem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_memslotstructkvmkvmstructkvm_memory_slotoldstructkvm_memory_slotnewenumkvm_mr_changechangestructkvm_memory_slotinvalid_slotintrReleasedinkvm_swap_active_memslotsMustbeheldfrombeforethecurrentmemslotsarecopieduntilafterthenewmemslotsareinstalledwithrcu_assign_pointerthenreleasedbeforethesynchronizesrcuinkvm_swap_active_memslotsWhenmodifyingmemslotsoutsideoftheslots_lockmustbeheldbeforereadingthepointertothecurrentmem",
      "signature": "kvm_set_memslotstructkvmkvmstructkvm_memory_slotoldstructkvm_memory_slotnewenumkvm_mr_changechangestructkvm_memory_slotinvalid_slotintrReleasedinkvm_swap_active_memslotsMustbeheldfrombeforethecurrentmemslotsarecopieduntilafterthenewmemslotsareinstalledwithrcu_assign_pointerthenreleasedbeforethesynchronizesrcuinkvm_swap_active_memslotsWhenmodifyingmemslotsoutsideoftheslots_lockmustbeheldbeforereadingthepointertothecurrentmem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_memory_regionstructkvmkvmconststructkvm_userspace_memory_region2memstructkvm_memory_slotoldnewstructkvm_memslotsslotsenumkvm_mr_changechangeunsignedlongnpagesgfn_tbase_gfnintas_ididintrlockdep_assert_heldkvmslots_lockrcheck_memory_region_flagskvmmemifrreturnras_idmemslot16idu16memslotGeneralsanitychecksifmemmemory_sizePAGE_SIZE1memmemory_sizeunsignedlongmemmemory_sizereturnEINVALifmemguest_phys_addrPAGE_SIZE1returnEINVALWecanreadtheguestmem",
      "signature": "kvm_set_memory_regionstructkvmkvmconststructkvm_userspace_memory_region2memstructkvm_memory_slotoldnewstructkvm_memslotsslotsenumkvm_mr_changechangeunsignedlongnpagesgfn_tbase_gfnintas_ididintrlockdep_assert_heldkvmslots_lockrcheck_memory_region_flagskvmmemifrreturnras_idmemslot16idu16memslotGeneralsanitychecksifmemmemory_sizePAGE_SIZE1memmemory_sizeunsignedlongmemmemory_sizereturnEINVALifmemguest_phys_addrPAGE_SIZE1returnEINVALWecanreadtheguestmem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_enable_virtualization_cpuvoidif__this_cpu_readvirt",
      "signature": "kvm_enable_virtualization_cpuvoidif__this_cpu_readvirt",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_disable_virtualization_cpuvoidignif__this_cpu_readvirt",
      "signature": "kvm_disable_virtualization_cpuvoidignif__this_cpu_readvirt",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_page",
      "signature": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_atomic",
      "signature": "kvm_read_guest_atomic",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_offset_cached",
      "signature": "int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MEM_LOG_DIRTY_PAGESKVM_MEM_READONLY",
      "signature": "KVM_MEM_LOG_DIRTY_PAGESKVM_MEM_READONLY",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_has_readonly_mem",
      "signature": "kvm_arch_has_readonly_mem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MEM_READONLY",
      "signature": "KVM_MEM_READONLY",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_GENERIC_DIRTYLOG_READ_PROTECT",
      "signature": "KVM_GENERIC_DIRTYLOG_READ_PROTECT",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_page",
      "signature": "KVM_INTERNALkvm_read_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_read_guest_page",
      "signature": "KVM_INTERNALkvm_vcpu_read_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest",
      "signature": "KVM_INTERNALkvm_read_guest",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_read_guest",
      "signature": "KVM_INTERNALkvm_vcpu_read_guest",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_atomic",
      "signature": "int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_read_guest_atomic",
      "signature": "KVM_INTERNALkvm_vcpu_read_guest_atomic",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_offset_cached",
      "signature": "KVM_INTERNALkvm_read_guest_offset_cached",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_cached",
      "signature": "KVM_INTERNALkvm_read_guest_cached",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_stats_read",
      "signature": "ssize_t kvm_vcpu_stats_read(struct file *file, char __user *user_buffer, size_t size, loff_t *offset)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_stats_read",
      "signature": "return kvm_stats_read(vcpu->stats_id, &kvm_vcpu_stats_header, &kvm_vcpu_stats_desc[0], &vcpu->stat, sizeof(vcpu->stat), user_buffer, size, offset); } static int kvm_vcpu_stats_release(struct inode *inode, struct file *file)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vm_stats_read",
      "signature": "ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer, size_t size, loff_t *offset)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_io_bus_read",
      "signature": "int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, void *val)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_iodevice_read",
      "signature": "kvm_iodevice_read",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_io_bus_read",
      "signature": "KVM_INTERNALkvm_io_bus_read",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "read_gueststructkvmkvmgpa_tgpa",
      "signature": "read_gueststructkvmkvmgpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "read_gueststructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_gueststructkvm_vcpuvcpugpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicstructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_guest_atomicstructkvm_vcpuvcpugpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestkvmgpa",
      "signature": "read_guestkvmgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_async_page_ready",
      "signature": "kvm_arch_async_page_ready",
      "file": "virt/kvm/async_pf.c",
      "category": "memory_read"
    },
    {
      "function": "__kvm_gmem_get_pfnstructfilefilestructkvm_memory_slotslotpgoff_tindexkvm_pfn_tpfnboolis_preparedintmax_orderstructfilegmem_fileREAD_ONCEslotgmem",
      "signature": "__kvm_gmem_get_pfnstructfilefilestructkvm_memory_slotslotpgoff_tindexkvm_pfn_tpfnboolis_preparedintmax_orderstructfilegmem_fileREAD_ONCEslotgmem",
      "file": "virt/kvm/guest_memfd.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_has_readonly_memstructkvmkvmreturnIS_ENABLEDCONFIG_HAVE_KVM_READONLY_MEM",
      "signature": "kvm_arch_has_readonly_memstructkvmkvmreturnIS_ENABLEDCONFIG_HAVE_KVM_READONLY_MEM",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "mmu_invalidate_retry_gfn_unsafestructkvmkvmunsignedlongmmu_seqgfn_tgfnUseREAD_ONCEtoensuretheinprogressflagandsequencecounterarealwaysreadfrommem",
      "signature": "mmu_invalidate_retry_gfn_unsafestructkvmkvmunsignedlongmmu_seqgfn_tgfnUseREAD_ONCEtoensuretheinprogressflagandsequencecounterarealwaysreadfrommem",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_get_memory_attributesstructkvmkvmgfn_tgfnreturnxa_to_valuexa_loadkvmmem",
      "signature": "kvm_get_memory_attributesstructkvmkvmgfn_tgfnreturnxa_to_valuexa_loadkvmmem",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_page",
      "signature": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset, int len); int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len); int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len); int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_offset_cached",
      "signature": "int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_io_bus_read",
      "signature": "int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, void *val); int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr, int len, struct kvm_io_device *dev); int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx, struct kvm_io_device *dev); struct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_has_readonly_mem",
      "signature": "bool kvm_arch_has_readonly_mem(struct kvm *kvm)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_lock",
      "signature": "void kvm_vcpu_srcu_read_lock(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_unlock",
      "signature": "void kvm_vcpu_srcu_read_unlock(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_map_readonly",
      "signature": "int kvm_vcpu_map_readonly(struct kvm_vcpu *vcpu, gpa_t gpa, struct kvm_host_map *map)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data, int offset, int len); int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_atomic",
      "signature": "int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "KVM_GENERIC_DIRTYLOG_READ_PROTECT",
      "signature": "KVM_GENERIC_DIRTYLOG_READ_PROTECT",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_memory_slotatomic_long_read",
      "signature": "kvm_memory_slotatomic_long_read",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_stats_read",
      "signature": "ssize_t kvm_stats_read(char *id, const struct kvm_stats_header *header, const struct _kvm_stats_desc *desc, void *stats, size_t size_stats, char __user *user_buffer, size_t size, loff_t *offset); /** * kvm_stats_linear_hist_update() - Update bucket value for linear histogram * statistics data. * * @data: start address of the stats data * @size: the number of bucket of the stats data * @value: the new value used to update the linear histogram's bucket * @bucket_size: the size (width) of a bucket */ static inline void kvm_stats_linear_hist_update(u64 *data, size_t size, u64 value, size_t bucket_size)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "read_gueststructkvmkvmgpa_tgpa",
      "signature": "read_gueststructkvmkvmgpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicstructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_guest_atomicstructkvm_vcpuvcpugpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "read_gueststructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_gueststructkvm_vcpuvcpugpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "KVM_MEM_READONLY",
      "signature": "define KVM_MEM_READONLY (1UL << 1) #define KVM_MEM_GUEST_MEMFD (1UL << 2)",
      "file": "include/uapi/linux/kvm.h",
      "category": "memory_read"
    },
    {
      "function": "KVM_CAP_READONLY_MEM",
      "signature": "KVM_CAP_READONLY_MEM",
      "file": "include/uapi/linux/kvm.h",
      "category": "memory_read"
    }
  ],
  "memory_write": [
    {
      "function": "guest_cpuid_hasstructkvm_vcpuvcpuunsignedintx86_featureconststructcpuid_regcpuidx86_feature_cpuidx86_featurestructkvm_cpuid_entry2entryu32regXSAVESisaspecialsnowflakeDuetolackofadedicatedinterceptonSVMKVMmustassumethatXSAVESandthusXRSTORSisusablebytheguestifthehostsupportsXSAVESandXSAVEisexposedtotheguestBecausetheguestcanexecuteXSAVESandXRSTORSiecanindirectlyconsumeXSSKVMmustensureXSSiszeroedwhenrunningtheguestiemustsetXSAVESinvCPUcapabilitiesButtorejectdirectXSSreadsandwritestominimizethevirt",
      "signature": "guest_cpuid_hasstructkvm_vcpuvcpuunsignedintx86_featureconststructcpuid_regcpuidx86_feature_cpuidx86_featurestructkvm_cpuid_entry2entryu32regXSAVESisaspecialsnowflakeDuetolackofadedicatedinterceptonSVMKVMmustassumethatXSAVESandthusXRSTORSisusablebytheguestifthehostsupportsXSAVESandXSAVEisexposedtotheguestBecausetheguestcanexecuteXSAVESandXRSTORSiecanindirectlyconsumeXSSKVMmustensureXSSiszeroedwhenrunningtheguestiemustsetXSAVESinvCPUcapabilitiesButtorejectdirectXSSreadsandwritestominimizethevirt",
      "file": "arch/x86/kvm/cpuid.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write_nodecode",
      "signature": "void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset); void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector); int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr); void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu); void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu); int kvm_x2apic_icr_write_fast(struct kvm_lapic *apic, u64 data); int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_icr_write_fast",
      "signature": "int kvm_x2apic_icr_write_fast(struct kvm_lapic *apic, u64 data); int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_msr_write",
      "signature": "int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_hv_vapic_msr_write",
      "signature": "int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "int kvm_xen_write_hypercall_page(struct kvm_vcpu *vcpu, u64 data); int kvm_xen_hvm_config(struct kvm *kvm, struct kvm_xen_hvm_config *xhc); void kvm_xen_init_vm(struct kvm *kvm); void kvm_xen_destroy_vm(struct kvm *kvm); void kvm_xen_init_vcpu(struct kvm_vcpu *vcpu); void kvm_xen_destroy_vcpu(struct kvm_vcpu *vcpu); int kvm_xen_set_evtchn_fast(struct kvm_xen_evtchn *xe, struct kvm *kvm); int kvm_xen_setup_evtchn(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e, const struct kvm_irq_routing_entry *ue); static inline void kvm_xen_sw_enable_lapic(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/xen.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_system",
      "signature": "int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception); int handle_ud(struct kvm_vcpu *vcpu); void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu, struct kvm_queued_exception *ex); int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata); void kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code); int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type, void *insn, int insn_len); int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, int emulation_type, void *insn, int insn_len); fastpath_t handle_fastpath_wrmsr(struct kvm_vcpu *vcpu); fastpath_t handle_fastpath_wrmsr_imm(struct kvm_vcpu *vcpu, u32 msr, int reg); fastpath_t handle_fastpath_hlt(struct kvm_vcpu *vcpu); fastpath_t handle_fastpath_invd(struct kvm_vcpu *vcpu); extern struct kvm_caps kvm_caps; extern struct kvm_host_values kvm_host; extern bool enable_pmu; /* * Get a filtered version of KVM's supported XCR0 that strips out dynamic * features for which the current process doesn't (yet)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "void kvm_register_write(struct kvm_vcpu *vcpu, int reg, unsigned long val)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write_raw",
      "signature": "return kvm_register_write_raw(vcpu, reg, val); } static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size, unsigned int port, void *data, unsigned int count, int in); static inline bool user_exit_on_hypercall(struct kvm *kvm, unsigned long hc_nr)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt",
      "signature": "write_guest_virt",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_tsc_offset",
      "signature": "kvm_write_tsc_offset",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write",
      "signature": "kvm_apic_write",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write",
      "signature": "kvm_msr_write",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write_ex",
      "signature": "kvm_msr_write_ex",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_cr_write",
      "signature": "kvm_cr_write",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val, sizeof(val)); } static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_lapic_msr_write",
      "signature": "int kvm_lapic_msr_write(struct kvm_lapic *apic, u32 reg, u64 data); static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_lapic_reg_write",
      "signature": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write",
      "signature": "kvm_apic_write",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_icr_write",
      "signature": "int kvm_x2apic_icr_write(struct kvm_lapic *apic, u64 data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_icr_write_fast",
      "signature": "int kvm_x2apic_icr_write_fast(struct kvm_lapic *apic, u64 data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write_nodecode",
      "signature": "void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_apic_write_nodecode",
      "signature": "KVM_INTERNALkvm_apic_write_nodecode",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_msr_write",
      "signature": "int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_hv_vapic_msr_write",
      "signature": "int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "em_cmpxchgstructx86_emulate_ctxtctxtSaverealsourcevaluethencompareEAXagainstdestinationctxtdstorig_valctxtdstvalctxtdstvalreg_readctxtVCPU_REGS_RAXctxtsrcorig_valctxtsrcvalctxtsrcvalctxtdstorig_valem_cmpctxtifctxteflagsX86_EFLAGS_ZFSuccesswritebacktomem",
      "signature": "em_cmpxchgstructx86_emulate_ctxtctxtSaverealsourcevaluethencompareEAXagainstdestinationctxtdstorig_valctxtdstvalctxtdstvalreg_readctxtVCPU_REGS_RAXctxtsrcorig_valctxtsrcvalctxtsrcvalctxtdstorig_valem_cmpctxtifctxteflagsX86_EFLAGS_ZFSuccesswritebacktomem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "em_xchgstructx86_emulate_ctxtctxtWritebacktheregistersourcectxtsrcvalctxtdstvalwrite_register_operandctxtsrcWritebackthemem",
      "signature": "em_xchgstructx86_emulate_ctxtctxtWritebacktheregistersourcectxtsrcvalctxtdstvalwrite_register_operandctxtsrcWritebackthemem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "em_fxsavestructx86_emulate_ctxtctxtstructfxregs_statefx_stateintrcrccheck_fxsrctxtifrcX86EMUL_CONTINUEreturnrckvm_fpu_getrcasm_safefxsavefxfxmfx_statekvm_fpu_putifrcX86EMUL_CONTINUEreturnrcreturnsegmented_write_stdctxtctxtmemopaddrmem",
      "signature": "em_fxsavestructx86_emulate_ctxtctxtstructfxregs_statefx_stateintrcrccheck_fxsrctxtifrcX86EMUL_CONTINUEreturnrckvm_fpu_getrcasm_safefxsavefxfxmfx_statekvm_fpu_putifrcX86EMUL_CONTINUEreturnrcreturnsegmented_write_stdctxtctxtmemopaddrmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_sse_reg",
      "signature": "kvm_write_sse_reg",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_mmx_reg",
      "signature": "kvm_write_mmx_reg",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_lname_write",
      "signature": "kvm_lname_write",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write_raw",
      "signature": "void kvm_register_write_raw(struct kvm_vcpu *vcpu, int reg, unsigned long val)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsp_write",
      "signature": "void kvm_rsp_write(struct kvm_vcpu *vcpu, unsigned long val)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_pdptr_write",
      "signature": "void kvm_pdptr_write(struct kvm_vcpu *vcpu, int index, u64 value)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALpmc_write_counter",
      "signature": "KVM_INTERNALpmc_write_counter",
      "file": "arch/x86/kvm/pmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_helpergva_taddrvoidvalunsignedintbytesstructkvm_vcpuvcpuu64accessstructx86_exceptionexceptionstructkvm_mmummuvcpuarchwalk_mmuvoiddatavalintrX86EMUL_CONTINUEwhilebytesgpa_tgpammugva_to_gpavcpummuaddraccessexceptionunsignedoffsetaddrPAGE_SIZE1unsignedtowriteminbytesunsignedPAGE_SIZEoffsetintretifgpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULTretkvm_vcpu_write_guestvcpugpa",
      "signature": "kvm_write_guest_virt_helpergva_taddrvoidvalunsignedintbytesstructkvm_vcpuvcpuu64accessstructx86_exceptionexceptionstructkvm_mmummuvcpuarchwalk_mmuvoiddatavalintrX86EMUL_CONTINUEwhilebytesgpa_tgpammugva_to_gpavcpummuaddraccessexceptionunsignedoffsetaddrPAGE_SIZE1unsignedtowriteminbytesunsignedPAGE_SIZEoffsetintretifgpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULTretkvm_vcpu_write_guestvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "emulator_write_stdstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionboolsystemstructkvm_vcpuvcpuemul_to_vcpuctxtu64accessPFERR_WRITE_MASKifsystemaccessPFERR_IMPLICIT_ACCESSelseifkvm_x86_callget_cplvcpu3accessPFERR_USER_MASKreturnkvm_write_guest_virt",
      "signature": "emulator_write_stdstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionboolsystemstructkvm_vcpuvcpuemul_to_vcpuctxtu64accessPFERR_WRITE_MASKifsystemaccessPFERR_IMPLICIT_ACCESSelseifkvm_x86_callget_cplvcpu3accessPFERR_USER_MASKreturnkvm_write_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_systemstructkvm_vcpuvcpugva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionkvm_write_guest_virt_systemcanpullintonsofpagesvcpuarchl1tf_flush_l1dtruereturnkvm_write_guest_virt",
      "signature": "kvm_write_guest_virt_systemstructkvm_vcpuvcpugva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionkvm_write_guest_virt_systemcanpullintonsofpagesvcpuarchl1tf_flush_l1dtruereturnkvm_write_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "emulator_write_physstructkvm_vcpuvcpugpa_tgpaconstvoidvalintbytesintretretkvm_vcpu_write_guestvcpugpavalbytesifret0return0kvm_page_track_writevcpugpa",
      "signature": "emulator_write_physstructkvm_vcpuvcpugpa_tgpaconstvoidvalintbytesintretretkvm_vcpu_write_guestvcpugpavalbytesifret0return0kvm_page_track_writevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_emulatestructkvm_vcpuvcpugpa_tgpavoidvalintbytesreturnemulator_write_physvcpugpa",
      "signature": "write_emulatestructkvm_vcpuvcpugpa_tgpavoidvalintbytesreturnemulator_write_physvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_mmiostructkvm_vcpuvcpugpa_tgpaintbytesvoidvaltrace_kvm_mmioKVM_TRACE_MMIO_WRITEbytesgpavalreturnvcpu_mmio_writevcpugpa",
      "signature": "write_mmiostructkvm_vcpuvcpugpa_tgpaintbytesvoidvaltrace_kvm_mmioKVM_TRACE_MMIO_WRITEbytesgpavalreturnvcpu_mmio_writevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_writestructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledwrite_emultorread_write_mmiovcpugpa",
      "signature": "kvm_sev_es_mmio_writestructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledwrite_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_readstructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledread_emultorread_write_mmiovcpugpa",
      "signature": "kvm_sev_es_mmio_readstructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledread_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_wall_clock",
      "signature": "void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock, int sec_hi_ofs)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "kvm_write_guest",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_system_time",
      "signature": "void kvm_write_system_time(struct kvm_vcpu *vcpu, gpa_t system_time, bool old_msr, bool host_initiated)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_tsc_offset",
      "signature": "kvm_write_tsc_offset",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_helper",
      "signature": "int kvm_write_guest_virt_helper(gva_t addr, void *val, unsigned int bytes, struct kvm_vcpu *vcpu, u64 access, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_system",
      "signature": "int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &reason, sizeof(reason)); } static inline int apf_put_user_ready(struct kvm_vcpu *vcpu, u32 token)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_offset_cached",
      "signature": "return kvm_write_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data, &token, offset, sizeof(token)); } static inline bool apf_pageready_slot_free(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdx_write",
      "signature": "kvm_rdx_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write",
      "signature": "int kvm_msr_write(struct kvm_vcpu *vcpu, u32 index, u64 data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_emulate_msr_write",
      "signature": "int kvm_emulate_msr_write(struct kvm_vcpu *vcpu, u32 index, u64 data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNAL__kvm_emulate_msr_write",
      "signature": "KVM_INTERNAL__kvm_emulate_msr_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_allowedvcpuindexKVM_MSR_FILTER_WRITE",
      "signature": "kvm_msr_allowedvcpuindexKVM_MSR_FILTER_WRITE",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_msr_write",
      "signature": "KVM_INTERNALkvm_emulate_msr_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "kvm_register_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write_ex",
      "signature": "kvm_msr_write_ex",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_icr_write_fast",
      "signature": "kvm_x2apic_icr_write_fast",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_tsc_multiplier",
      "signature": "void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier); static int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_tsc_offset",
      "signature": "void kvm_vcpu_write_tsc_offset(struct kvm_vcpu *vcpu, u64 l1_offset)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "return kvm_xen_write_hypercall_page(vcpu, data); switch (msr)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_msr_write",
      "signature": "return kvm_x2apic_msr_write(vcpu, msr, data); case MSR_IA32_TSC_DEADLINE: kvm_set_lapic_tscdeadline_msr(vcpu, data); break; case MSR_IA32_TSC_ADJUST: if (guest_cpu_cap_has(vcpu, X86_FEATURE_TSC_ADJUST))",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_iodevice_write",
      "signature": "kvm_iodevice_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "kvm_io_bus_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_mmu_gva_to_gpa_write",
      "signature": "KVM_INTERNALkvm_mmu_gva_to_gpa_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_virt_system",
      "signature": "KVM_INTERNALkvm_write_guest_virt_system",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "endif kvm_rip_write(vcpu, regs->rip); kvm_set_rflags(vcpu, regs->rflags | X86_EFLAGS_FIXED); vcpu->arch.exception.pending = false; vcpu->arch.exception_vmexit.pending = false; kvm_make_request(KVM_REQ_EVENT, vcpu); } int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "kvm_page_track_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "signature": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write_raw",
      "signature": "kvm_register_write_raw",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rbx_write",
      "signature": "kvm_rbx_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rcx_write",
      "signature": "kvm_rcx_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsi_write",
      "signature": "kvm_rsi_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdi_write",
      "signature": "kvm_rdi_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsp_write",
      "signature": "kvm_rsp_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rbp_write",
      "signature": "kvm_rbp_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r8_write",
      "signature": "CONFIG_X86_64 kvm_r8_write(vcpu, regs->r8); kvm_r9_write(vcpu, regs->r9); kvm_r10_write(vcpu, regs->r10); kvm_r11_write(vcpu, regs->r11); kvm_r12_write(vcpu, regs->r12); kvm_r13_write(vcpu, regs->r13); kvm_r14_write(vcpu, regs->r14); kvm_r15_write(vcpu, regs->r15); #endif kvm_rip_write(vcpu, regs->rip); kvm_set_rflags(vcpu, regs->rflags | X86_EFLAGS_FIXED); vcpu->arch.exception.pending = false; vcpu->arch.exception_vmexit.pending = false; kvm_make_request(KVM_REQ_EVENT, vcpu); } int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r9_write",
      "signature": "kvm_r9_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r10_write",
      "signature": "kvm_r10_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r11_write",
      "signature": "kvm_r11_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r12_write",
      "signature": "kvm_r12_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r13_write",
      "signature": "kvm_r13_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r14_write",
      "signature": "kvm_r14_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r15_write",
      "signature": "kvm_r15_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_pdptr_write",
      "signature": "kvm_pdptr_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_remove_write_access",
      "signature": "kvm_mmu_slot_remove_write_access",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes, void *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_sev_es_mmio_write",
      "signature": "KVM_INTERNALkvm_sev_es_mmio_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_wall_clockstructkvmkvmgpa",
      "signature": "write_wall_clockstructkvmkvmgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_system_timestructkvm_vcpuvcpugpa",
      "signature": "write_system_timestructkvm_vcpuvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt_helpergva",
      "signature": "write_guest_virt_helpergva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_guestvcpugpa",
      "signature": "write_guestvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_stdstructx86_emulate_ctxtctxtgva",
      "signature": "write_stdstructx86_emulate_ctxtctxtgva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt",
      "signature": "write_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt_systemstructkvm_vcpuvcpugva",
      "signature": "write_guest_virt_systemstructkvm_vcpuvcpugva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_physstructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_physstructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_emulatestructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_emulatestructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_physvcpugpa",
      "signature": "write_physvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_emulatevcpugpa",
      "signature": "write_emulatevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_mmiovcpugpa",
      "signature": "write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_exit_mmiovcpugpa",
      "signature": "write_exit_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_emultorread_write_mmiovcpugpa",
      "signature": "write_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_sse_reg",
      "signature": "void kvm_write_sse_reg(int reg, const sse128_t *data)",
      "file": "arch/x86/kvm/fpu.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_mmx_reg",
      "signature": "void kvm_write_mmx_reg(int reg, const u64 *data)",
      "file": "arch/x86/kvm/fpu.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "kvm_rip_write",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_emulate_msr_write",
      "signature": "kvm_emulate_msr_write",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write",
      "signature": "kvm_msr_write",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "kvm_write_guest",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "kvm_vcpu_write_guest_page",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_hv_vapic_msr_write",
      "signature": "return kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data); case HV_X64_MSR_ICR: return kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data); case HV_X64_MSR_TPR: return kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data); case HV_X64_MSR_VP_RUNTIME: if (!host) return 1; hv_vcpu->runtime_offset = data - current_task_runtime_100ns(); break; case HV_X64_MSR_SCONTROL: case HV_X64_MSR_SVERSION: case HV_X64_MSR_SIEFP: case HV_X64_MSR_SIMP: case HV_X64_MSR_EOM: case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: return synic_set_msr(to_hv_synic(vcpu), msr, data, host)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdx_write",
      "signature": "kvm_rdx_write",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "write_guestkvmgfn_to_gpa",
      "signature": "write_guestkvmgfn_to_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rbx_write",
      "signature": "kvm_rbx_write",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rcx_write",
      "signature": "kvm_rcx_write",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdx_write",
      "signature": "kvm_rdx_write",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_wall_clock",
      "signature": "mirrors kvm_write_wall_clock() except that it writes * directly through the pfn cache and doesn't mark the page dirty. */ wall_nsec = kvm_get_wall_clock_epoch(kvm); /* Paranoia checks on the 32-bit struct layout */ BUILD_BUG_ON(offsetof(struct compat_shared_info, wc) != 0x900); BUILD_BUG_ON(offsetof(struct compat_shared_info, arch.wc_sec_hi) != 0x924); BUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0); #ifdef CONFIG_X86_64 /* Paranoia checks on the 64-bit struct layout */ BUILD_BUG_ON(offsetof(struct shared_info, wc) != 0xc00); BUILD_BUG_ON(offsetof(struct shared_info, wc_sec_hi) != 0xc0c); if (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode)",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "int kvm_xen_write_hypercall_page(struct kvm_vcpu *vcpu, u64 data)",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_write"
    },
    {
      "function": "__avic_vcpu_loadstructkvm_vcpuvcpuintcpuenumavic_vcpu_actionactionstructkvm_svmkvm_svmto_kvm_svmvcpukvminth_physical_idkvm_cpu_get_apicidcpustructvcpu_svmsvmto_svmvcpuunsignedlongflagsu64entrylockdep_assert_preemption_disabledifWARN_ONh_physical_idAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKreturnifWARN_ON_ONCEvcpuvcpu_idsizeofentryPAGE_SIZEreturnGrabthepervCPUinterruptremappinglockeveniftheVMdoesnt_currently_haveassigneddevicesasthatcanchangeHoldingir_list_lockensuresthateithersvm_ir_list_addwillconsumeuptodateentryinformationorthatthistaskwillwaituntilsvm_ir_list_addcompletestosetthenewtargetpCPUraw_spin_lock_irqsavesvmir_list_lockflagsentrysvmavic_physical_id_entryWARN_ON_ONCEentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKentryAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKAVIC_PHYSICAL_ID_ENTRY_GA_LOG_INTRentryh_physical_idAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKsvmavic_physical_id_entryentryIfIPIvirtualizationisdisabledclearIsRunningwhenupdatingtheactualPhysicalIDtablesothattheCPUneverseesIsRunning1KeeptheAPICIDuptodateintheentrytominimizethechancesofthingsgoingsidewaysifhardwarepeeksattheIDifenable_ipiventryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKWRITE_ONCEkvm_svmavic_phys",
      "signature": "__avic_vcpu_loadstructkvm_vcpuvcpuintcpuenumavic_vcpu_actionactionstructkvm_svmkvm_svmto_kvm_svmvcpukvminth_physical_idkvm_cpu_get_apicidcpustructvcpu_svmsvmto_svmvcpuunsignedlongflagsu64entrylockdep_assert_preemption_disabledifWARN_ONh_physical_idAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKreturnifWARN_ON_ONCEvcpuvcpu_idsizeofentryPAGE_SIZEreturnGrabthepervCPUinterruptremappinglockeveniftheVMdoesnt_currently_haveassigneddevicesasthatcanchangeHoldingir_list_lockensuresthateithersvm_ir_list_addwillconsumeuptodateentryinformationorthatthistaskwillwaituntilsvm_ir_list_addcompletestosetthenewtargetpCPUraw_spin_lock_irqsavesvmir_list_lockflagsentrysvmavic_physical_id_entryWARN_ON_ONCEentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKentryAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKAVIC_PHYSICAL_ID_ENTRY_GA_LOG_INTRentryh_physical_idAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKsvmavic_physical_id_entryentryIfIPIvirtualizationisdisabledclearIsRunningwhenupdatingtheactualPhysicalIDtablesothattheCPUneverseesIsRunning1KeeptheAPICIDuptodateintheentrytominimizethechancesofthingsgoingsidewaysifhardwarepeeksattheIDifenable_ipiventryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKWRITE_ONCEkvm_svmavic_phys",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_write"
    },
    {
      "function": "__avic_vcpu_putstructkvm_vcpuvcpuenumavic_vcpu_actionactionstructkvm_svmkvm_svmto_kvm_svmvcpukvmstructvcpu_svmsvmto_svmvcpuunsignedlongflagsu64entrysvmavic_physical_id_entrylockdep_assert_preemption_disabledifWARN_ON_ONCEvcpuvcpu_idsizeofentryPAGE_SIZEreturnTakeandholdthepervCPUinterruptremappinglockwhileupdatingthePhysicalIDentryeventhoughthelockdoesntprotectagainstmultiplewritersseeaboveHoldingir_list_lockensuresthateithersvm_ir_list_addwillconsumeuptodateentryinformationorthatthistaskwillwaituntilsvm_ir_list_addcompletestomarkthevCPUasnotrunningraw_spin_lock_irqsavesvmir_list_lockflagsavic_update_iommu_vcpu_affinityvcpu1actionWARN_ON_ONCEentryAVIC_PHYSICAL_ID_ENTRY_GA_LOG_INTRKeepthepreviousAPICIDintheentrysothataroguedoorbellfromhardwareisatleastrestrictedtoaCPUassociatedwiththevCPUentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKifenable_ipivWRITE_ONCEkvm_svmavic_phys",
      "signature": "__avic_vcpu_putstructkvm_vcpuvcpuenumavic_vcpu_actionactionstructkvm_svmkvm_svmto_kvm_svmvcpukvmstructvcpu_svmsvmto_svmvcpuunsignedlongflagsu64entrysvmavic_physical_id_entrylockdep_assert_preemption_disabledifWARN_ON_ONCEvcpuvcpu_idsizeofentryPAGE_SIZEreturnTakeandholdthepervCPUinterruptremappinglockwhileupdatingthePhysicalIDentryeventhoughthelockdoesntprotectagainstmultiplewritersseeaboveHoldingir_list_lockensuresthateithersvm_ir_list_addwillconsumeuptodateentryinformationorthatthistaskwillwaituntilsvm_ir_list_addcompletestomarkthevCPUasnotrunningraw_spin_lock_irqsavesvmir_list_lockflagsavic_update_iommu_vcpu_affinityvcpu1actionWARN_ON_ONCEentryAVIC_PHYSICAL_ID_ENTRY_GA_LOG_INTRKeepthepreviousAPICIDintheentrysothataroguedoorbellfromhardwareisatleastrestrictedtoaCPUassociatedwiththevCPUentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKifenable_ipivWRITE_ONCEkvm_svmavic_phys",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write_nodecode",
      "signature": "kvm_apic_write_nodecode",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_write"
    },
    {
      "function": "WRITE_ONCEkvm_svmavic_phys",
      "signature": "WRITE_ONCEkvm_svmavic_phys",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "kvm_write_guest",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_emulate_msr_write",
      "signature": "kvm_emulate_msr_write",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "kvm_sev_es_mmio_write",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_write"
    },
    {
      "function": "write_guestkvmresp_gpa",
      "signature": "write_guestkvmresp_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "kvm_rip_write",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_WRITE",
      "signature": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_WRITE",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_cr_write",
      "signature": "kvm_cr_write",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "kvm_register_write",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsp_write",
      "signature": "kvm_rsp_write",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "kvm_rip_write",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_write"
    },
    {
      "function": "__kvm_page_track_write_tracking_allocstructkvm_memory_slotslotunsignedlongnpagesconstsize_tsizesizeofslotarchgfn_write_trackifslotarchgfn_write_trackslotarchgfn_write_track__vcallocnpagessizeGFP_KERNEL_ACCOUNTreturnslotarchgfn_write_track0ENOMEM",
      "signature": "__kvm_page_track_write_tracking_allocstructkvm_memory_slotslotunsignedlongnpagesconstsize_tsizesizeofslotarchgfn_write_trackifslotarchgfn_write_trackslotarchgfn_write_track__vcallocnpagessizeGFP_KERNEL_ACCOUNTreturnslotarchgfn_write_track0ENOMEM",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "__kvm_page_track_writestructkvmkvmgpa_tgpaconstu8newintbytesstructkvm_page_track_notifier_headheadstructkvm_page_track_notifier_nodenintidxheadkvmarchtrack_notifier_headifhlist_emptyheadtrack_notifier_listreturnidxsrcu_read_lockheadtrack_srcuhlist_for_each_entry_srcunheadtrack_notifier_listnodesrcu_read_lock_heldheadtrack_srcuifntrack_writentrack_writegpa",
      "signature": "__kvm_page_track_writestructkvmkvmgpa_tgpaconstu8newintbytesstructkvm_page_track_notifier_headheadstructkvm_page_track_notifier_nodenintidxheadkvmarchtrack_notifier_headifhlist_emptyheadtrack_notifier_listreturnidxsrcu_read_lockheadtrack_srcuhlist_for_each_entry_srcunheadtrack_notifier_listnodesrcu_read_lock_heldheadtrack_srcuifntrack_writentrack_writegpa",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_add_gfn",
      "signature": "int kvm_write_track_add_gfn(struct kvm *kvm, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_remove_gfn",
      "signature": "int kvm_write_track_remove_gfn(struct kvm *kvm, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_external_write_tracking_enabled",
      "signature": "bool kvm_external_write_tracking_enabled(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_EXTERNAL_WRITE_TRACKING",
      "signature": "KVM_EXTERNAL_WRITE_TRACKING",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_enable",
      "signature": "in kvm_page_track_write_tracking_enable(). */ return smp_load_acquire(&kvm->arch.external_write_tracking_enabled); #else return false; #endif } bool kvm_page_track_write_tracking_enabled(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "bool kvm_page_track_write_tracking_enabled(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_BUG_ONkvm_page_track_write_tracking_enabled",
      "signature": "KVM_BUG_ONkvm_page_track_write_tracking_enabled",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "kvm_mmu_slot_gfn_write_protect",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_gfn_is_write_tracked",
      "signature": "bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_enable_external_write_tracking",
      "signature": "int kvm_enable_external_write_tracking(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "kvm_page_track_write",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_spte_atomic",
      "signature": "u64 kvm_tdp_mmu_write_spte_atomic(tdp_ptep_t sptep, u64 new_spte)",
      "file": "arch/x86/kvm/mmu/tdp_iter.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_spte",
      "signature": "u64 kvm_tdp_mmu_write_spte(tdp_ptep_t sptep, u64 old_spte, u64 new_spte, int level)",
      "file": "arch/x86/kvm/mmu/tdp_iter.h",
      "category": "memory_write"
    },
    {
      "function": "__kvm_mmu_unprotect_gfn_and_retrystructkvm_vcpuvcpugpa_tcr2_or_gpaboolalways_retrystructkvmkvmvcpukvmLIST_HEADinvalid_liststructkvm_mmu_pagespgpa_tgpacr2_or_gpaboolrfalseBailearlyiftherearentanywriteprotectedshadowpagestoavoidunnecessarilytakingmmu_locklockegifthegfniswritetrackedbyathirdpartyReadingindirect_shadow_pageswithoutholdingmmu_lockissafeasthisispurelyanoptimizationieafalsepositiveisbenignandafalsenegativewillsimplyresultinKVMskippingtheunprotectretrypathwhichisalsoanoptimizationifREAD_ONCEkvmarchindirect_shadow_pagesgotooutifvcpuarchmmuroot_roledirectgpakvm_mmu_gva_to_gpa_writevcpucr2_or_gpa",
      "signature": "__kvm_mmu_unprotect_gfn_and_retrystructkvm_vcpuvcpugpa_tcr2_or_gpaboolalways_retrystructkvmkvmvcpukvmLIST_HEADinvalid_liststructkvm_mmu_pagespgpa_tgpacr2_or_gpaboolrfalseBailearlyiftherearentanywriteprotectedshadowpagestoavoidunnecessarilytakingmmu_locklockegifthegfniswritetrackedbyathirdpartyReadingindirect_shadow_pageswithoutholdingmmu_lockissafeasthisispurelyanoptimizationieafalsepositiveisbenignandafalsenegativewillsimplyresultinKVMskippingtheunprotectretrypathwhichisalsoanoptimizationifREAD_ONCEkvmarchindirect_shadow_pagesgotooutifvcpuarchmmuroot_roledirectgpakvm_mmu_gva_to_gpa_writevcpucr2_or_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "mmio_info_in_cachestructkvm_vcpuvcpuu64addrbooldirectAnestedguestcannotusetheMMIOcacheifitisusingnestedpagetablesbecausecr2isanGPAwhilethecachestoresGPA",
      "signature": "mmio_info_in_cachestructkvm_vcpuvcpuu64addrbooldirectAnestedguestcannotusetheMMIOcacheifitisusingnestedpagetablesbecausecr2isanGPAwhilethecachestoresGPA",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytesgfn_tgfngpaPAGE_SHIFTstructkvm_mmu_pagespLIST_HEADinvalid_listu64entrygentryspteintnpteboolflushfalseWhenemulatingguestwritesensurethewrittenvalueisvisibletoanytaskthatishandlingpagefaultsbeforecheckingwhetherornotKVMisshadowingaguestPTEThisensureseitherKVMwillcreatethecorrectSPTEinthepagefaulthandlerorthistaskwillseeanonzeroindirect_shadow_pagesPairswiththesmp_mbinaccount_shadowedsmp_mbifvcpukvmarchindirect_shadow_pagesreturnwrite_lockvcpukvmmmu_lockgentrymmu_pte_write_fetch_gptevcpugpabytesvcpukvmstatmmu_pte_writefor_each_gfn_valid_sp_with_gptesvcpukvmspgfnifdetect_write_misalignedspgpa",
      "signature": "kvm_mmu_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytesgfn_tgfngpaPAGE_SHIFTstructkvm_mmu_pagespLIST_HEADinvalid_listu64entrygentryspteintnpteboolflushfalseWhenemulatingguestwritesensurethewrittenvalueisvisibletoanytaskthatishandlingpagefaultsbeforecheckingwhetherornotKVMisshadowingaguestPTEThisensureseitherKVMwillcreatethecorrectSPTEinthepagefaulthandlerorthistaskwillseeanonzeroindirect_shadow_pagesPairswiththesmp_mbinaccount_shadowedsmp_mbifvcpukvmarchindirect_shadow_pagesreturnwrite_lockvcpukvmmmu_lockgentrymmu_pte_write_fetch_gptevcpugpabytesvcpukvmstatmmu_pte_writefor_each_gfn_valid_sp_with_gptesvcpukvmspgfnifdetect_write_misalignedspgpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_zap_memslot_pages_and_flushstructkvmkvmstructkvm_memory_slotslotboolflushLIST_HEADinvalid_listunsignedlongiiflist_emptykvmarchactive_mmu_pagesgotoout_flushSinceaccountinginformationisstoredinstructkvm_arch_mem",
      "signature": "kvm_mmu_zap_memslot_pages_and_flushstructkvmkvmstructkvm_memory_slotslotboolflushLIST_HEADinvalid_listunsignedlongiiflist_emptykvmarchactive_mmu_pagesgotoout_flushSinceaccountinginformationisstoredinstructkvm_arch_mem",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_add_gfn",
      "signature": "kvm_write_track_add_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_remove_gfn",
      "signature": "kvm_write_track_remove_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "in kvm_mmu_track_write(). */ smp_mb(); gfn = sp->gfn; slots = kvm_memslots_for_spte_role(kvm, sp->role); slot = __gfn_to_memslot(slots, gfn); /* the non-leaf shadow pages are keeping readonly. */ if (sp->role.level > PG_LEVEL_4K) return __kvm_write_track_add_gfn(kvm, slot, gfn); kvm_mmu_gfn_disallow_lpage(slot, gfn); if (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn, PG_LEVEL_4K)) kvm_flush_remote_tlbs_gfn(kvm, gfn, PG_LEVEL_4K); } void track_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp, enum kvm_mmu_type mmu_type)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm, struct kvm_memory_slot *slot, u64 gfn, int min_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_write_protect_pt_masked",
      "signature": "void kvm_mmu_write_protect_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_protect_gfn",
      "signature": "kvm_tdp_mmu_write_protect_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_protect_gfn",
      "signature": "bool kvm_vcpu_write_protect_gfn(struct kvm_vcpu *vcpu, u64 gfn)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "kvm_mmu_gva_to_gpa_write",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_gfn_is_write_tracked",
      "signature": "kvm_gfn_is_write_tracked",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "kvm_page_track_write_tracking_enabled",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "kvm_page_track_write_tracking_alloc",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_write_protect_fault",
      "signature": "int kvm_mmu_write_protect_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code, int *emulation_type)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_remove_write_access",
      "signature": "void kvm_mmu_slot_remove_write_access(struct kvm *kvm, const struct kvm_memory_slot *memslot, int start_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_fetch_gptestructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_fetch_gptestructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_misalignedstructkvm_mmu_pagespgpa_tgpa",
      "signature": "write_misalignedstructkvm_mmu_pagespgpa_tgpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_fetch_gptevcpugpa",
      "signature": "write_fetch_gptevcpugpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_misalignedspgpa",
      "signature": "write_misalignedspgpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_protect_faultstructkvm_vcpuvcpugpa_tcr2_or_gpa",
      "signature": "write_protect_faultstructkvm_vcpuvcpugpa_tcr2_or_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_protect_faultvcpucr2_or_gpa",
      "signature": "write_protect_faultvcpucr2_or_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "bool kvm_mmu_page_ad_need_write_protect(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm, struct kvm_memory_slot *slot, u64 gfn, int min_level); /* Flush the given page (huge or not) of guest memory. */ static inline void kvm_flush_remote_tlbs_gfn(struct kvm *kvm, gfn_t gfn, int level)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "kvm_mmu_page_ad_need_write_protect",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_maskmaskmaskACC_WRITE_MASK",
      "signature": "kvm_mmu_set_mmio_spte_maskmaskmaskACC_WRITE_MASK",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_protect_gfn",
      "signature": "bool kvm_tdp_mmu_write_protect_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, int min_level); void kvm_tdp_mmu_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t start, gfn_t end, int target_level, bool shared); static inline void kvm_tdp_mmu_walk_lockless_begin(void)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytes__kvm_page_track_writevcpukvmgpanewbyteskvm_mmu_track_writevcpugpa",
      "signature": "kvm_page_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytes__kvm_page_track_writevcpukvmgpanewbyteskvm_mmu_track_writevcpugpa",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_add_gfn",
      "signature": "kvm_write_track_add_gfn",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_remove_gfn",
      "signature": "kvm_write_track_remove_gfn",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "bool kvm_page_track_write_tracking_enabled(struct kvm *kvm); int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot); void kvm_page_track_free_memslot(struct kvm_memory_slot *slot); int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages); void __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); void __kvm_write_track_remove_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot); void kvm_page_track_free_memslot(struct kvm_memory_slot *slot); int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages); void __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); void __kvm_write_track_remove_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_gfn_is_write_tracked",
      "signature": "bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "KVM_EXTERNAL_WRITE_TRACKING",
      "signature": "KVM_EXTERNAL_WRITE_TRACKING",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "void kvm_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "kvm_mmu_track_write",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_spte_need_atomic_write",
      "signature": "in kvm_tdp_mmu_spte_need_atomic_write(). */ #define for_each_tdp_mmu_root_rcu(_kvm, _root, _as_id, _types) \\ list_for_each_entry_rcu(_root, &_kvm->arch.tdp_mmu_roots, link) \\ if ((_as_id >= 0 && kvm_mmu_page_as_id(_root) != _as_id) || \\ !tdp_mmu_root_match((_root), (_types)))",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_spte_atomic",
      "signature": "kvm_tdp_mmu_write_spte_atomic",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_spte",
      "signature": "kvm_tdp_mmu_write_spte",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "return kvm_mmu_page_ad_need_write_protect(kvm, sp) || !kvm_ad_enabled; } static void clear_dirty_gfn_range(struct kvm *kvm, struct kvm_mmu_page *root, gfn_t start, gfn_t end)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_protect_gfn",
      "signature": "bool kvm_tdp_mmu_write_protect_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, int min_level)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "sgx_gva_to_gpastructkvm_vcpuvcpugva_tgvaboolwritegpa_tgpastructx86_exceptionexifwritegpakvm_mmu_gva_to_gpa_writevcpugva",
      "signature": "sgx_gva_to_gpastructkvm_vcpuvcpugva_tgvaboolwritegpa_tgpastructx86_exceptionexifwritegpakvm_mmu_gva_to_gpa_writevcpugva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "kvm_mmu_gva_to_gpa_write",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_write"
    },
    {
      "function": "tdx_mmio_writestructkvm_vcpuvcpugpa_tgpaintsizeunsignedlongvalifkvm_io_bus_writevcpuKVM_FAST_MMIO_BUSgpa",
      "signature": "tdx_mmio_writestructkvm_vcpuvcpugpa_tgpaintsizeunsignedlongvalifkvm_io_bus_writevcpuKVM_FAST_MMIO_BUSgpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "tdx_emulate_mmiostructkvm_vcpuvcpustructvcpu_tdxtdxto_tdxvcpuintsizewriterunsignedlongvalgpa_tgpasizetdxvp_enter_argsr12writetdxvp_enter_argsr13gpatdxvp_enter_argsr14valwritetdxvp_enter_argsr150ifsize1size2size4size8gotoerrorifwrite0write1gotoerrorTDGVPVMCALLMMIOallowsonlysharedGPAitmakesnosensetodoMMIOemulationforprivateGPAifvt_is_tdx_private_gpavcpukvmgpavt_is_tdx_private_gpavcpukvmgpasize1gotoerrorgpagpagfn_to_gpakvm_gfn_direct_bitsvcpukvmifwritertdx_mmio_writevcpugpa",
      "signature": "tdx_emulate_mmiostructkvm_vcpuvcpustructvcpu_tdxtdxto_tdxvcpuintsizewriterunsignedlongvalgpa_tgpasizetdxvp_enter_argsr12writetdxvp_enter_argsr13gpatdxvp_enter_argsr14valwritetdxvp_enter_argsr150ifsize1size2size4size8gotoerrorifwrite0write1gotoerrorTDGVPVMCALLMMIOallowsonlysharedGPAitmakesnosensetodoMMIOemulationforprivateGPAifvt_is_tdx_private_gpavcpukvmgpavt_is_tdx_private_gpavcpukvmgpasize1gotoerrorgpagpagfn_to_gpakvm_gfn_direct_bitsvcpukvmifwritertdx_mmio_writevcpugpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rbx_write",
      "signature": "kvm_rbx_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rcx_write",
      "signature": "kvm_rcx_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdx_write",
      "signature": "kvm_rdx_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsi_write",
      "signature": "kvm_rsi_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "kvm_io_bus_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "signature": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "init_vmcsstructvcpu_vmxvmxstructkvmkvmvmxvcpukvmstructkvm_vmxkvm_vmxto_kvm_vmxkvmifnestednested_vmx_set_vmcs_shadowing_bitmapifcpu_has_vmx_msr_bitmapvmcs_write64MSR_BITMAP__pavmxvmcs01msr_bitmapvmcs_write64VMCS_LINK_POINTERINVALID_GPA",
      "signature": "init_vmcsstructvcpu_vmxvmxstructkvmkvmvmxvcpukvmstructkvm_vmxkvm_vmxto_kvm_vmxkvmifnestednested_vmx_set_vmcs_shadowing_bitmapifcpu_has_vmx_msr_bitmapvmcs_write64MSR_BITMAP__pavmxvmcs01msr_bitmapvmcs_write64VMCS_LINK_POINTERINVALID_GPA",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "ifenable_pmlvmcs_write64PML_ADDRESSpage_to_phys",
      "signature": "ifenable_pmlvmcs_write64PML_ADDRESSpage_to_phys",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "handle_ept_misconfigstructkvm_vcpuvcpugpa_tgpaifvmx_check_emulate_instructionvcpuEMULTYPE_PFNULL0return1AnestedguestcannotoptimizeMMIOvmexitsbecausewehaveannGPAhereinsteadoftherequiredGPAgpavmcs_read64GUEST_PHYSICAL_ADDRESSifis_guest_modevcpukvm_io_bus_writevcpuKVM_FAST_MMIO_BUSgpa",
      "signature": "handle_ept_misconfigstructkvm_vcpuvcpugpa_tgpaifvmx_check_emulate_instructionvcpuEMULTYPE_PFNULL0return1AnestedguestcannotoptimizeMMIOvmexitsbecausewehaveannGPAhereinsteadoftherequiredGPAgpavmcs_read64GUEST_PHYSICAL_ADDRESSifis_guest_modevcpukvm_io_bus_writevcpuKVM_FAST_MMIO_BUSgpa",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "endif kvm_rip_write(vcpu, rip)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_WRITE",
      "signature": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_WRITE",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_cr_write",
      "signature": "kvm_cr_write",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "kvm_register_write",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write_nodecode",
      "signature": "kvm_apic_write_nodecode",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "kvm_io_bus_write",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_faultin_pfnslotgfnFOLL_WRITE",
      "signature": "kvm_faultin_pfnslotgfnFOLL_WRITE",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "vmx_disable_shadow_vmcsstructvcpu_vmxvmxsecondary_exec_controls_clearbitvmxSECONDARY_EXEC_SHADOW_VMCSvmcs_write64VMCS_LINK_POINTERINVALID_GPA",
      "signature": "vmx_disable_shadow_vmcsstructvcpu_vmxvmxsecondary_exec_controls_clearbitvmxSECONDARY_EXEC_SHADOW_VMCSvmcs_write64VMCS_LINK_POINTERINVALID_GPA",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "prepare_vmcs02_early_rarestructvcpu_vmxvmxstructvmcs12vmcs12prepare_vmcs02_constant_statevmxvmcs_write64VMCS_LINK_POINTERINVALID_GPAIfVPIDisdisabledthenguestTLBaccessesuseVPID0iethesameVPIDasthehostEmulatethisbehaviorbyusingvpid01forL2ifVPIDisdisabledinvmcs12NoteifVPIDisdisabledVMEnterandVMExitarearchitecturallyrequiredtoflushVPID0butonlyVPID0Ieusingvpid02wouldbeoksolongasKVMemulatestherequiredflushesbutdoingsowouldcauseKVMtooverflushEgifL1runsL2XwithVPID121thenrunsL2YwithVPID12disabledandthenrunsL2XagainthenKVMcanandshouldretainTLBentriesforVPID121ifenable_vpidifnested_cpu_has_vpidvmcs12vmxnestedvpid02vmcs_write16VIRTUAL_PROCESSOR_IDvmxnestedvpid02elsevmcs_write16VIRT",
      "signature": "prepare_vmcs02_early_rarestructvcpu_vmxvmxstructvmcs12vmcs12prepare_vmcs02_constant_statevmxvmcs_write64VMCS_LINK_POINTERINVALID_GPAIfVPIDisdisabledthenguestTLBaccessesuseVPID0iethesameVPIDasthehostEmulatethisbehaviorbyusingvpid01forL2ifVPIDisdisabledinvmcs12NoteifVPIDisdisabledVMEnterandVMExitarearchitecturallyrequiredtoflushVPID0butonlyVPID0Ieusingvpid02wouldbeoksolongasKVMemulatestherequiredflushesbutdoingsowouldcauseKVMtooverflushEgifL1runsL2XwithVPID121thenrunsL2YwithVPID12disabledandthenrunsL2XagainthenKVMcanandshouldretainTLBentriesforVPID121ifenable_vpidifnested_cpu_has_vpidvmcs12vmxnestedvpid02vmcs_write16VIRTUAL_PROCESSOR_IDvmxnestedvpid02elsevmcs_write16VIRT",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "handle_vmptrststructkvm_vcpuvcpuunsignedlongexit_qualvmx_get_exit_qualvcpuu32instr_infovmcs_read32VMX_INSTRUCTION_INFOgpa_tcurrent_vmptrto_vmxvcpunestedcurrent_vmptrstructx86_exceptionegva_tgvaintrifnested_vmx_check_permissionvcpureturn1ifunlikelynested_vmx_is_evmptr12_validto_vmxvcpureturn1ifget_vmx_mem_addressvcpuexit_qualinstr_infotruesizeofgpa_tgvareturn1_systemoknested_vmx_check_permissionhasverifiedcpl0rkvm_write_guest_virt_systemvcpugva",
      "signature": "handle_vmptrststructkvm_vcpuvcpuunsignedlongexit_qualvmx_get_exit_qualvcpuu32instr_infovmcs_read32VMX_INSTRUCTION_INFOgpa_tcurrent_vmptrto_vmxvcpunestedcurrent_vmptrstructx86_exceptionegva_tgvaintrifnested_vmx_check_permissionvcpureturn1ifunlikelynested_vmx_is_evmptr12_validto_vmxvcpureturn1ifget_vmx_mem_addressvcpuexit_qualinstr_infotruesizeofgpa_tgvareturn1_systemoknested_vmx_check_permissionhasverifiedcpl0rkvm_write_guest_virt_systemvcpugva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "kvm_write_guest_cached",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "kvm_write_guest_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_system",
      "signature": "kvm_write_guest_virt_system",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_emulate_msr_write",
      "signature": "kvm_emulate_msr_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsp_write",
      "signature": "kvm_rsp_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "kvm_rip_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "kvm_vcpu_write_guest_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "kvm_register_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "write_pml_bufferstructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_pml_bufferstructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_pagevcpukvmgpa_to_gfndstgpa",
      "signature": "write_guest_pagevcpukvmgpa_to_gfndstgpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt_systemvcpugva",
      "signature": "write_guest_virt_systemvcpugva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_swap_active_memslotsstructkvmkvmintas_idstructkvm_memslotsslotskvm_get_inactive_memslotskvmas_idGrabthegenerationfromtheactivatememslotsu64gen__kvm_memslotskvmas_idgenerationWARN_ONgenKVM_MEMSLOT_GEN_UPDATE_IN_PROGRESSslotsgenerationgenKVM_MEMSLOT_GEN_UPDATE_IN_PROGRESSDonotstorethenewmem",
      "signature": "kvm_swap_active_memslotsstructkvmkvmintas_idstructkvm_memslotsslotskvm_get_inactive_memslotskvmas_idGrabthegenerationfromtheactivatememslotsu64gen__kvm_memslotskvmas_idgenerationWARN_ONgenKVM_MEMSLOT_GEN_UPDATE_IN_PROGRESSslotsgenerationgenKVM_MEMSLOT_GEN_UPDATE_IN_PROGRESSDonotstorethenewmem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_invalidate_memslotstructkvmkvmstructkvm_memory_slotoldstructkvm_memory_slotinvalid_slotMarkthecurrentslotINVALIDAswithallmemslotmodificationsthismustbedoneonanunreachableslottoavoidmodifyingthecurrentslotintheactivetreekvm_copy_memslotinvalid_slotoldinvalid_slotflagsKVM_MEMSLOT_INVALIDkvm_replace_memslotkvmoldinvalid_slotActivatetheslotthatisnowmarkedINVALIDbutdontpropagatetheslottothenowinactiveslotsTheslotiseithergoingtobedeletedorrecreatedasanewslotkvm_swap_active_memslotskvmoldas_idFromthispointnonewshadowpagespointingtoadeletedormovedmemslotwillbecreatedValidationofspgfnhappensingfn_to_hvakvm_read_guestgfn_to_pfnkvm_is_visible_gfnmmu_check_rootkvm_arch_flush_shadow_memslotkvmoldkvm_arch_guest_memory_reclaimedkvmWasreleasedbykvm_swap_active_memslotsreacquiremutex_lockkvmslots_arch_lockCopythearchspecificfieldofthenewlyinstalledslotbacktotheoldslotasthearchdatacouldhavechangedbetweenreleasingslots_arch_lockinkvm_swap_active_memslotsandreacquiringthelockaboveWritersarerequiredtoretrievemem",
      "signature": "kvm_invalidate_memslotstructkvmkvmstructkvm_memory_slotoldstructkvm_memory_slotinvalid_slotMarkthecurrentslotINVALIDAswithallmemslotmodificationsthismustbedoneonanunreachableslottoavoidmodifyingthecurrentslotintheactivetreekvm_copy_memslotinvalid_slotoldinvalid_slotflagsKVM_MEMSLOT_INVALIDkvm_replace_memslotkvmoldinvalid_slotActivatetheslotthatisnowmarkedINVALIDbutdontpropagatetheslottothenowinactiveslotsTheslotiseithergoingtobedeletedorrecreatedasanewslotkvm_swap_active_memslotskvmoldas_idFromthispointnonewshadowpagespointingtoadeletedormovedmemslotwillbecreatedValidationofspgfnhappensingfn_to_hvakvm_read_guestgfn_to_pfnkvm_is_visible_gfnmmu_check_rootkvm_arch_flush_shadow_memslotkvmoldkvm_arch_guest_memory_reclaimedkvmWasreleasedbykvm_swap_active_memslotsreacquiremutex_lockkvmslots_arch_lockCopythearchspecificfieldofthenewlyinstalledslotbacktotheoldslotasthearchdatacouldhavechangedbetweenreleasingslots_arch_lockinkvm_swap_active_memslotsandreacquiringthelockaboveWritersarerequiredtoretrievemem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "foristartiendirxa_errxa_storekvmmem",
      "signature": "foristartiendirxa_errxa_storekvmmem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_disable_virtualization_cpuvoidignif__this_cpu_readvirtualization_enabledreturnkvm_arch_disable_virtualization_cpu__this_cpu_writevirt",
      "signature": "kvm_disable_virtualization_cpuvoidignif__this_cpu_readvirtualization_enabledreturnkvm_arch_disable_virtualization_cpu__this_cpu_writevirt",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_offset_cached",
      "signature": "int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_resolve_pfnkfppageNULLflagsFOLL_WRITE",
      "signature": "kvm_resolve_pfnkfppageNULLflagsFOLL_WRITE",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_page",
      "signature": "KVM_INTERNALkvm_write_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_write_guest_page",
      "signature": "KVM_INTERNALkvm_vcpu_write_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest",
      "signature": "KVM_INTERNALkvm_write_guest",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_write_guest",
      "signature": "KVM_INTERNALkvm_vcpu_write_guest",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_offset_cached",
      "signature": "KVM_INTERNALkvm_write_guest_offset_cached",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_cached",
      "signature": "KVM_INTERNALkvm_write_guest_cached",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_arch_allow_write_without_running_vcpu",
      "signature": "kvm_arch_allow_write_without_running_vcpu",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_iodevice_write",
      "signature": "kvm_iodevice_write",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_io_bus_write",
      "signature": "KVM_INTERNALkvm_io_bus_write",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write_cookie",
      "signature": "int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val, long cookie)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "write_gueststructkvmkvmgpa_tgpa",
      "signature": "write_gueststructkvmkvmgpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "write_gueststructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_gueststructkvm_vcpuvcpugpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "write_guestkvmgpa",
      "signature": "write_guestkvmgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_arch_allow_write_without_running_vcpu",
      "signature": "bool kvm_arch_allow_write_without_running_vcpu(struct kvm *kvm)",
      "file": "virt/kvm/dirty_ring.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_gmem_releasestructinodeinodestructfilefilestructkvm_gmemgmemfileprivate_datastructkvm_memory_slotslotstructkvmkvmgmemkvmunsignedlongindexPreventconcurrentattemptstounbindamemslotThisisthelastreferencetothefileandthusnonewbindingscanbecreatedbutdereferencingtheslotforexistingbindingsneedstobeprotectedagainstmemslotupdatesspecificallysothatunbinddoesntraceandfreethememslotkvm_gmem_get_filewillreturnNULLSincereleaseiscalledonlywhenthereferencecountiszeroafterwhichfile_ref_getandget_file_activefailkvm_gmem_get_pfncannotbeusingthefileconcurrentlyfile_ref_putprovidesafullbarrierandget_file_activethematchingacquirebarriermutex_lockkvmslots_lockfilemap_invalidate_lockinodei_mappingxa_for_eachgmembindingsindexslotWRITE_ONCEslotgmem",
      "signature": "kvm_gmem_releasestructinodeinodestructfilefilestructkvm_gmemgmemfileprivate_datastructkvm_memory_slotslotstructkvmkvmgmemkvmunsignedlongindexPreventconcurrentattemptstounbindamemslotThisisthelastreferencetothefileandthusnonewbindingscanbecreatedbutdereferencingtheslotforexistingbindingsneedstobeprotectedagainstmemslotupdatesspecificallysothatunbinddoesntraceandfreethememslotkvm_gmem_get_filewillreturnNULLSincereleaseiscalledonlywhenthereferencecountiszeroafterwhichfile_ref_getandget_file_activefailkvm_gmem_get_pfncannotbeusingthefileconcurrentlyfile_ref_putprovidesafullbarrierandget_file_activethematchingacquirebarriermutex_lockkvmslots_lockfilemap_invalidate_lockinodei_mappingxa_for_eachgmembindingsindexslotWRITE_ONCEslotgmem",
      "file": "virt/kvm/guest_memfd.c",
      "category": "memory_write"
    },
    {
      "function": "__kvm_gmem_unbindstructkvm_memory_slotslotstructkvm_gmemgmemunsignedlongstartslotgmempgoffunsignedlongendstartslotnpagesxa_store_rangegmembindingsstartend1NULLGFP_KERNELsynchronize_srcukvmsrcuensuredthatkvm_gmem_get_pfncannotseethismemslotWRITE_ONCEslotgmem",
      "signature": "__kvm_gmem_unbindstructkvm_memory_slotslotstructkvm_gmemgmemunsignedlongstartslotgmempgoffunsignedlongendstartslotnpagesxa_store_rangegmembindingsstartend1NULLGFP_KERNELsynchronize_srcukvmsrcuensuredthatkvm_gmem_get_pfncannotseethismemslotWRITE_ONCEslotgmem",
      "file": "virt/kvm/guest_memfd.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_offset_cached",
      "signature": "int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val); int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val, long cookie); int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, void *val); int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr, int len, struct kvm_io_device *dev); int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx, struct kvm_io_device *dev); struct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write_cookie",
      "signature": "int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val, long cookie); int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, void *val); int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr, int len, struct kvm_io_device *dev); int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx, struct kvm_io_device *dev); struct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "write_gueststructkvmkvmgpa_tgpa",
      "signature": "write_gueststructkvmkvmgpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "write_gueststructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_gueststructkvm_vcpuvcpugpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    }
  ],
  "page_operations": [
    {
      "function": "kvm_vcpu_is_legal_aligned_gpavcpugpaPAGE_SIZE",
      "signature": "kvm_vcpu_is_legal_aligned_gpavcpugpaPAGE_SIZE",
      "file": "arch/x86/kvm/cpuid.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_alloc_apic_access_page",
      "signature": "int kvm_alloc_apic_access_page(struct kvm *kvm); void kvm_inhibit_apic_access_page(struct kvm_vcpu *vcpu); bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src, struct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map); int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src, struct kvm_lapic_irq *irq, struct dest_map *dest_map); void kvm_apic_send_ipi(struct kvm_lapic *apic, u32 icr_low, u32 icr_high); int kvm_apic_set_base(struct kvm_vcpu *vcpu, u64 value, bool host_initiated); int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s); int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s); void kvm_apic_update_hwapic_isr(struct kvm_vcpu *vcpu); int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu); u64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu); void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data); void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset); void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector); int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr); void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu); void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu); int kvm_x2apic_icr_write_fast(struct kvm_lapic *apic, u64 data); int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_inhibit_apic_access_page",
      "signature": "void kvm_inhibit_apic_access_page(struct kvm_vcpu *vcpu); bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src, struct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map); int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src, struct kvm_lapic_irq *irq, struct dest_map *dest_map); void kvm_apic_send_ipi(struct kvm_lapic *apic, u32 icr_low, u32 icr_high); int kvm_apic_set_base(struct kvm_vcpu *vcpu, u64 value, bool host_initiated); int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s); int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s); void kvm_apic_update_hwapic_isr(struct kvm_vcpu *vcpu); int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu); u64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu); void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data); void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset); void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector); int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr); void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu); void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu); int kvm_x2apic_icr_write_fast(struct kvm_lapic *apic, u64 data); int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "int kvm_xen_write_hypercall_page(struct kvm_vcpu *vcpu, u64 data); int kvm_xen_hvm_config(struct kvm *kvm, struct kvm_xen_hvm_config *xhc); void kvm_xen_init_vm(struct kvm *kvm); void kvm_xen_destroy_vm(struct kvm *kvm); void kvm_xen_init_vcpu(struct kvm_vcpu *vcpu); void kvm_xen_destroy_vcpu(struct kvm_vcpu *vcpu); int kvm_xen_set_evtchn_fast(struct kvm_xen_evtchn *xe, struct kvm *kvm); int kvm_xen_setup_evtchn(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e, const struct kvm_irq_routing_entry *ue); static inline void kvm_xen_sw_enable_lapic(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/xen.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_xen_is_hypercall_page_msr",
      "signature": "bool kvm_xen_is_hypercall_page_msr(struct kvm *kvm, u32 msr)",
      "file": "arch/x86/kvm/xen.h",
      "category": "page_operations"
    },
    {
      "function": "boolnested_page_fault",
      "signature": "boolnested_page_fault",
      "file": "arch/x86/kvm/kvm_emulate.h",
      "category": "page_operations"
    },
    {
      "function": "u8async_page_fault",
      "signature": "u8async_page_fault",
      "file": "arch/x86/kvm/kvm_emulate.h",
      "category": "page_operations"
    },
    {
      "function": "boolx86_page_table_writing_insn",
      "signature": "boolx86_page_table_writing_insn",
      "file": "arch/x86/kvm/kvm_emulate.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/trace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpuvcpuu64gpau64pfn",
      "signature": "kvm_vcpuvcpuu64gpau64pfn",
      "file": "arch/x86/kvm/trace.h",
      "category": "page_operations"
    },
    {
      "function": "TRACE_EVENTkvm_page_fault",
      "signature": "TRACE_EVENTkvm_page_fault",
      "file": "arch/x86/kvm/trace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_alloc_apic_access_page",
      "signature": "int kvm_alloc_apic_access_page(struct kvm *kvm)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_alloc_apic_access_page",
      "signature": "KVM_INTERNALkvm_alloc_apic_access_page",
      "file": "arch/x86/kvm/lapic.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_inhibit_apic_access_page",
      "signature": "void kvm_inhibit_apic_access_page(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_opsalloc_apic_backing_page",
      "signature": "kvm_x86_opsalloc_apic_backing_page",
      "file": "arch/x86/kvm/lapic.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_callalloc_apic_backing_page",
      "signature": "kvm_x86_callalloc_apic_backing_page",
      "file": "arch/x86/kvm/lapic.c",
      "category": "page_operations"
    },
    {
      "function": "get_zeroed_page",
      "signature": "get_zeroed_page",
      "file": "arch/x86/kvm/lapic.c",
      "category": "page_operations"
    },
    {
      "function": "boolx86_page_table_writing_insn",
      "signature": "boolx86_page_table_writing_insn",
      "file": "arch/x86/kvm/emulate.c",
      "category": "page_operations"
    },
    {
      "function": "get_partition_assist_page",
      "signature": "get_partition_assist_page",
      "file": "arch/x86/kvm/kvm_onhyperv.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_activate_synicstructkvm_vcpuvcpubooldont_zero_synic_pages",
      "signature": "kvm_hv_activate_synicstructkvm_vcpuvcpubooldont_zero_synic_pages",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_assist_page_enabled",
      "signature": "bool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu); int kvm_hv_get_assist_page(struct kvm_vcpu *vcpu); static inline struct kvm_vcpu_hv_stimer *to_hv_stimer(struct kvm_vcpu *vcpu, int timer_index)",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_get_assist_page",
      "signature": "int kvm_hv_get_assist_page(struct kvm_vcpu *vcpu); static inline struct kvm_vcpu_hv_stimer *to_hv_stimer(struct kvm_vcpu *vcpu, int timer_index)",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_setup_tsc_page",
      "signature": "void kvm_hv_setup_tsc_page(struct kvm *kvm, struct pvclock_vcpu_time_info *hv_clock); void kvm_hv_request_tsc_page_update(struct kvm *kvm); void kvm_hv_xsaves_xsavec_maybe_warn(struct kvm_vcpu *vcpu); void kvm_hv_init_vm(struct kvm *kvm); void kvm_hv_destroy_vm(struct kvm *kvm); int kvm_hv_vcpu_init(struct kvm_vcpu *vcpu); void kvm_hv_set_cpuid(struct kvm_vcpu *vcpu, bool hyperv_enabled); int kvm_hv_set_enforce_cpuid(struct kvm_vcpu *vcpu, bool enforce); int kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args); int kvm_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid, struct kvm_cpuid_entry2 __user *entries); static inline struct kvm_vcpu_hv_tlb_flush_fifo *kvm_hv_get_tlb_flush_fifo(struct kvm_vcpu *vcpu, bool is_guest_mode)",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_request_tsc_page_update",
      "signature": "void kvm_hv_request_tsc_page_update(struct kvm *kvm); void kvm_hv_xsaves_xsavec_maybe_warn(struct kvm_vcpu *vcpu); void kvm_hv_init_vm(struct kvm *kvm); void kvm_hv_destroy_vm(struct kvm *kvm); int kvm_hv_vcpu_init(struct kvm_vcpu *vcpu); void kvm_hv_set_cpuid(struct kvm_vcpu *vcpu, bool hyperv_enabled); int kvm_hv_set_enforce_cpuid(struct kvm_vcpu *vcpu, bool enforce); int kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args); int kvm_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid, struct kvm_cpuid_entry2 __user *entries); static inline struct kvm_vcpu_hv_tlb_flush_fifo *kvm_hv_get_tlb_flush_fifo(struct kvm_vcpu *vcpu, bool is_guest_mode)",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "page_operations"
    },
    {
      "function": "get_assist_page",
      "signature": "get_assist_page",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_archhv_root_tdpINVALID_PAGE",
      "signature": "kvm_archhv_root_tdpINVALID_PAGE",
      "file": "arch/x86/kvm/kvm_onhyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_inject_page_fault",
      "signature": "void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_inject_emulated_page_fault",
      "signature": "void kvm_inject_emulated_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_inject_emulated_page_fault",
      "signature": "KVM_INTERNALkvm_inject_emulated_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_request_tsc_page_update",
      "signature": "kvm_hv_request_tsc_page_update",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_setup_tsc_page",
      "signature": "kvm_hv_setup_tsc_page",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_xen_is_hypercall_page_msr",
      "signature": "kvm_xen_is_hypercall_page_msr",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "return kvm_xen_write_hypercall_page(vcpu, data); switch (msr)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_CAP_VM_DISABLE_NX_HUGE_PAGES",
      "signature": "KVM_CAP_VM_DISABLE_NX_HUGE_PAGES",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vm_ioctl_set_nr_mmu_pages",
      "signature": "int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm, unsigned long kvm_nr_mmu_pages)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_nr_mmu_pages",
      "signature": "kvm_nr_mmu_pages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_nr_mmu_pagesKVM_MIN_ALLOC_MMU_PAGES",
      "signature": "kvm_nr_mmu_pagesKVM_MIN_ALLOC_MMU_PAGES",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_change_mmu_pageskvmkvm_nr_mmu_pages",
      "signature": "kvm_mmu_change_mmu_pageskvmkvm_nr_mmu_pages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_SET_NR_MMU_PAGES",
      "signature": "KVM_SET_NR_MMU_PAGES",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_read_guest_pagevcpugpaPAGE_SHIFT",
      "signature": "kvm_vcpu_read_guest_pagevcpugpaPAGE_SHIFT",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_write_guest_virt_systemcanpullintonsofpages",
      "signature": "kvm_write_guest_virt_systemcanpullintonsofpages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "kvm_page_track_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mark_page_dirty",
      "signature": "kvm_vcpu_mark_page_dirty",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PIO_PAGE_OFFSETPAGE_SIZE",
      "signature": "KVM_PIO_PAGE_OFFSETPAGE_SIZE",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_inhibit_apic_access_page",
      "signature": "kvm_inhibit_apic_access_page",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_reload_apic_access_page",
      "signature": "void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_callset_apic_access_page_addr",
      "signature": "kvm_x86_callset_apic_access_page_addr",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_check_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "signature": "kvm_check_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_opsnested_opsget_nested_state_pages",
      "signature": "kvm_x86_opsnested_opsget_nested_state_pages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_check_requestKVM_REQ_APIC_PAGE_RELOAD",
      "signature": "kvm_check_requestKVM_REQ_APIC_PAGE_RELOAD",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_init",
      "signature": "kvm_page_track_init",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_cleanup",
      "signature": "kvm_page_track_cleanup",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_NR_PAGE_SIZES",
      "signature": "KVM_NR_PAGE_SIZES",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_free_memslot",
      "signature": "kvm_page_track_free_memslot",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_memory_slotslotunsignedlongnpages",
      "signature": "kvm_memory_slotslotunsignedlongnpages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_lpagesslotnpages",
      "signature": "kvm_mmu_slot_lpagesslotnpages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_lpage_info",
      "signature": "kvm_lpage_info",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGES_PER_HPAGE",
      "signature": "KVM_PAGES_PER_HPAGE",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_create_memslotkvmslotnpages",
      "signature": "kvm_page_track_create_memslotkvmslotnpages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MR_MOVEkvm_page_track_has_external_user",
      "signature": "KVM_MR_MOVEkvm_page_track_has_external_user",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_is_gfn_aliaskvmnewbase_gfnnewnpages",
      "signature": "kvm_is_gfn_aliaskvmnewbase_gfnnewnpages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MEM_LOG_DIRTY_PAGES",
      "signature": "KVM_MEM_LOG_DIRTY_PAGES",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_update_cpu_dirty_loggingkvmlog_dirty_pages",
      "signature": "kvm_mmu_update_cpu_dirty_loggingkvmlog_dirty_pages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_recover_huge_pages",
      "signature": "kvm_mmu_recover_huge_pages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_try_split_huge_pages",
      "signature": "kvm_mmu_slot_try_split_huge_pages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_delete_slot",
      "signature": "kvm_page_track_delete_slot",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO",
      "signature": "KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MIN_ALLOC_MMU_PAGES",
      "signature": "KVM_MIN_ALLOC_MMU_PAGES",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_change_mmu_pageskvmnr_mmu_pages",
      "signature": "kvm_mmu_change_mmu_pageskvmnr_mmu_pages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PV_REASON_PAGE_NOT_PRESENT",
      "signature": "KVM_PV_REASON_PAGE_NOT_PRESENT",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_async_page_not_present",
      "signature": "bool kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_async_page_present",
      "signature": "void kvm_arch_async_page_present(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_async_page_present_queued",
      "signature": "void kvm_arch_async_page_present_queued(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_can_dequeue_async_page_present",
      "signature": "bool kvm_arch_can_dequeue_async_page_present(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_lapic_enabledvcpuapf_pageready_slot_free",
      "signature": "kvm_lapic_enabledvcpuapf_pageready_slot_free",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_gmem_preparestructkvmkvmgfn_tgfnkvm_pfn_tpfn",
      "signature": "kvm_arch_gmem_preparestructkvmkvmgfn_tgfnkvm_pfn_tpfn",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_callgmem_preparekvmpfn",
      "signature": "kvm_x86_callgmem_preparekvmpfn",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_gmem_invalidatekvm_pfn_tstartkvm_pfn_t",
      "signature": "kvm_arch_gmem_invalidatekvm_pfn_tstartkvm_pfn_t",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "get_tsc_page",
      "signature": "get_tsc_page",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "GET_NESTED_STATE_PAGE",
      "signature": "GET_NESTED_STATE_PAGE",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "get_nested_state_page",
      "signature": "get_nested_state_page",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_addr",
      "signature": "kvm_mmu_invalidate_addr",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOT_CURRENT",
      "signature": "KVM_MMU_ROOT_CURRENT",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_roots",
      "signature": "kvm_mmu_free_roots",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_CR0_ROLE_BITS",
      "signature": "KVM_MMU_CR0_ROLE_BITS",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reset_context",
      "signature": "kvm_mmu_reset_context",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_CR4_ROLE_BITS",
      "signature": "KVM_MMU_CR4_ROLE_BITS",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unload",
      "signature": "kvm_mmu_unload",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_NUM_PREV_ROOTS",
      "signature": "KVM_MMU_NUM_PREV_ROOTS",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOT_PREVIOUS",
      "signature": "KVM_MMU_ROOT_PREVIOUS",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_new_pgd",
      "signature": "kvm_mmu_new_pgd",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_EFER_ROLE_BITS",
      "signature": "KVM_MMU_EFER_ROLE_BITS",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sync_roots",
      "signature": "kvm_mmu_sync_roots",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sync_prev_roots",
      "signature": "kvm_mmu_sync_prev_roots",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_change_mmu_pages",
      "signature": "kvm_mmu_change_mmu_pages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_read",
      "signature": "gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_system",
      "signature": "gpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invlpg",
      "signature": "kvm_mmu_invlpg",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unprotect_gfn_and_retry",
      "signature": "kvm_mmu_unprotect_gfn_and_retry",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_vendor_module_init",
      "signature": "kvm_mmu_vendor_module_init",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_vendor_module_exit",
      "signature": "kvm_mmu_vendor_module_exit",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_obsolete_roots",
      "signature": "kvm_mmu_free_obsolete_roots",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_load_pgd",
      "signature": "kvm_mmu_load_pgd",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reload",
      "signature": "kvm_mmu_reload",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_post_init_vm",
      "signature": "kvm_mmu_post_init_vm",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_create",
      "signature": "kvm_mmu_create",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_destroy",
      "signature": "kvm_mmu_destroy",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_init_vm",
      "signature": "kvm_mmu_init_vm",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_uninit_vm",
      "signature": "kvm_mmu_uninit_vm",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pre_destroy_vm",
      "signature": "endif kvm_mmu_pre_destroy_vm(kvm); static_call_cond(kvm_x86_vm_pre_destroy)(kvm); } void kvm_arch_destroy_vm(struct kvm *kvm)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_lpages",
      "signature": "kvm_mmu_slot_lpages",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_init_memslot_memory_attributes",
      "signature": "CONFIG_KVM_GENERIC_MEMORY_ATTRIBUTES kvm_mmu_init_memslot_memory_attributes(kvm, slot); #endif if (kvm_page_track_create_memslot(kvm, slot, npages)) goto out_free; return 0; out_free: memslot_rmap_free(slot); for (i = 1; i < KVM_NR_PAGE_SIZES; ++i)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_mmio_sptes",
      "signature": "kvm_mmu_invalidate_mmio_sptes",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_gfn",
      "signature": "kvm_mmu_max_gfn",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_update_cpu_dirty_logging",
      "signature": "void kvm_mmu_update_cpu_dirty_logging(struct kvm *kvm, bool enable)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_apply_flags",
      "signature": "void kvm_mmu_slot_apply_flags(struct kvm *kvm, struct kvm_memory_slot *old, const struct kvm_memory_slot *new, enum kvm_mr_change change)",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_leaf_clear_dirty",
      "signature": "kvm_mmu_slot_leaf_clear_dirty",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_remove_write_access",
      "signature": "kvm_mmu_slot_remove_write_access",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invpcid_gva",
      "signature": "kvm_mmu_invpcid_gva",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_x86_module_init",
      "signature": "kvm_mmu_x86_module_init",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "voidkvm_inject_page_fault",
      "signature": "voidkvm_inject_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "ifis_guest_modevcpufaultasync_page_fault",
      "signature": "ifis_guest_modevcpufaultasync_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "voidkvm_inject_emulated_page_fault",
      "signature": "voidkvm_inject_emulated_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "fault_mmufaultnested_page_fault",
      "signature": "fault_mmufaultnested_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "fault_mmuinject_page_fault",
      "signature": "fault_mmuinject_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "EXPORT_SYMBOL_FOR_KVM_INTERNALkvm_inject_emulated_page_fault",
      "signature": "EXPORT_SYMBOL_FOR_KVM_INTERNALkvm_inject_emulated_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "callkvm_inject_page_fault",
      "signature": "callkvm_inject_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "faultnested_page_fault",
      "signature": "faultnested_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "faultasync_page_fault",
      "signature": "faultasync_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "vcpuarchwalk_mmuinject_page_fault",
      "signature": "vcpuarchwalk_mmuinject_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "EXPORT_TRACEPOINT_SYMBOL_GPLkvm_page_fault",
      "signature": "EXPORT_TRACEPOINT_SYMBOL_GPLkvm_page_fault",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "IfemulationwascausedbyawriteprotectionPFonanonpage_table",
      "signature": "IfemulationwascausedbyawriteprotectionPFonanonpage_table",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "x86_page_table_writing_insn",
      "signature": "x86_page_table_writing_insn",
      "file": "arch/x86/kvm/x86.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reset_context",
      "signature": "kvm_mmu_reset_context",
      "file": "arch/x86/kvm/smm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_lpage_strKVM_NR_PAGE_SIZES",
      "signature": "kvm_lpage_strKVM_NR_PAGE_SIZES",
      "file": "arch/x86/kvm/debugfs.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_NR_PAGE_SIZES",
      "signature": "KVM_NR_PAGE_SIZES",
      "file": "arch/x86/kvm/debugfs.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_lpages",
      "signature": "kvm_mmu_slot_lpages",
      "file": "arch/x86/kvm/debugfs.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_lpage_str",
      "signature": "kvm_lpage_str",
      "file": "arch/x86/kvm/debugfs.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_rmaps_stat_show",
      "signature": "int kvm_mmu_rmaps_stat_show(struct seq_file *m, void *v)",
      "file": "arch/x86/kvm/debugfs.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_rmaps_stat_open",
      "signature": "int kvm_mmu_rmaps_stat_open(struct inode *inode, struct file *file)",
      "file": "arch/x86/kvm/debugfs.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_rmaps_stat_release",
      "signature": "int kvm_mmu_rmaps_stat_release(struct inode *inode, struct file *file)",
      "file": "arch/x86/kvm/debugfs.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_read_guest_pagevcpumsg_page_gfn",
      "signature": "kvm_vcpu_read_guest_pagevcpumsg_page_gfn",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_write_guest_pagevcpumsg_page_gfn",
      "signature": "kvm_vcpu_write_guest_pagevcpumsg_page_gfn",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_assist_page_enabled",
      "signature": "bool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_hv_assist_page_enabled",
      "signature": "KVM_INTERNALkvm_hv_assist_page_enabled",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_get_assist_page",
      "signature": "int kvm_hv_get_assist_page(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_hv_get_assist_page",
      "signature": "KVM_INTERNALkvm_hv_get_assist_page",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_activate_synicstructkvm_vcpuvcpubooldont_zero_synic_pages",
      "signature": "kvm_hv_activate_synicstructkvm_vcpuvcpubooldont_zero_synic_pages",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_setup_tsc_page",
      "signature": "void kvm_hv_setup_tsc_page(struct kvm *kvm, struct pvclock_vcpu_time_info *hv_clock)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_request_tsc_page_update",
      "signature": "void kvm_hv_request_tsc_page_update(struct kvm *kvm)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mark_page_dirty",
      "signature": "kvm_vcpu_mark_page_dirty",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_callflush_tlb_gvavcpugvajPAGE_SIZE",
      "signature": "kvm_x86_callflush_tlb_gvavcpugvajPAGE_SIZE",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "signature": "kvm_read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "get_assist_page",
      "signature": "get_assist_page",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_roleAsaresultKVMmaymissguestpage",
      "signature": "kvm_mmu_page_roleAsaresultKVMmaymissguestpage",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_cpu_cap_setX86_FEATURE_GBPAGES",
      "signature": "kvm_cpu_cap_setX86_FEATURE_GBPAGES",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_after_set_cpuid",
      "signature": "kvm_mmu_after_set_cpuid",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_role",
      "signature": "kvm_mmu_page_role",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_max_tdp_level",
      "signature": "kvm_mmu_get_max_tdp_level",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_handle_page_fault",
      "signature": "int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code, u64 fault_address, char *insn, int insn_len); void __kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu); int kvm_mmu_load(struct kvm_vcpu *vcpu); void kvm_mmu_unload(struct kvm_vcpu *vcpu); void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_map_page",
      "signature": "int kvm_tdp_map_page(struct kvm_vcpu *vcpu, gpa_t gpa, u64 error_code, u8 *level); static inline bool kvm_memslots_have_rmaps(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_HPAGE_GFN_SHIFT",
      "signature": "KVM_HPAGE_GFN_SHIFT",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_lpagesstructkvm_memory_slotslotunsignedlongnpages",
      "signature": "kvm_mmu_slot_lpagesstructkvm_memory_slotslotunsignedlongnpages",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_lpages",
      "signature": "long kvm_mmu_slot_lpages(struct kvm_memory_slot *slot, int level)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_lpagesslotslotnpages",
      "signature": "kvm_mmu_slot_lpagesslotslotnpages",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_update_page_stats",
      "signature": "void kvm_update_page_stats(struct kvm *kvm, int level, int count)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_CR4_ROLE_BITS",
      "signature": "define KVM_MMU_CR4_ROLE_BITS (X86_CR4_PSE | X86_CR4_PAE | X86_CR4_LA57 | \\ X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE) #define KVM_MMU_CR0_ROLE_BITS (X86_CR0_PG | X86_CR0_WP) #define KVM_MMU_EFER_ROLE_BITS (EFER_LME | EFER_NX) static __always_inline u64 rsvd_bits(int s, int e)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_CR0_ROLE_BITS",
      "signature": "define KVM_MMU_CR0_ROLE_BITS (X86_CR0_PG | X86_CR0_WP) #define KVM_MMU_EFER_ROLE_BITS (EFER_LME | EFER_NX) static __always_inline u64 rsvd_bits(int s, int e)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_EFER_ROLE_BITS",
      "signature": "define KVM_MMU_EFER_ROLE_BITS (EFER_LME | EFER_NX) static __always_inline u64 rsvd_bits(int s, int e)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_gfn",
      "signature": "gfn_t kvm_mmu_max_gfn(void)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_max_tdp_level",
      "signature": "u8 kvm_mmu_get_max_tdp_level(void); void kvm_mmu_set_mmio_spte_mask(u64 mmio_value, u64 mmio_mask, u64 access_mask); void kvm_mmu_set_mmio_spte_value(struct kvm *kvm, u64 mmio_value); void kvm_mmu_set_me_spte_mask(u64 me_value, u64 me_mask); void kvm_mmu_set_ept_masks(bool has_ad_bits, bool has_exec_only); void kvm_init_mmu(struct kvm_vcpu *vcpu); void kvm_init_shadow_npt_mmu(struct kvm_vcpu *vcpu, unsigned long cr0, unsigned long cr4, u64 efer, gpa_t nested_cr3); void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly, int huge_page_level, bool accessed_dirty, gpa_t new_eptp); bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu); int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code, u64 fault_address, char *insn, int insn_len); void __kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu); int kvm_mmu_load(struct kvm_vcpu *vcpu); void kvm_mmu_unload(struct kvm_vcpu *vcpu); void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_mask",
      "signature": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_value, u64 mmio_mask, u64 access_mask); void kvm_mmu_set_mmio_spte_value(struct kvm *kvm, u64 mmio_value); void kvm_mmu_set_me_spte_mask(u64 me_value, u64 me_mask); void kvm_mmu_set_ept_masks(bool has_ad_bits, bool has_exec_only); void kvm_init_mmu(struct kvm_vcpu *vcpu); void kvm_init_shadow_npt_mmu(struct kvm_vcpu *vcpu, unsigned long cr0, unsigned long cr4, u64 efer, gpa_t nested_cr3); void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly, int huge_page_level, bool accessed_dirty, gpa_t new_eptp); bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu); int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code, u64 fault_address, char *insn, int insn_len); void __kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu); int kvm_mmu_load(struct kvm_vcpu *vcpu); void kvm_mmu_unload(struct kvm_vcpu *vcpu); void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_value",
      "signature": "void kvm_mmu_set_mmio_spte_value(struct kvm *kvm, u64 mmio_value); void kvm_mmu_set_me_spte_mask(u64 me_value, u64 me_mask); void kvm_mmu_set_ept_masks(bool has_ad_bits, bool has_exec_only); void kvm_init_mmu(struct kvm_vcpu *vcpu); void kvm_init_shadow_npt_mmu(struct kvm_vcpu *vcpu, unsigned long cr0, unsigned long cr4, u64 efer, gpa_t nested_cr3); void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly, int huge_page_level, bool accessed_dirty, gpa_t new_eptp); bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu); int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code, u64 fault_address, char *insn, int insn_len); void __kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu); int kvm_mmu_load(struct kvm_vcpu *vcpu); void kvm_mmu_unload(struct kvm_vcpu *vcpu); void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_me_spte_mask",
      "signature": "void kvm_mmu_set_me_spte_mask(u64 me_value, u64 me_mask); void kvm_mmu_set_ept_masks(bool has_ad_bits, bool has_exec_only); void kvm_init_mmu(struct kvm_vcpu *vcpu); void kvm_init_shadow_npt_mmu(struct kvm_vcpu *vcpu, unsigned long cr0, unsigned long cr4, u64 efer, gpa_t nested_cr3); void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly, int huge_page_level, bool accessed_dirty, gpa_t new_eptp); bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu); int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code, u64 fault_address, char *insn, int insn_len); void __kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu); int kvm_mmu_load(struct kvm_vcpu *vcpu); void kvm_mmu_unload(struct kvm_vcpu *vcpu); void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_ept_masks",
      "signature": "void kvm_mmu_set_ept_masks(bool has_ad_bits, bool has_exec_only); void kvm_init_mmu(struct kvm_vcpu *vcpu); void kvm_init_shadow_npt_mmu(struct kvm_vcpu *vcpu, unsigned long cr0, unsigned long cr4, u64 efer, gpa_t nested_cr3); void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly, int huge_page_level, bool accessed_dirty, gpa_t new_eptp); bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu); int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code, u64 fault_address, char *insn, int insn_len); void __kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu); int kvm_mmu_load(struct kvm_vcpu *vcpu); void kvm_mmu_unload(struct kvm_vcpu *vcpu); void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_refresh_passthrough_bits",
      "signature": "void kvm_mmu_refresh_passthrough_bits(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_load",
      "signature": "int kvm_mmu_load(struct kvm_vcpu *vcpu); void kvm_mmu_unload(struct kvm_vcpu *vcpu); void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unload",
      "signature": "void kvm_mmu_unload(struct kvm_vcpu *vcpu); void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_obsolete_roots",
      "signature": "void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sync_roots",
      "signature": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu); void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sync_prev_roots",
      "signature": "void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu); void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reload",
      "signature": "int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_load_pgd",
      "signature": "void kvm_mmu_load_pgd(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_may_ignore_guest_pat",
      "signature": "bool kvm_mmu_may_ignore_guest_pat(struct kvm *kvm); int kvm_mmu_post_init_vm(struct kvm *kvm); void kvm_mmu_pre_destroy_vm(struct kvm *kvm); static inline bool kvm_shadow_root_allocated(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_post_init_vm",
      "signature": "int kvm_mmu_post_init_vm(struct kvm *kvm); void kvm_mmu_pre_destroy_vm(struct kvm *kvm); static inline bool kvm_shadow_root_allocated(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pre_destroy_vm",
      "signature": "void kvm_mmu_pre_destroy_vm(struct kvm *kvm); static inline bool kvm_shadow_root_allocated(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "intkvm_handle_page_fault",
      "signature": "intkvm_handle_page_fault",
      "file": "arch/x86/kvm/mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_checkgpcPAGE_SIZE",
      "signature": "kvm_gpc_checkgpcPAGE_SIZE",
      "file": "arch/x86/kvm/xen.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_refreshgpcPAGE_SIZE",
      "signature": "kvm_gpc_refreshgpcPAGE_SIZE",
      "file": "arch/x86/kvm/xen.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "int kvm_xen_write_hypercall_page(struct kvm_vcpu *vcpu, u64 data)",
      "file": "arch/x86/kvm/xen.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_write_guestvcpupage_addrpagePAGE_SIZE",
      "signature": "kvm_vcpu_write_guestvcpupage_addrpagePAGE_SIZE",
      "file": "arch/x86/kvm/xen.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/svm/svm.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tstartkvm_pfn_t",
      "signature": "kvm_pfn_tstartkvm_pfn_t",
      "file": "arch/x86/kvm/svm/svm.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_svmavic_physical_id_tablevoidget_zeroed_page",
      "signature": "kvm_svmavic_physical_id_tablevoidget_zeroed_page",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_svmavic_logical_id_tablevoidget_zeroed_page",
      "signature": "kvm_svmavic_logical_id_tablevoidget_zeroed_page",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_alloc_apic_access_page",
      "signature": "kvm_alloc_apic_access_page",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "page_operations"
    },
    {
      "function": "get_zeroed_page",
      "signature": "get_zeroed_page",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "page_operations"
    },
    {
      "function": "get_backing_page",
      "signature": "get_backing_page",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "page_operations"
    },
    {
      "function": "get_partition_assist_page",
      "signature": "get_partition_assist_page",
      "file": "arch/x86/kvm/svm/svm_onhyperv.c",
      "category": "page_operations"
    },
    {
      "function": "get_vp_assist_page",
      "signature": "get_vp_assist_page",
      "file": "arch/x86/kvm/svm/svm_onhyperv.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_sev_infokvmpages_lockednpages",
      "signature": "kvm_sev_infokvmpages_lockednpages",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_SEV_SNP_PAGE_TYPE_ZERO",
      "signature": "KVM_SEV_SNP_PAGE_TYPE_ZERO",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_SEV_SNP_PAGE_TYPE_CPUID",
      "signature": "KVM_SEV_SNP_PAGE_TYPE_CPUID",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_SEV_SNP_PAGE_TYPE_NORMAL",
      "signature": "KVM_SEV_SNP_PAGE_TYPE_NORMAL",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_SEV_SNP_PAGE_TYPE_UNMEASURED",
      "signature": "KVM_SEV_SNP_PAGE_TYPE_UNMEASURED",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_SEV_SNP_PAGE_TYPE_SECRETS",
      "signature": "KVM_SEV_SNP_PAGE_TYPE_SECRETS",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_populatekvmparamsgfn_startsrcnpages",
      "signature": "kvm_gmem_populatekvmparamsgfn_startsrcnpages",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGES_PER_HPAGE",
      "signature": "KVM_PAGES_PER_HPAGE",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MAP_GPA_RANGE_PAGE_SZ_4K",
      "signature": "KVM_MAP_GPA_RANGE_PAGE_SZ_4K",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MAP_GPA_RANGE_PAGE_SZ_2M",
      "signature": "KVM_MAP_GPA_RANGE_PAGE_SZ_2M",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_get_pfnvcpukvmslotgfnpfnpage",
      "signature": "kvm_gmem_get_pfnvcpukvmslotgfnpfnpage",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_cleanpage",
      "signature": "kvm_release_page_cleanpage",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_read_guestkvmreq_gpasevguest_req_bufPAGE_SIZE",
      "signature": "kvm_read_guestkvmreq_gpasevguest_req_bufPAGE_SIZE",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_write_guestkvmresp_gpasevguest_resp_bufPAGE_SIZE",
      "signature": "kvm_write_guestkvmresp_gpasevguest_resp_bufPAGE_SIZE",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mapvcpughcb_gpaPAGE_SHIFT",
      "signature": "kvm_vcpu_mapvcpughcb_gpaPAGE_SHIFT",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_get_pfnkvmslotgfnpfnpage",
      "signature": "kvm_gmem_get_pfnkvmslotgfnpfnpage",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_unusedpage",
      "signature": "kvm_release_page_unusedpage",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_HPAGE_GFN_SHIFT",
      "signature": "KVM_HPAGE_GFN_SHIFT",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_rmp_make_sharedstructkvmkvmu64pfn",
      "signature": "kvm_rmp_make_sharedstructkvmkvmu64pfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_BUG_ONrmp_make_sharedpfn",
      "signature": "KVM_BUG_ONrmp_make_sharedpfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_BUGrckvmFailedtoreclaimPFNllxrcdfw_errdpfn",
      "signature": "KVM_BUGrckvmFailedtoreclaimPFNllxrcdfw_errdpfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_rmp_make_sharedkvmpfn",
      "signature": "kvm_rmp_make_sharedkvmpfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_rmp_make_sharedvcpukvmpfn",
      "signature": "kvm_rmp_make_sharedvcpukvmpfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_get_pfnvcpukvmslotgfnpfn",
      "signature": "kvm_gmem_get_pfnvcpukvmslotgfnpfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_get_pfnkvmslotgfnpfn",
      "signature": "kvm_gmem_get_pfnkvmslotgfnpfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_rmp_faultvcpugpapfn",
      "signature": "kvm_rmp_faultvcpugpapfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tstartkvm_pfn_t",
      "signature": "kvm_pfn_tstartkvm_pfn_t",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn_alignedALIGN_DOWNpfn",
      "signature": "kvm_pfn_tpfn_alignedALIGN_DOWNpfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn_aligned",
      "signature": "kvm_pfn_tpfn_aligned",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "get_num_contig_page",
      "signature": "get_num_contig_page",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "get_svmsev_essnp_vmsa_gpaINVALID_PAGE",
      "signature": "get_svmsev_essnp_vmsa_gpaINVALID_PAGE",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_handle_page_fault",
      "signature": "return kvm_handle_page_fault(vcpu, error_code, fault_address, static_cpu_has(X86_FEATURE_DECODEASSISTS) ? svm->vmcb->control.insn_bytes : NULL, svm->vmcb->control.insn_len); } static int npf_interception(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_fault",
      "signature": "kvm_mmu_page_fault",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_load",
      "signature": "via kvm_mmu_load() while entering the guest. For guests * that do (SEV-ES/SEV-SNP), the cr3 update needs to be written to * VMCB save area now, since the save area will become the initial * contents of the VMSA, and future VMCB save area updates won't be * seen. */ if (sev_es_guest(vcpu->kvm))",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invlpg",
      "signature": "kvm_mmu_invlpg",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reset_context",
      "signature": "via kvm_mmu_reset_context()). */ if (static_cpu_has(X86_FEATURE_FLUSHBYASID)) svm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID; else svm->current_vmcb->asid_generation--; } static void svm_flush_tlb_current(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_mask",
      "signature": "kvm_mmu_set_mmio_spte_mask",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_me_spte_mask",
      "signature": "kvm_mmu_set_me_spte_mask",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "returnkvm_handle_page_fault",
      "signature": "returnkvm_handle_page_fault",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "trace_kvm_page_fault",
      "signature": "trace_kvm_page_fault",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "rckvm_mmu_page_fault",
      "signature": "rckvm_mmu_page_fault",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_make_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "signature": "kvm_make_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_clear_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "signature": "kvm_clear_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "page_operations"
    },
    {
      "function": "GET_NESTED_STATE_PAGE",
      "signature": "GET_NESTED_STATE_PAGE",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "page_operations"
    },
    {
      "function": "get_nested_state_page",
      "signature": "get_nested_state_page",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "page_operations"
    },
    {
      "function": "get_nested_state_pagessvm_get_nested_state_page",
      "signature": "get_nested_state_pagessvm_get_nested_state_page",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_new_pgd",
      "signature": "kvm_mmu_new_pgd",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "page_operations"
    },
    {
      "function": "vcpuarchmmuinject_page_fault",
      "signature": "vcpuarchmmuinject_page_fault",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_enable",
      "signature": "in kvm_page_track_write_tracking_enable(). */ return smp_load_acquire(&kvm->arch.external_write_tracking_enabled); #else return false; #endif } bool kvm_page_track_write_tracking_enabled(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "bool kvm_page_track_write_tracking_enabled(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_free_memslot",
      "signature": "void kvm_page_track_free_memslot(struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_create_memslot",
      "signature": "int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_allocslotnpages",
      "signature": "kvm_page_track_write_tracking_allocslotnpages",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_allocslotslotnpages",
      "signature": "kvm_page_track_write_tracking_allocslotslotnpages",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_BUG_ONkvm_page_track_write_tracking_enabled",
      "signature": "KVM_BUG_ONkvm_page_track_write_tracking_enabled",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gfn_disallow_lpage",
      "signature": "kvm_mmu_gfn_disallow_lpage",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gfn_allow_lpage",
      "signature": "kvm_mmu_gfn_allow_lpage",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_cleanup",
      "signature": "void kvm_page_track_cleanup(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_notifier_head",
      "signature": "kvm_page_track_notifier_head",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_init",
      "signature": "int kvm_page_track_init(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_register_notifier",
      "signature": "int kvm_page_track_register_notifier(struct kvm *kvm, struct kvm_page_track_notifier_node *n)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_notifier_node",
      "signature": "kvm_page_track_notifier_node",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_unregister_notifier",
      "signature": "void kvm_page_track_unregister_notifier(struct kvm *kvm, struct kvm_page_track_notifier_node *n)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "kvm_page_track_write",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_delete_slot",
      "signature": "void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "kvm_mmu_slot_gfn_write_protect",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_iter.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_WARN_ON",
      "signature": "KVM_MMU_WARN_ON",
      "file": "arch/x86/kvm/mmu/tdp_iter.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pageto_shadow_pagehpa_tshadow_page",
      "signature": "kvm_mmu_pageto_shadow_pagehpa_tshadow_page",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagepage_privatepage",
      "signature": "kvm_mmu_pagepage_privatepage",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpuvcpustructkvm_mmu_page",
      "signature": "kvm_vcpuvcpustructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_role",
      "signature": "kvm_mmu_page_role",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tspte_to_pfn",
      "signature": "kvm_pfn_tspte_to_pfn",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_is_dummy_root",
      "signature": "kvm_mmu_is_dummy_root",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_WARN_ON",
      "signature": "KVM_MMU_WARN_ON",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_apply_flags",
      "signature": "see kvm_mmu_slot_apply_flags()), and * when clearing dirty logs, KVM flushes based on whether or not dirty entries * were reaped from the bitmap/ring, not whether or not dirty SPTEs were found. * * Note, this logic only applies to shadow-present leaf SPTEs. The caller is * responsible for checking that the old SPTE is shadow-present, and is also * responsible for determining whether or not a TLB flush is required when * modifying a shadow-present non-leaf SPTE. */ static inline bool leaf_spte_change_needs_tlb_flush(u64 old_spte, u64 new_spte)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_spte_module_init",
      "signature": "__init kvm_mmu_spte_module_init(void); void kvm_mmu_reset_all_pte_masks(void)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reset_all_pte_masks",
      "signature": "void kvm_mmu_reset_all_pte_masks(void)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "staticinlineboolis_access_allowedstructkvm_page_fault",
      "signature": "staticinlineboolis_access_allowedstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_get_gfnstructkvm_mmu_page",
      "signature": "kvm_mmu_page_get_gfnstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_get_gfn",
      "signature": "gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index); /* Flush the range of guest memory mapped by the given SPTE. */ static void kvm_flush_remote_tlbs_sptep(struct kvm *kvm, u64 *sptep)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_update_page_stats",
      "signature": "kvm_update_page_stats",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_commit_zap_page",
      "signature": "void kvm_mmu_commit_zap_page(struct kvm *kvm, struct list_head *invalid_list); static bool sp_has_gptes(struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_topup_memory_cachevcpuarchmmu_shadow_page_cache",
      "signature": "kvm_mmu_topup_memory_cachevcpuarchmmu_shadow_page_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_topup_memory_cachevcpuarchmmu_page_header_cache",
      "signature": "kvm_mmu_topup_memory_cachevcpuarchmmu_page_header_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_memory_cachevcpuarchmmu_shadow_page_cache",
      "signature": "kvm_mmu_free_memory_cachevcpuarchmmu_shadow_page_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_memory_cachevcpuarchmmu_page_header_cache",
      "signature": "kvm_mmu_free_memory_cachevcpuarchmmu_page_header_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_get_accessstructkvm_mmu_page",
      "signature": "kvm_mmu_page_get_accessstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_set_translationstructkvm_mmu_page",
      "signature": "kvm_mmu_page_set_translationstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_get_access",
      "signature": "u32 kvm_mmu_page_get_access(struct kvm_mmu_page *sp, int index)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_set_accessstructkvm_mmu_page",
      "signature": "kvm_mmu_page_set_accessstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_set_translation",
      "signature": "void kvm_mmu_page_set_translation(struct kvm_mmu_page *sp, int index, gfn_t gfn, unsigned int access)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_lpage_infolpage_info_slot",
      "signature": "kvm_lpage_infolpage_info_slot",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_LPAGE_MIXED_FLAG",
      "signature": "KVM_LPAGE_MIXED_FLAG",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_lpage_info",
      "signature": "kvm_lpage_info",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MAX_HUGEPAGE_LEVEL",
      "signature": "KVM_MAX_HUGEPAGE_LEVEL",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gfn_disallow_lpage",
      "signature": "void kvm_mmu_gfn_disallow_lpage(const struct kvm_memory_slot *slot, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gfn_allow_lpage",
      "signature": "void kvm_mmu_gfn_allow_lpage(const struct kvm_memory_slot *slot, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_try_split_huge_pages",
      "signature": "void kvm_mmu_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *memslot, u64 start, u64 end, int target_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGES_PER_HPAGE",
      "signature": "KVM_PAGES_PER_HPAGE",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_opsset_apic_access_page_addr",
      "signature": "kvm_x86_opsset_apic_access_page_addr",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_make_all_cpus_requestkvmKVM_REQ_APIC_PAGE_RELOAD",
      "signature": "kvm_make_all_cpus_requestkvmKVM_REQ_APIC_PAGE_RELOAD",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_check_sptes_at_freestructkvm_mmu_page",
      "signature": "kvm_mmu_check_sptes_at_freestructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_account_mmu_pagestructkvmkvmstructkvm_mmu_page",
      "signature": "kvm_account_mmu_pagestructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_account_pgtable_pages",
      "signature": "kvm_account_pgtable_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_unaccount_mmu_pagestructkvmkvmstructkvm_mmu_page",
      "signature": "kvm_unaccount_mmu_pagestructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_shadow_pagestructkvm_mmu_page",
      "signature": "kvm_mmu_free_shadow_pagestructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_table_hashfn",
      "signature": "unsigned kvm_page_table_hashfn(gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_mark_parents_unsyncstructkvm_mmu_page",
      "signature": "kvm_mmu_mark_parents_unsyncstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGE_ARRAY_NR",
      "signature": "KVM_PAGE_ARRAY_NR",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pages",
      "signature": "kvm_mmu_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagespvecstructkvm_mmu_page",
      "signature": "kvm_mmu_pagespvecstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_unlink_unsync_pagestructkvmkvmstructkvm_mmu_page",
      "signature": "kvm_unlink_unsync_pagestructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sync_page",
      "signature": "kvm_mmu_sync_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_prepare_zap_pagestructkvmkvmstructkvm_mmu_page",
      "signature": "kvm_mmu_prepare_zap_pagestructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_get_mmu_page_hash",
      "signature": "hlist_head *kvm_get_mmu_page_hash(struct kvm *kvm, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_alloc_page_hash",
      "signature": "in * kvm_mmu_alloc_page_hash(). */ struct hlist_head *page_hash = smp_load_acquire(&kvm->arch.mmu_page_hash); lockdep_assert_held(&kvm->mmu_lock); if (!page_hash) return &empty_page_hash; return &page_hash[kvm_page_table_hashfn(gfn)]; } #define for_each_valid_sp(_kvm, _sp, _list) \\ hlist_for_each_entry(_sp, _list, hash_link) \\ if (is_obsolete_sp((_kvm), (_sp)))",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_sync_page_checkstructkvm_vcpuvcpustructkvm_mmu_page",
      "signature": "kvm_sync_page_checkstructkvm_vcpuvcpustructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_role",
      "signature": "kvm_mmu_page_role",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_sync_sptestructkvm_vcpuvcpustructkvm_mmu_page",
      "signature": "kvm_sync_sptestructkvm_vcpuvcpustructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_sync_pagestructkvm_vcpuvcpustructkvm_mmu_page",
      "signature": "kvm_sync_pagestructkvm_vcpuvcpustructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_sync_page_check",
      "signature": "bool kvm_sync_page_check(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_sync_page",
      "signature": "int kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp, struct list_head *invalid_list)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_prepare_zap_page",
      "signature": "bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp, struct list_head *invalid_list); static void kvm_mmu_commit_zap_page(struct kvm *kvm, struct list_head *invalid_list); static bool sp_has_gptes(struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagesppvecpage",
      "signature": "kvm_mmu_pagesppvecpage",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagespages",
      "signature": "kvm_mmu_pagespages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_unlink_unsync_page",
      "signature": "void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagekvm_mmu_find_shadow_page",
      "signature": "kvm_mmu_pagekvm_mmu_find_shadow_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cachepage_header_cache",
      "signature": "kvm_mmu_memory_cachepage_header_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cacheshadow_page_cache",
      "signature": "kvm_mmu_memory_cacheshadow_page_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagekvm_mmu_alloc_shadow_page",
      "signature": "kvm_mmu_pagekvm_mmu_alloc_shadow_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_alloccachespage_header_cache",
      "signature": "kvm_mmu_memory_cache_alloccachespage_header_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_alloccachesshadow_page_cache",
      "signature": "kvm_mmu_memory_cache_alloccachesshadow_page_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_zap_obsolete_pages",
      "signature": "as kvm_zap_obsolete_pages() * depends on valid pages being added to the head of the list. See * comments in kvm_zap_obsolete_pages(). */ sp->mmu_valid_gen = kvm->arch.mmu_valid_gen; list_add(&sp->link, &kvm->arch.active_mmu_pages); kvm_account_mmu_page(kvm, sp); sp->gfn = gfn; sp->role = role; hlist_add_head(&sp->hash_link, sp_list); if (sp_has_gptes(sp)) account_shadowed(kvm, sp); return sp; } /* Note, @vcpu may be NULL if @role.direct is true; see kvm_mmu_find_shadow_page. */ static struct kvm_mmu_page *__kvm_mmu_get_shadow_page(struct kvm *kvm, struct kvm_vcpu *vcpu, struct shadow_page_caches *caches, gfn_t gfn, union kvm_mmu_page_role role)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_account_mmu_page",
      "signature": "void kvm_account_mmu_page(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_find_shadow_page",
      "signature": "kvm_mmu_page *kvm_mmu_find_shadow_page(struct kvm *kvm, struct kvm_vcpu *vcpu, gfn_t gfn, struct hlist_head *sp_list, union kvm_mmu_page_role role)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page__kvm_mmu_get_shadow_page",
      "signature": "kvm_mmu_page__kvm_mmu_get_shadow_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_alloc_shadow_page",
      "signature": "kvm_mmu_page *kvm_mmu_alloc_shadow_page(struct kvm *kvm, struct shadow_page_caches *caches, gfn_t gfn, struct hlist_head *sp_list, union kvm_mmu_page_role role)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_page",
      "signature": "kvm_mmu_get_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagekvm_mmu_get_shadow_page",
      "signature": "kvm_mmu_pagekvm_mmu_get_shadow_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_shadow_page",
      "signature": "kvm_mmu_page *kvm_mmu_get_shadow_page(struct kvm_vcpu *vcpu, gfn_t gfn, union kvm_mmu_page_role role)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_unlink_children",
      "signature": "int kvm_mmu_page_unlink_children(struct kvm *kvm, struct kvm_mmu_page *sp, struct list_head *invalid_list)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unlink_parentsstructkvmkvmstructkvm_mmu_page",
      "signature": "kvm_mmu_unlink_parentsstructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_unaccount_mmu_page",
      "signature": "void kvm_unaccount_mmu_page(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_shadow_page",
      "signature": "void kvm_mmu_free_shadow_page(struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_oldest_mmu_pages",
      "signature": "long kvm_mmu_zap_oldest_mmu_pages(struct kvm *kvm, unsigned long nr_to_zap)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_available_pages",
      "signature": "long kvm_mmu_available_pages(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MIN_FREE_MMU_PAGES",
      "signature": "KVM_MIN_FREE_MMU_PAGES",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_oldest_mmu_pagesvcpukvmKVM_REFILL_PAGES",
      "signature": "kvm_mmu_zap_oldest_mmu_pagesvcpukvmKVM_REFILL_PAGES",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_change_mmu_pagesstructkvmkvmunsignedlonggoal_nr_mmu_pages",
      "signature": "kvm_mmu_change_mmu_pagesstructkvmkvmunsignedlonggoal_nr_mmu_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_oldest_mmu_pageskvmkvmarchn_used_mmu_pages",
      "signature": "kvm_mmu_zap_oldest_mmu_pageskvmkvmarchn_used_mmu_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_unsync_pagestructkvmkvmstructkvm_mmu_page",
      "signature": "kvm_unsync_pagestructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unsync_page",
      "signature": "kvm_mmu_unsync_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_unsync_page",
      "signature": "void kvm_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfnstructkvm_page_fault",
      "signature": "kvm_pfn_tpfnstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_set_access",
      "signature": "void kvm_mmu_page_set_access(struct kvm_mmu_page *sp, int index, unsigned int access)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_prefetch_pagesslotgfnpagesnr_pages",
      "signature": "kvm_prefetch_pagesslotgfnpagesnr_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_dirtypages",
      "signature": "kvm_release_page_dirtypages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_WARN_ONorderKVM_HPAGE_GFN_SHIFT",
      "signature": "KVM_MMU_WARN_ONorderKVM_HPAGE_GFN_SHIFT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_HPAGE_GFN_SHIFT",
      "signature": "KVM_HPAGE_GFN_SHIFT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "signature": "kvm_gmem_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "signature": "kvm_mmu_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_hugepage_adjuststructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_mmu_hugepage_adjuststructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_hugepage_adjust",
      "signature": "void kvm_mmu_hugepage_adjust(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_handle_error_pfnstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_handle_error_pfnstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_NUM_MMU_PAGES",
      "signature": "KVM_NUM_MMU_PAGES",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "kvm_page_track_write_tracking_enabled",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "kvm_page_track_write_tracking_alloc",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_is_visible_gfnvcpupdptrsiPAGE_SHIFT",
      "signature": "kvm_vcpu_is_visible_gfnvcpupdptrsiPAGE_SHIFT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_async_page_ready",
      "signature": "void kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_do_page_fault",
      "signature": "kvm_mmu_do_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_finish_page_fault",
      "signature": "void kvm_mmu_finish_page_fault(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault, int r)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_faultin_pagevcpukvmfaultrefcounted_page",
      "signature": "kvm_release_faultin_pagevcpukvmfaultrefcounted_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_try_async_get_page",
      "signature": "kvm_try_async_get_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_handle_page_fault",
      "signature": "int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code, u64 fault_address, char *insn, int insn_len)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_fault",
      "signature": "noinline kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code, void *insn, int insn_len)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PV_REASON_PAGE_NOT_PRESENT",
      "signature": "KVM_PV_REASON_PAGE_NOT_PRESENT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_handle_page_fault",
      "signature": "KVM_INTERNALkvm_handle_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_page_fault",
      "signature": "int kvm_tdp_mmu_page_fault(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_tdp_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_map_page",
      "signature": "int kvm_tdp_map_page(struct kvm_vcpu *vcpu, gpa_t gpa, u64 error_code, u8 *level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_page_fault",
      "signature": "int kvm_tdp_page_fault(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_tdp_map_page",
      "signature": "KVM_INTERNALkvm_tdp_map_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_HPAGE_MASKlevelKVM_HPAGE_SIZE",
      "signature": "KVM_HPAGE_MASKlevelKVM_HPAGE_SIZE",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmucontextboolexeconlyinthuge_page_level",
      "signature": "kvm_mmucontextboolexeconlyinthuge_page_level",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_calc_tdp_mmu_root_page_role",
      "signature": "kvm_mmu_page_role kvm_calc_tdp_mmu_root_page_role(struct kvm_vcpu *vcpu, union kvm_cpu_role cpu_role)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_roleroot_rolekvm_calc_tdp_mmu_root_page_role",
      "signature": "kvm_mmu_page_roleroot_rolekvm_calc_tdp_mmu_root_page_role",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_inject_page_fault",
      "signature": "kvm_inject_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_calc_shadow_ept_root_page_role",
      "signature": "kvm_cpu_role kvm_calc_shadow_ept_root_page_role(struct kvm_vcpu *vcpu, bool accessed_dirty, bool execonly, u8 level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_mmu_page_fault",
      "signature": "KVM_INTERNALkvm_mmu_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_memory_cachekvmarchsplit_page_header_cache",
      "signature": "kvm_mmu_free_memory_cachekvmarchsplit_page_header_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_memory_cachekvmarchsplit_shadow_page_cache",
      "signature": "kvm_mmu_free_memory_cachekvmarchsplit_shadow_page_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_topup_memory_cachekvmarchsplit_page_header_cache",
      "signature": "kvm_mmu_topup_memory_cachekvmarchsplit_page_header_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_topup_memory_cachekvmarchsplit_shadow_page_cache",
      "signature": "kvm_mmu_topup_memory_cachekvmarchsplit_shadow_page_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_available_pageskvmKVM_MIN_FREE_MMU_PAGES",
      "signature": "kvm_mmu_available_pageskvmKVM_MIN_FREE_MMU_PAGES",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_split_huge_page",
      "signature": "kvm_mmu_split_huge_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_shadow_mmu_try_split_huge_pages",
      "signature": "void kvm_shadow_mmu_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t start, gfn_t end, int target_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_try_split_huge_pages",
      "signature": "kvm_tdp_mmu_try_split_huge_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_try_split_huge_pages",
      "signature": "in * kvm_mmu_slot_try_split_huge_pages(). */ } void kvm_mmu_slot_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *memslot, int target_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_recover_huge_pages",
      "signature": "void kvm_mmu_recover_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_recover_huge_pages",
      "signature": "kvm_tdp_mmu_recover_huge_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_memslot_pages_and_flush",
      "signature": "void kvm_mmu_zap_memslot_pages_and_flush(struct kvm *kvm, struct kvm_memory_slot *slot, bool flush)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_debug_ratelimitedzappingshadowpages",
      "signature": "kvm_debug_ratelimitedzappingshadowpages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_header",
      "signature": "kvm_mmu_page_header",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_recover_nx_huge_pages",
      "signature": "void kvm_recover_nx_huge_pages(struct kvm *kvm, const enum kvm_mmu_type mmu_type)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_zap_possible_nx_huge_page",
      "signature": "kvm_tdp_mmu_zap_possible_nx_huge_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_nx_huge_page_recovery_worker_kill",
      "signature": "void kvm_nx_huge_page_recovery_worker_kill(void *data)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_nx_huge_page_recovery_worker",
      "signature": "bool kvm_nx_huge_page_recovery_worker(void *data)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_start_lpage_recovery",
      "signature": "int kvm_mmu_start_lpage_recovery(struct once *once)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_range_addkvmstartstartnr_pages",
      "signature": "kvm_mmu_invalidate_range_addkvmstartstartnr_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_range_addkvmendendnr_pages",
      "signature": "kvm_mmu_invalidate_range_addkvmendendnr_pages",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_FAULT",
      "signature": "KVM_PFN_ERR_FAULT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_callgmem_max_mapping_levelkvmpfn",
      "signature": "kvm_x86_callgmem_max_mapping_levelkvmpfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_t",
      "signature": "kvm_pfn_t",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_handle_error_pfn",
      "signature": "int kvm_handle_error_pfn(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_RO_FAULT",
      "signature": "KVM_PFN_ERR_RO_FAULT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_HWPOISON",
      "signature": "KVM_PFN_ERR_HWPOISON",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_NOSLOT",
      "signature": "KVM_PFN_NOSLOT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_faultin_pfn_gmem",
      "signature": "int kvm_mmu_faultin_pfn_gmem(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_get_pfnvcpukvmfaultslotfaultgfnfaultpfn",
      "signature": "kvm_gmem_get_pfnvcpukvmfaultslotfaultgfnfaultpfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_faultin_pfn",
      "signature": "int kvm_mmu_faultin_pfn(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault, unsigned int access)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_faultin_pfn",
      "signature": "kvm_faultin_pfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_NEEDS_IO",
      "signature": "KVM_PFN_ERR_NEEDS_IO",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "get_nx_huge_page",
      "signature": "get_nx_huge_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "get_gfnstructkvm_mmu_page",
      "signature": "get_gfnstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "get_accessstructkvm_mmu_page",
      "signature": "get_accessstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "get_mmu_page",
      "signature": "get_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "get_shadow_page",
      "signature": "get_shadow_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "get_zeroed_page",
      "signature": "get_zeroed_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "get_written_sptesstructkvm_mmu_page",
      "signature": "get_written_sptesstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_role_regs",
      "signature": "kvm_mmu_role_regs",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_CR0_ROLE_BITS",
      "signature": "KVM_MMU_CR0_ROLE_BITS",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_CR4_ROLE_BITS",
      "signature": "KVM_MMU_CR4_ROLE_BITS",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_guest_pgd",
      "signature": "long kvm_mmu_get_guest_pgd(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_WARN_ON",
      "signature": "KVM_MMU_WARN_ON",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_topup_memory_cache",
      "signature": "return kvm_mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache, PT64_ROOT_MAX_LEVEL); } static void mmu_free_memory_caches(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_memory_cache",
      "signature": "kvm_mmu_free_memory_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "in kvm_mmu_track_write(). */ smp_mb(); gfn = sp->gfn; slots = kvm_memslots_for_spte_role(kvm, sp->role); slot = __gfn_to_memslot(slots, gfn); /* the non-leaf shadow pages are keeping readonly. */ if (sp->role.level > PG_LEVEL_4K) return __kvm_write_track_add_gfn(kvm, slot, gfn); kvm_mmu_gfn_disallow_lpage(slot, gfn); if (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn, PG_LEVEL_4K)) kvm_flush_remote_tlbs_gfn(kvm, gfn, PG_LEVEL_4K); } void track_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp, enum kvm_mmu_type mmu_type)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm, struct kvm_memory_slot *slot, u64 gfn, int min_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_type",
      "signature": "kvm_mmu_type",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache",
      "signature": "kvm_mmu_memory_cache",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_alloc",
      "signature": "kvm_mmu_memory_cache_alloc",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_write_protect_pt_masked",
      "signature": "void kvm_mmu_write_protect_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_clear_dirty_pt_masked",
      "signature": "void kvm_mmu_clear_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_check_sptes_at_free",
      "signature": "void kvm_mmu_check_sptes_at_free(struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_HASH_SHIFT",
      "signature": "KVM_MMU_HASH_SHIFT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_mark_parents_unsync",
      "signature": "void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_remote_flush_or_zap",
      "signature": "bool kvm_mmu_remote_flush_or_zap(struct kvm *kvm, struct list_head *invalid_list, bool remote_flush)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_child_role",
      "signature": "kvm_mmu_page_role kvm_mmu_child_role(u64 *sptep, bool direct, unsigned int access)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_child_sp",
      "signature": "kvm_mmu_page *kvm_mmu_get_child_sp(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn, bool direct, unsigned int access)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unlink_parents",
      "signature": "void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_all_fast",
      "signature": "in kvm_mmu_zap_all_fast(). Note, is_obsolete_sp() also * treats invalid shadow pages as being obsolete. */ zapped_root = !is_obsolete_sp(kvm, sp); } if (sp->nx_huge_page_disallowed) unaccount_nx_huge_page(kvm, sp); sp->role.invalid = 1; /* * Make the request to free obsolete roots after marking the root * invalid, otherwise other vCPUs may not see it as invalid. */ if (zapped_root) kvm_make_all_cpus_request(kvm, KVM_REQ_MMU_FREE_OBSOLETE_ROOTS); return list_unstable; } static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp, struct list_head *invalid_list)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_change_mmu_pages",
      "signature": "void kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned long goal_nr_mmu_pages)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unprotect_gfn_and_retry",
      "signature": "kvm_mmu_unprotect_gfn_and_retry",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "kvm_mmu_gva_to_gpa_write",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sync_roots",
      "signature": "because * kvm_mmu_sync_roots() checks the unsync flags without holding * the MMU lock and so can race with this. If the SPTE was updated * before the page had been marked as unsync-ed, something like the * following could happen: * * CPU 1 CPU 2 * --------------------------------------------------------------------- * 1.2 Host updates SPTE * to be writable * 2.1 Guest writes a GPTE for GVA X. * (GPTE being in the guest page table shadowed * by the SP from CPU 1.) * This reads SPTE during the page table walk. * Since SPTE.W is read as 1, there is no * fault. * * 2.2 Guest issues TLB flush. * That causes a VM Exit. * * 2.3 Walking of unsync pages sees sp->unsync is * false and skips the page. * * 2.4 Guest accesses GVA X. * Since the mapping in the SP was not updated, * so the old mapping for GVA X incorrectly * gets used. * 1.1 Host marks SP * as unsync * (sp->unsync = true) * * The write barrier below ensures that 1.1 happens before 1.2 and thus * the situation in 2.4 does not arise. It pairs with the read barrier * in is_unsync_root(), placed between 2.1's load of SPTE.W and 2.3. */ smp_wmb(); return 0; } static int mmu_set_spte(struct kvm_vcpu *vcpu, struct kvm_memory_slot *slot, u64 *sptep, unsigned int pte_access, gfn_t gfn, kvm_pfn_t pfn, struct kvm_page_fault *fault)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_spte",
      "signature": "kvm_mmu_set_spte",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_prefetch_sptes",
      "signature": "bool kvm_mmu_prefetch_sptes(struct kvm_vcpu *vcpu, gfn_t gfn, u64 *sptep, int nr_pages, unsigned int access)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_mapping_level",
      "signature": "int kvm_mmu_max_mapping_level(struct kvm *kvm, struct kvm_page_fault *fault, const struct kvm_memory_slot *slot, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_spte_requested",
      "signature": "kvm_mmu_spte_requested",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_prepare_memory_fault_exit",
      "signature": "kvm_mmu_prepare_memory_fault_exit",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_gfn",
      "signature": "kvm_mmu_max_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOT_",
      "signature": "KVM_MMU_ROOT_",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_roots",
      "signature": "void kvm_mmu_free_roots(struct kvm *kvm, struct kvm_mmu *mmu, ulong roots_to_free)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOTS_ALL",
      "signature": "KVM_MMU_ROOTS_ALL",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_NUM_PREV_ROOTS",
      "signature": "KVM_MMU_NUM_PREV_ROOTS",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOT_CURRENT",
      "signature": "KVM_MMU_ROOT_CURRENT",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOT_PREVIOUS",
      "signature": "KVM_MMU_ROOT_PREVIOUS",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_is_dummy_root",
      "signature": "kvm_mmu_is_dummy_root",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_guest_mode_roots",
      "signature": "void kvm_mmu_free_guest_mode_roots(struct kvm *kvm, struct kvm_mmu *mmu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_dummy_root",
      "signature": "kvm_mmu_get_dummy_root",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sync_prev_roots",
      "signature": "void kvm_mmu_sync_prev_roots(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reload",
      "signature": "kvm_mmu_reload",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_root_info",
      "signature": "kvm_mmu_root_info",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_new_pgd",
      "signature": "void kvm_mmu_new_pgd(struct kvm_vcpu *vcpu, gpa_t new_pgd)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_refresh_passthrough_bits",
      "signature": "kvm_mmu_refresh_passthrough_bits",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_tdp_level",
      "signature": "int kvm_mmu_get_tdp_level(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_max_tdp_level",
      "signature": "u8 kvm_mmu_get_max_tdp_level(void)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_after_set_cpuid",
      "signature": "void kvm_mmu_after_set_cpuid(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reset_context",
      "signature": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unload",
      "signature": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_load",
      "signature": "int kvm_mmu_load(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_load_pgd",
      "signature": "kvm_mmu_load_pgd",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_obsolete_roots",
      "signature": "void kvm_mmu_free_obsolete_roots(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_write_protect_fault",
      "signature": "int kvm_mmu_write_protect_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code, int *emulation_type)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_print_sptes",
      "signature": "void kvm_mmu_print_sptes(struct kvm_vcpu *vcpu, gpa_t gpa, const char *msg)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_addr",
      "signature": "void kvm_mmu_invalidate_addr(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, u64 addr, unsigned long roots)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invlpg",
      "signature": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invpcid_gva",
      "signature": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_create",
      "signature": "int kvm_mmu_create(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOT_INFO_INVALID",
      "signature": "KVM_MMU_ROOT_INFO_INVALID",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_init_vm",
      "signature": "int kvm_mmu_init_vm(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_init_tdp_mmu",
      "signature": "kvm_mmu_init_tdp_mmu",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_uninit_vm",
      "signature": "void kvm_mmu_uninit_vm(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_uninit_tdp_mmu",
      "signature": "kvm_mmu_uninit_tdp_mmu",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_begin",
      "signature": "kvm_mmu_invalidate_begin",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_range_add",
      "signature": "kvm_mmu_invalidate_range_add",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_end",
      "signature": "kvm_mmu_invalidate_end",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_remove_write_access",
      "signature": "void kvm_mmu_slot_remove_write_access(struct kvm *kvm, const struct kvm_memory_slot *memslot, int start_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_nr_free_objects",
      "signature": "return kvm_mmu_memory_cache_nr_free_objects(cache) < min; } static bool need_topup_split_caches_or_resched(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_collapsible_spte",
      "signature": "bool kvm_mmu_zap_collapsible_spte(struct kvm *kvm, struct kvm_rmap_head *rmap_head, const struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_leaf_clear_dirty",
      "signature": "void kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm, const struct kvm_memory_slot *memslot)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_all",
      "signature": "void kvm_mmu_zap_all(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_memslot",
      "signature": "void kvm_mmu_zap_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_mmio_sptes",
      "signature": "void kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, u64 gen)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_x86_module_init",
      "signature": "__init kvm_mmu_x86_module_init(void)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_spte_module_init",
      "signature": "kvm_mmu_spte_module_init",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_vendor_module_init",
      "signature": "int kvm_mmu_vendor_module_init(void)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_extended_role",
      "signature": "kvm_mmu_extended_role",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reset_all_pte_masks",
      "signature": "kvm_mmu_reset_all_pte_masks",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_destroy",
      "signature": "void kvm_mmu_destroy(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_vendor_module_exit",
      "signature": "void kvm_mmu_vendor_module_exit(void)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sp_dirty_logging_enabled",
      "signature": "bool kvm_mmu_sp_dirty_logging_enabled(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_post_init_vm",
      "signature": "int kvm_mmu_post_init_vm(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pre_destroy_vm",
      "signature": "void kvm_mmu_pre_destroy_vm(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_init_memslot_memory_attributes",
      "signature": "void kvm_mmu_init_memslot_memory_attributes(struct kvm *kvm, struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticu8kvm_gmem_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "signature": "staticu8kvm_gmem_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "intkvm_mmu_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "signature": "intkvm_mmu_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "voidkvm_mmu_hugepage_adjuststructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "voidkvm_mmu_hugepage_adjuststructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "voiddisallowed_hugepage_adjuststructkvm_page_fault",
      "signature": "voiddisallowed_hugepage_adjuststructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticintdirect_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "staticintdirect_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticintkvm_handle_error_pfnstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "staticintkvm_handle_error_pfnstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "structkvm_page_fault",
      "signature": "structkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticboolpage_fault_can_be_faststructkvmkvmstructkvm_page_fault",
      "signature": "staticboolpage_fault_can_be_faststructkvmkvmstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "set_spteButfast_page_fault",
      "signature": "set_spteButfast_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticintfast_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "staticintfast_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "ifpage_fault_can_be_fast",
      "signature": "ifpage_fault_can_be_fast",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "trace_fast_page_fault",
      "signature": "trace_fast_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticinthandle_mmio_page_fault",
      "signature": "staticinthandle_mmio_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "trace_handle_mmio_page_fault",
      "signature": "trace_handle_mmio_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticboolpage_fault_handle_page_track",
      "signature": "staticboolpage_fault_handle_page_track",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "rkvm_mmu_do_page_fault",
      "signature": "rkvm_mmu_do_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticvoidkvm_mmu_finish_page_fault",
      "signature": "staticvoidkvm_mmu_finish_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "changeinattributesis_page_fault_stale",
      "signature": "changeinattributesis_page_fault_stale",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticboolis_page_fault_stale",
      "signature": "staticboolis_page_fault_stale",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticintdirect_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "staticintdirect_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "ifpage_fault_handle_page_track",
      "signature": "ifpage_fault_handle_page_track",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "rfast_page_fault",
      "signature": "rfast_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "ifis_page_fault_stale",
      "signature": "ifis_page_fault_stale",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticintnonpaging_page_fault",
      "signature": "staticintnonpaging_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "returndirect_page_fault",
      "signature": "returndirect_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "intkvm_handle_page_fault",
      "signature": "intkvm_handle_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "trace_kvm_page_fault",
      "signature": "trace_kvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "rkvm_mmu_page_fault",
      "signature": "rkvm_mmu_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "EXPORT_SYMBOL_FOR_KVM_INTERNALkvm_handle_page_fault",
      "signature": "EXPORT_SYMBOL_FOR_KVM_INTERNALkvm_handle_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticintkvm_tdp_mmu_page_fault",
      "signature": "staticintkvm_tdp_mmu_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "intkvm_tdp_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "intkvm_tdp_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "returnkvm_tdp_mmu_page_fault",
      "signature": "returnkvm_tdp_mmu_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "ifvcpuarchmmupage_faultkvm_tdp_page_fault",
      "signature": "ifvcpuarchmmupage_faultkvm_tdp_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "contextpage_faultnonpaging_page_fault",
      "signature": "contextpage_faultnonpaging_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "contextpage_faultpaging64_page_fault",
      "signature": "contextpage_faultpaging64_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "contextpage_faultpaging32_page_fault",
      "signature": "contextpage_faultpaging32_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "contextpage_faultkvm_tdp_page_fault",
      "signature": "contextpage_faultkvm_tdp_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "contextinject_page_faultkvm_inject_page_fault",
      "signature": "contextinject_page_faultkvm_inject_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "contextpage_faultept_page_fault",
      "signature": "contextpage_faultept_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "g_contextinject_page_faultkvm_inject_page_fault",
      "signature": "g_contextinject_page_faultkvm_inject_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "intnoinlinekvm_mmu_page_fault",
      "signature": "intnoinlinekvm_mmu_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "rhandle_mmio_page_fault",
      "signature": "rhandle_mmio_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "Noneofhandle_mmio_page_faultkvm_mmu_do_page_fault",
      "signature": "Noneofhandle_mmio_page_faultkvm_mmu_do_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "EXPORT_SYMBOL_FOR_KVM_INTERNALkvm_mmu_page_fault",
      "signature": "EXPORT_SYMBOL_FOR_KVM_INTERNALkvm_mmu_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "smp_store_mbvcpumodeREADING_SHADOW_PAGE_TABLES",
      "signature": "smp_store_mbvcpumodeREADING_SHADOW_PAGE_TABLES",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticunsignedkvm_page_table_hashfn",
      "signature": "staticunsignedkvm_page_table_hashfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "returnpage_hashkvm_page_table_hashfn",
      "signature": "returnpage_hashkvm_page_table_hashfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "sp_listkvmarchmmu_page_hashkvm_page_table_hashfn",
      "signature": "sp_listkvmarchmmu_page_hashkvm_page_table_hashfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticvoidshadow_page_table_clear_flood",
      "signature": "staticvoidshadow_page_table_clear_flood",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "staticboolis_write_to_guest_page_table",
      "signature": "staticboolis_write_to_guest_page_table",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "ifdirectis_write_to_guest_page_table",
      "signature": "ifdirectis_write_to_guest_page_table",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_iter.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_as_id",
      "signature": "kvm_mmu_page_as_id",
      "file": "arch/x86/kvm/mmu/tdp_iter.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGES_PER_HPAGE",
      "signature": "KVM_PAGES_PER_HPAGE",
      "file": "arch/x86/kvm/mmu/tdp_iter.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_is_dummy_roothpa_tshadow_page",
      "signature": "kvm_mmu_is_dummy_roothpa_tshadow_page",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_role",
      "signature": "kvm_mmu_page_role",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_role_as_idunionkvm_mmu_page_role",
      "signature": "kvm_mmu_role_as_idunionkvm_mmu_page_role",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_as_idstructkvm_mmu_page",
      "signature": "kvm_mmu_page_as_idstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_alloc_external_sptstructkvm_vcpuvcpustructkvm_mmu_page",
      "signature": "kvm_mmu_alloc_external_sptstructkvm_vcpuvcpustructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gfn_root_bitsconststructkvmkvmconststructkvm_mmu_page",
      "signature": "kvm_gfn_root_bitsconststructkvmkvmconststructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "bool kvm_mmu_page_ad_need_write_protect(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGES_PER_HPAGE",
      "signature": "KVM_PAGES_PER_HPAGE",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gfn_disallow_lpage",
      "signature": "void kvm_mmu_gfn_disallow_lpage(const struct kvm_memory_slot *slot, gfn_t gfn); void kvm_mmu_gfn_allow_lpage(const struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm, struct kvm_memory_slot *slot, u64 gfn, int min_level); /* Flush the given page (huge or not) of guest memory. */ static inline void kvm_flush_remote_tlbs_gfn(struct kvm *kvm, gfn_t gfn, int level)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gfn_allow_lpage",
      "signature": "void kvm_mmu_gfn_allow_lpage(const struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm, struct kvm_memory_slot *slot, u64 gfn, int min_level); /* Flush the given page (huge or not) of guest memory. */ static inline void kvm_flush_remote_tlbs_gfn(struct kvm *kvm, gfn_t gfn, int level)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_do_page_fault",
      "signature": "course kvm_mmu_do_page_fault(). * * RET_PF_CONTINUE: So far, so good, keep handling the page fault. * RET_PF_RETRY: let CPU fault again on the address. * RET_PF_EMULATE: mmio page fault, emulate the instruction directly. * RET_PF_WRITE_PROTECTED: the gfn is write-protected, either unprotected the * gfn and retry, or emulate the instruction directly. * RET_PF_INVALID: the spte is invalid, let the real page fault path update it. * RET_PF_FIXED: The faulting entry has been fixed. * RET_PF_SPURIOUS: The faulting entry was already fixed, e.g. by another vCPU. * * Any names added to this enum should be exported to userspace for use in * tracepoints via TRACE_DEFINE_ENUM()",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_tdp_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_prepare_memory_fault_exitvcpufaultgfnPAGE_SHIFT",
      "signature": "kvm_prepare_memory_fault_exitvcpufaultgfnPAGE_SHIFT",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_page_fault",
      "signature": "int kvm_tdp_page_fault(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault); /* * Return values of handle_mmio_page_fault(), mmu.page_fault(), fast_page_fault(), * and of course kvm_mmu_do_page_fault(). * * RET_PF_CONTINUE: So far, so good, keep handling the page fault. * RET_PF_RETRY: let CPU fault again on the address. * RET_PF_EMULATE: mmio page fault, emulate the instruction directly. * RET_PF_WRITE_PROTECTED: the gfn is write-protected, either unprotected the * gfn and retry, or emulate the instruction directly. * RET_PF_INVALID: the spte is invalid, let the real page fault path update it. * RET_PF_FIXED: The faulting entry has been fixed. * RET_PF_SPURIOUS: The faulting entry was already fixed, e.g. by another vCPU. * * Any names added to this enum should be exported to userspace for use in * tracepoints via TRACE_DEFINE_ENUM()",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MAX_HUGEPAGE_LEVEL",
      "signature": "KVM_MAX_HUGEPAGE_LEVEL",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "signature": "kvm_mmu_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_hugepage_adjuststructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_mmu_hugepage_adjuststructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_faultin_pfn",
      "signature": "of kvm_mmu_faultin_pfn(). */ unsigned long mmu_seq; kvm_pfn_t pfn; struct page *refcounted_page; bool map_writable; /* * Indicates the guest is trying to write a gfn that contains one or * more of the PTEs used to translate the write itself, i.e. the access * is changing its own translation in the guest page tables. */ bool write_fault_to_shadow_pgtable; }; int kvm_tdp_page_fault(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault); /* * Return values of handle_mmio_page_fault(), mmu.page_fault(), fast_page_fault(), * and of course kvm_mmu_do_page_fault(). * * RET_PF_CONTINUE: So far, so good, keep handling the page fault. * RET_PF_RETRY: let CPU fault again on the address. * RET_PF_EMULATE: mmio page fault, emulate the instruction directly. * RET_PF_WRITE_PROTECTED: the gfn is write-protected, either unprotected the * gfn and retry, or emulate the instruction directly. * RET_PF_INVALID: the spte is invalid, let the real page fault path update it. * RET_PF_FIXED: The faulting entry has been fixed. * RET_PF_SPURIOUS: The faulting entry was already fixed, e.g. by another vCPU. * * Any names added to this enum should be exported to userspace for use in * tracepoints via TRACE_DEFINE_ENUM()",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_FAULT",
      "signature": "KVM_PFN_ERR_FAULT",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_WARN_ON",
      "signature": "define KVM_MMU_WARN_ON(x) WARN_ON_ONCE(x) #else #define KVM_MMU_WARN_ON(x) BUILD_BUG_ON_INVALID(x) #endif /* Page table builder macros common to shadow (host) PTEs and guest PTEs. */ #define __PT_BASE_ADDR_MASK GENMASK_ULL(51, 12) #define __PT_LEVEL_SHIFT(level, bits_per_level) \\ (PAGE_SHIFT + ((level) - 1) * (bits_per_level)) #define __PT_INDEX(address, level, bits_per_level) \\ (((address) >> __PT_LEVEL_SHIFT(level, bits_per_level)) & ((1 << (bits_per_level)) - 1)) #define __PT_LVL_ADDR_MASK(base_addr_mask, level, bits_per_level) \\ ((base_addr_mask) & ~((1ULL << (PAGE_SHIFT + (((level) - 1) * (bits_per_level)))) - 1)) #define __PT_LVL_OFFSET_MASK(base_addr_mask, level, bits_per_level) \\ ((base_addr_mask) & ((1ULL << (PAGE_SHIFT + (((level) - 1) * (bits_per_level)))) - 1)) #define __PT_ENT_PER_PAGE(bits_per_level) (1 << (bits_per_level)) /* * Unlike regular MMU roots, PAE \"roots\", a.k.a. PDPTEs/PDPTRs, have a PRESENT * bit, and thus are guaranteed to be non-zero when valid. And, when a guest * PDPTR is !PRESENT, its corresponding PAE root cannot be set to INVALID_PAGE, * as the CPU would treat that as PRESENT PDPTR with reserved bits set. Use * '0' instead of INVALID_PAGE to indicate an invalid PAE root. */ #define INVALID_PAE_ROOT 0 #define IS_VALID_PAE_ROOT(x) (!!(x)) static inline hpa_t kvm_mmu_get_dummy_root(void)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_dummy_root",
      "signature": "hpa_t kvm_mmu_get_dummy_root(void)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_is_dummy_root",
      "signature": "bool kvm_mmu_is_dummy_root(hpa_t shadow_page)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_role_as_id",
      "signature": "int kvm_mmu_role_as_id(union kvm_mmu_page_role role)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_as_id",
      "signature": "int kvm_mmu_page_as_id(struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_alloc_external_spt",
      "signature": "void kvm_mmu_alloc_external_spt(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_alloc",
      "signature": "kvm_mmu_memory_cache_alloc",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm, struct kvm_memory_slot *slot, u64 gfn, int min_level); /* Flush the given page (huge or not) of guest memory. */ static inline void kvm_flush_remote_tlbs_gfn(struct kvm *kvm, gfn_t gfn, int level)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_prepare_memory_fault_exit",
      "signature": "void kvm_mmu_prepare_memory_fault_exit(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_mapping_level",
      "signature": "int kvm_mmu_max_mapping_level(struct kvm *kvm, struct kvm_page_fault *fault, const struct kvm_memory_slot *slot, gfn_t gfn); void kvm_mmu_hugepage_adjust(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault); void disallowed_hugepage_adjust(struct kvm_page_fault *fault, u64 spte, int cur_level); void track_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp, enum kvm_mmu_type mmu_type); void untrack_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp, enum kvm_mmu_type mmu_type)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_hugepage_adjust",
      "signature": "void kvm_mmu_hugepage_adjust(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault); void disallowed_hugepage_adjust(struct kvm_page_fault *fault, u64 spte, int cur_level); void track_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp, enum kvm_mmu_type mmu_type); void untrack_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp, enum kvm_mmu_type mmu_type)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_type",
      "signature": "kvm_mmu_type",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "structkvm_page_fault",
      "signature": "structkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "argumentstokvm_mmu_do_page_fault",
      "signature": "argumentstokvm_mmu_do_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "intkvm_tdp_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "intkvm_tdp_page_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "Returnvaluesofhandle_mmio_page_faultmmupage_faultfast_page_fault",
      "signature": "Returnvaluesofhandle_mmio_page_faultmmupage_faultfast_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "andofcoursekvm_mmu_do_page_fault",
      "signature": "andofcoursekvm_mmu_do_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "staticinlineintkvm_mmu_do_page_fault",
      "signature": "staticinlineintkvm_mmu_do_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "is_tdplikelyvcpuarchmmupage_faultkvm_tdp_page_fault",
      "signature": "is_tdplikelyvcpuarchmmupage_faultkvm_tdp_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "rkvm_tdp_page_fault",
      "signature": "rkvm_tdp_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "rvcpuarchmmupage_fault",
      "signature": "rvcpuarchmmupage_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "intkvm_mmu_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "signature": "intkvm_mmu_max_mapping_levelstructkvmkvmstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "voidkvm_mmu_hugepage_adjuststructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "voidkvm_mmu_hugepage_adjuststructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "voiddisallowed_hugepage_adjuststructkvm_page_fault",
      "signature": "voiddisallowed_hugepage_adjuststructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_PAGE_FIELDS",
      "signature": "KVM_MMU_PAGE_FIELDS",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_PAGE_ASSIGN",
      "signature": "define KVM_MMU_PAGE_ASSIGN(sp) \\ __entry->mmu_valid_gen = sp->mmu_valid_gen; \\ __entry->gfn = sp->gfn; \\ __entry->role = sp->role.word; \\ __entry->root_count = sp->root_count; \\ __entry->unsync = sp->unsync; #define KVM_MMU_PAGE_PRINTK()",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_PAGE_PRINTK",
      "signature": "define KVM_MMU_PAGE_PRINTK()",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_role",
      "signature": "kvm_mmu_page_role",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagetable_walk",
      "signature": "kvm_mmu_pagetable_walk",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_page",
      "signature": "kvm_mmu_get_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_class",
      "signature": "kvm_mmu_page_class",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_classkvm_mmu_sync_page",
      "signature": "kvm_mmu_page_classkvm_mmu_sync_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_classkvm_mmu_unsync_page",
      "signature": "kvm_mmu_page_classkvm_mmu_unsync_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_classkvm_mmu_prepare_zap_page",
      "signature": "kvm_mmu_page_classkvm_mmu_prepare_zap_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGES_PER_HPAGE",
      "signature": "KVM_PAGES_PER_HPAGE",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_split_huge_page",
      "signature": "kvm_mmu_split_huge_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_trace_pferr_flags",
      "signature": "kvm_mmu_trace_pferr_flags",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_paging_element",
      "signature": "kvm_mmu_paging_element",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_bit_class",
      "signature": "kvm_mmu_set_bit_class",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_accessed_bit",
      "signature": "kvm_mmu_set_accessed_bit",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_dirty_bit",
      "signature": "kvm_mmu_set_dirty_bit",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_walker_error",
      "signature": "kvm_mmu_walker_error",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_sync_page",
      "signature": "kvm_mmu_sync_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unsync_page",
      "signature": "kvm_mmu_unsync_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_prepare_zap_page",
      "signature": "kvm_mmu_prepare_zap_page",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_zap_all_fast",
      "signature": "kvm_mmu_zap_all_fast",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_spte",
      "signature": "kvm_mmu_set_spte",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_spte_requested",
      "signature": "kvm_mmu_spte_requested",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "handle_mmio_page_fault",
      "signature": "handle_mmio_page_fault",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "fast_page_fault",
      "signature": "fast_page_fault",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "TP_PROTOstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "TP_PROTOstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "TP_PROTOstructkvm_page_fault",
      "signature": "TP_PROTOstructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpuvcpustructkvm_mmu_page",
      "signature": "kvm_vcpuvcpustructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "kvm_mmu_page_ad_need_write_protect",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_hugepage_adjust",
      "signature": "kvm_mmu_hugepage_adjust",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_role",
      "signature": "kvm_mmu_page_role",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGES_PER_HPAGErolelevelPAGE_SHIFT",
      "signature": "KVM_PAGES_PER_HPAGErolelevelPAGE_SHIFT",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_HPAGE_MASKlevelPAGE_MASK",
      "signature": "KVM_HPAGE_MASKlevelPAGE_MASK",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_is_mmio_pfnkvm_pfn_tpfn",
      "signature": "kvm_is_mmio_pfnkvm_pfn_tpfn",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_is_mmio_pfnpfn",
      "signature": "kvm_is_mmio_pfnpfn",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_spte_module_init",
      "signature": "__init kvm_mmu_spte_module_init(void)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_WARN_ON",
      "signature": "KVM_MMU_WARN_ON",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_mask",
      "signature": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_value, u64 mmio_mask, u64 access_mask)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_value",
      "signature": "void kvm_mmu_set_mmio_spte_value(struct kvm *kvm, u64 mmio_value)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_me_spte_mask",
      "signature": "void kvm_mmu_set_me_spte_mask(u64 me_value, u64 me_mask)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_ept_masks",
      "signature": "void kvm_mmu_set_ept_masks(bool has_ad_bits, bool has_exec_only)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reset_all_pte_masks",
      "signature": "void kvm_mmu_reset_all_pte_masks(void)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_get_rootstructkvm_mmu_page",
      "signature": "kvm_tdp_mmu_get_rootstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_put_rootstructkvmkvmstructkvm_mmu_page",
      "signature": "kvm_tdp_mmu_put_rootstructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_zap_possible_nx_huge_page",
      "signature": "bool kvm_tdp_mmu_zap_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp); void kvm_tdp_mmu_zap_all(struct kvm *kvm); void kvm_tdp_mmu_invalidate_roots(struct kvm *kvm, enum kvm_tdp_mmu_root_types root_types); void kvm_tdp_mmu_zap_invalidated_roots(struct kvm *kvm, bool shared); int kvm_tdp_mmu_map(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault); bool kvm_tdp_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range, bool flush); bool kvm_tdp_mmu_age_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); bool kvm_tdp_mmu_test_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range); bool kvm_tdp_mmu_wrprot_slot(struct kvm *kvm, const struct kvm_memory_slot *slot, int min_level); void kvm_tdp_mmu_clear_dirty_slot(struct kvm *kvm, const struct kvm_memory_slot *slot); void kvm_tdp_mmu_clear_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, unsigned long mask, bool wrprot); void kvm_tdp_mmu_recover_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot); bool kvm_tdp_mmu_write_protect_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, int min_level); void kvm_tdp_mmu_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t start, gfn_t end, int target_level, bool shared); static inline void kvm_tdp_mmu_walk_lockless_begin(void)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_tdp_mmu_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_recover_huge_pages",
      "signature": "void kvm_tdp_mmu_recover_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot); bool kvm_tdp_mmu_write_protect_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, int min_level); void kvm_tdp_mmu_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t start, gfn_t end, int target_level, bool shared); static inline void kvm_tdp_mmu_walk_lockless_begin(void)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_try_split_huge_pages",
      "signature": "void kvm_tdp_mmu_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t start, gfn_t end, int target_level, bool shared); static inline void kvm_tdp_mmu_walk_lockless_begin(void)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagespreturnsptdp_mmu_page",
      "signature": "kvm_mmu_pagespreturnsptdp_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "get_rootstructkvm_mmu_page",
      "signature": "get_rootstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "put_rootstructkvmkvmstructkvm_mmu_page",
      "signature": "put_rootstructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_init_tdp_mmu",
      "signature": "void kvm_mmu_init_tdp_mmu(struct kvm *kvm); void kvm_mmu_uninit_tdp_mmu(struct kvm *kvm); void kvm_tdp_mmu_alloc_root(struct kvm_vcpu *vcpu, bool private); __must_check static inline bool kvm_tdp_mmu_get_root(struct kvm_mmu_page *root)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_uninit_tdp_mmu",
      "signature": "void kvm_mmu_uninit_tdp_mmu(struct kvm *kvm); void kvm_tdp_mmu_alloc_root(struct kvm_vcpu *vcpu, bool private); __must_check static inline bool kvm_tdp_mmu_get_root(struct kvm_mmu_page *root)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "structkvm_page_fault",
      "signature": "structkvm_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "intkvm_tdp_mmu_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "intkvm_tdp_mmu_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_X86_PAGE_TRACK_H",
      "signature": "KVM_X86_PAGE_TRACK_H",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track",
      "signature": "kvm_page_track",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "bool kvm_page_track_write_tracking_enabled(struct kvm *kvm); int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot); void kvm_page_track_free_memslot(struct kvm_memory_slot *slot); int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages); void __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); void __kvm_write_track_remove_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot); void kvm_page_track_free_memslot(struct kvm_memory_slot *slot); int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages); void __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); void __kvm_write_track_remove_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_free_memslot",
      "signature": "void kvm_page_track_free_memslot(struct kvm_memory_slot *slot); int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages); void __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); void __kvm_write_track_remove_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_create_memslot",
      "signature": "int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages); void __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); void __kvm_write_track_remove_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_init",
      "signature": "int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_cleanup",
      "signature": "void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "void kvm_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_delete_slot",
      "signature": "void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_track_has_external_user",
      "signature": "bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "kvm_mmu_track_write",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_WARN_ONatomic64_readkvmarchtdp_mmu_pages",
      "signature": "KVM_MMU_WARN_ONatomic64_readkvmarchtdp_mmu_pages",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagespcontainer_ofheadstructkvm_mmu_page",
      "signature": "kvm_mmu_pagespcontainer_ofheadstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_put_rootstructkvmkvmstructkvm_mmu_page",
      "signature": "kvm_tdp_mmu_put_rootstructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_BUG_ONis_tdp_mmu_page",
      "signature": "KVM_BUG_ONis_tdp_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_as_id",
      "signature": "kvm_mmu_page_as_id",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_allocvcpuarchmmu_page_header_cache",
      "signature": "kvm_mmu_memory_cache_allocvcpuarchmmu_page_header_cache",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_allocvcpuarchmmu_shadow_page_cache",
      "signature": "kvm_mmu_memory_cache_allocvcpuarchmmu_shadow_page_cache",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_role",
      "signature": "kvm_mmu_page_role",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_page",
      "signature": "kvm_mmu_get_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_account_pgtable_pages",
      "signature": "kvm_account_pgtable_pages",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_prepare_zap_page",
      "signature": "kvm_mmu_prepare_zap_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PAGES_PER_HPAGE",
      "signature": "i * KVM_PAGES_PER_HPAGE(level); u64 old_spte; if (shared)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_update_page_stats",
      "signature": "kvm_update_page_stats",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_zap_possible_nx_huge_page",
      "signature": "bool kvm_tdp_mmu_zap_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_tdp_mmu_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_hugepage_adjust",
      "signature": "kvm_mmu_hugepage_adjust",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MAX_HUGEPAGE_LEVEL",
      "signature": "KVM_MAX_HUGEPAGE_LEVEL",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_update_page_statskvmlevel1SPTE_ENT_PER_PAGE",
      "signature": "kvm_update_page_statskvmlevel1SPTE_ENT_PER_PAGE",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_split_huge_page",
      "signature": "kvm_mmu_split_huge_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_try_split_huge_pages",
      "signature": "void kvm_tdp_mmu_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t start, gfn_t end, int target_level, bool shared)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "return kvm_mmu_page_ad_need_write_protect(kvm, sp) || !kvm_ad_enabled; } static void clear_dirty_gfn_range(struct kvm *kvm, struct kvm_mmu_page *root, gfn_t start, gfn_t end)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_mmu_recover_huge_pages",
      "signature": "void kvm_tdp_mmu_recover_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_told_pfnspte_to_pfn",
      "signature": "kvm_pfn_told_pfnspte_to_pfn",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_callremove_external_sptekvmgfnlevelold_pfn",
      "signature": "kvm_x86_callremove_external_sptekvmgfnlevelold_pfn",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tnew_pfnspte_to_pfn",
      "signature": "kvm_pfn_tnew_pfnspte_to_pfn",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_x86_callset_external_sptekvmgfnlevelnew_pfn",
      "signature": "kvm_x86_callset_external_sptekvmgfnlevelnew_pfn",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "get_zeroed_page",
      "signature": "get_zeroed_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "put_rootstructkvmkvmstructkvm_mmu_page",
      "signature": "put_rootstructkvmkvmstructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_init_tdp_mmu",
      "signature": "void kvm_mmu_init_tdp_mmu(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_uninit_tdp_mmu",
      "signature": "void kvm_mmu_uninit_tdp_mmu(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_WARN_ON",
      "signature": "CONFIG_KVM_PROVE_MMU KVM_MMU_WARN_ON(atomic64_read(&kvm->arch.tdp_mmu_pages)); #endif WARN_ON(!list_empty(&kvm->arch.tdp_mmu_roots)); /* * Ensure that all the outstanding RCU callbacks to free shadow pages * can run before the VM is torn down. Putting the last reference to * zapped roots will create new callbacks. */ rcu_barrier(); } static void tdp_mmu_free_sp(struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_alloc",
      "signature": "kvm_mmu_memory_cache_alloc",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_role_as_id",
      "signature": "kvm_mmu_role_as_id",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_gfn",
      "signature": "return kvm_mmu_max_gfn() + 1; } static void __tdp_mmu_zap_root(struct kvm *kvm, struct kvm_mmu_page *root, bool shared, int zap_level)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_load",
      "signature": "see kvm_mmu_load()), and * when migrating a vCPU to a different pCPU. Note, the local * TLB flush on reuse also invalidates paging-structure-cache * entries, i.e. TLB entries for intermediate paging structures, * that may be zapped, as such entries are associated with the * ASID on both VMX and SVM. */ tdp_mmu_zap_root(kvm, root, shared); /* * The referenced needs to be put *after* zapping the root, as * the root must be reachable by mmu_notifiers while it's being * zapped */ kvm_tdp_mmu_put_root(kvm, root); } if (shared) read_unlock(&kvm->mmu_lock); else write_unlock(&kvm->mmu_lock); } /* * Mark each TDP MMU root as invalid to prevent vCPUs from reusing a root that * is about to be zapped, e.g. in response to a memslots update. The actual * zapping is done separately so that it happens with mmu_lock with read, * whereas invalidating roots must be done with mmu_lock held for write (unless * the VM is being destroyed). * * Note, kvm_tdp_mmu_zap_invalidated_roots() is gifted the TDP MMU's reference. * See kvm_tdp_mmu_alloc_root(). */ void kvm_tdp_mmu_invalidate_roots(struct kvm *kvm, enum kvm_tdp_mmu_root_types root_types)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_spte",
      "signature": "kvm_mmu_set_spte",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_spte_requested",
      "signature": "kvm_mmu_spte_requested",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_alloc_external_spt",
      "signature": "kvm_mmu_alloc_external_spt",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_max_mapping_level",
      "signature": "kvm_mmu_max_mapping_level",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "structkvm_page_fault",
      "signature": "structkvm_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "intkvm_tdp_mmu_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "intkvm_tdp_mmu_mapstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "WARNINGThisfunctionisonlyintendedtobecalledduringfast_page_fault",
      "signature": "WARNINGThisfunctionisonlyintendedtobecalledduringfast_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "wearepassingituptofast_page_fault",
      "signature": "wearepassingituptofast_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "Thisissafesincefast_page_fault",
      "signature": "Thisissafesincefast_page_fault",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page",
      "signature": "kvm_mmu_page",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mark_page_dirty",
      "signature": "kvm_vcpu_mark_page_dirty",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_pagetable_walk",
      "signature": "kvm_mmu_pagetable_walk",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpuvcpustructkvm_mmu_page",
      "signature": "kvm_vcpuvcpustructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpuvcpustructkvm_page_fault",
      "signature": "kvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_find_shadow_page",
      "signature": "kvm_mmu_find_shadow_page",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_sync_page",
      "signature": "via kvm_sync_page(). * * For higher level pages, which cannot be unsync themselves * but can have unsync children, synchronize via the slower * mmu_sync_children(). If KVM needs to drop mmu_lock due to * contention or to reschedule, instruct the caller to retry * the #PF (mmu_sync_children() ensures forward progress will * be made). */ if (sp != ERR_PTR(-EEXIST) && sp->unsync_children && mmu_sync_children(vcpu, sp, false)) return RET_PF_RETRY; /* * Verify that the gpte in the page, which is now either * write-protected or unsync, wasn't modified between the fault * and acquiring mmu_lock. This needs to be done even when * reusing an existing shadow page to ensure the information * gathered by the walker matches the information stored in the * shadow page (which could have been modified by a different * vCPU even if the page was already linked). Holding mmu_lock * prevents the shadow page from changing after this point. */ if (FNAME(gpte_changed)(vcpu, gw, it.level - 1)) return RET_PF_RETRY; if (sp != ERR_PTR(-EEXIST)) link_shadow_page(vcpu, it.sptep, sp); if (fault->write && table_gfn == fault->gfn) fault->write_fault_to_shadow_pgtable = true; } /* * Adjust the hugepage size _after_ resolving indirect shadow pages. * KVM doesn't support mapping hugepages into the guest for gfns that * are being shadowed by KVM, i.e. allocating a new shadow page may * affect the allowed hugepage size. */ kvm_mmu_hugepage_adjust(vcpu, fault); trace_kvm_mmu_spte_requested(fault); for (; shadow_walk_okay(&it); shadow_walk_next(&it))",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_hugepage_adjust",
      "signature": "kvm_mmu_hugepage_adjust",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_inject_emulated_page_fault",
      "signature": "kvm_inject_emulated_page_fault",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_finish_page_fault",
      "signature": "kvm_mmu_finish_page_fault",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_get_gfn",
      "signature": "kvm_mmu_page_get_gfn",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_get_access",
      "signature": "kvm_mmu_page_get_access",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_set_access",
      "signature": "kvm_mmu_page_set_access",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_faultin_pfn",
      "signature": "kvm_mmu_faultin_pfn",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "get_level1_sp_gpastructkvm_mmu_page",
      "signature": "get_level1_sp_gpastructkvm_mmu_page",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_accessed_bit",
      "signature": "kvm_mmu_set_accessed_bit",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_dirty_bit",
      "signature": "kvm_mmu_set_dirty_bit",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_guest_pgd",
      "signature": "kvm_mmu_get_guest_pgd",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_paging_element",
      "signature": "kvm_mmu_paging_element",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_walker_error",
      "signature": "kvm_mmu_walker_error",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_prefetch_sptes",
      "signature": "return kvm_mmu_prefetch_sptes(vcpu, gfn, spte, 1, pte_access); } static bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu, struct guest_walker *gw, int level)",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_is_dummy_root",
      "signature": "kvm_mmu_is_dummy_root",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_get_child_sp",
      "signature": "kvm_mmu_get_child_sp",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_spte_requested",
      "signature": "kvm_mmu_spte_requested",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "walkerfaultnested_page_fault",
      "signature": "walkerfaultnested_page_fault",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "walkerfaultasync_page_fault",
      "signature": "walkerfaultasync_page_fault",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "staticintFNAMEfetchstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "staticintFNAMEfetchstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "staticintFNAMEpage_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "signature": "staticintFNAMEpage_faultstructkvm_vcpuvcpustructkvm_page_fault",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "ifpage_fault_handle_page_track",
      "signature": "ifpage_fault_handle_page_track",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "ifis_page_fault_stale",
      "signature": "ifis_page_fault_stale",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "shadow_page_table_clear_flood",
      "signature": "shadow_page_table_clear_flood",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "page_operations"
    },
    {
      "function": "get_vp_assist_page",
      "signature": "get_vp_assist_page",
      "file": "arch/x86/kvm/vmx/vmx_onhyperv.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_inject_emulated_page_fault",
      "signature": "kvm_inject_emulated_page_fault",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_rbx_readvcpu3232pageinfo_gva",
      "signature": "kvm_rbx_readvcpu3232pageinfo_gva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_read_guest_virtvcpupageinfo_gvapageinfo",
      "signature": "kvm_read_guest_virtvcpupageinfo_gvapageinfo",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_gfn_to_hvavcpuPFN_DOWN",
      "signature": "kvm_vcpu_gfn_to_hvavcpuPFN_DOWN",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "page_operations"
    },
    {
      "function": "get_free_page",
      "signature": "get_free_page",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "kvm_mmu_gva_to_gpa_write",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_read",
      "signature": "kvm_mmu_gva_to_gpa_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "page_operations"
    },
    {
      "function": "exnested_page_fault",
      "signature": "exnested_page_fault",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdcs_pages",
      "signature": "kvm_tdxtdtdcs_pages",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdcs_nr_pages",
      "signature": "kvm_tdxtdtdcs_nr_pages",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdr_page",
      "signature": "kvm_tdxtdtdr_page",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdcx_nr_pages",
      "signature": "kvm_tdxtdtdcx_nr_pages",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdgpatdx_levelpage",
      "signature": "kvm_tdxtdgpatdx_levelpage",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_TDX_INIT_MEM_REGIONcallskvm_gmem_populatetomapguestpages",
      "signature": "KVM_TDX_INIT_MEM_REGIONcallskvm_gmem_populatetomapguestpages",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_map_pagenr_premappedcountsthenumberofpages",
      "signature": "kvm_tdp_map_pagenr_premappedcountsthenumberofpages",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxhkidpage",
      "signature": "kvm_tdxhkidpage",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxkvmtdgpatdx_levelpage",
      "signature": "kvm_tdxkvmtdgpatdx_levelpage",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_TDX_INIT_MEM_REGIONwithouttdh_mem_page_add",
      "signature": "KVM_TDX_INIT_MEM_REGIONwithouttdh_mem_page_add",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_HPAGE_MASK",
      "signature": "KVM_HPAGE_MASK",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdcs_nr_pagestdx_sysinfotd_ctrltdcs_base_sizePAGE_SIZE",
      "signature": "kvm_tdxtdtdcs_nr_pagestdx_sysinfotd_ctrltdcs_base_sizePAGE_SIZE",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdcx_nr_pagestdx_sysinfotd_ctrltdvps_base_sizePAGE_SIZE",
      "signature": "kvm_tdxtdtdcx_nr_pagestdx_sysinfotd_ctrltdvps_base_sizePAGE_SIZE",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdcs_nr_pagessizeofkvm_tdxtdtdcs_pages",
      "signature": "kvm_tdxtdtdcs_nr_pagessizeofkvm_tdxtdtdcs_pages",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdr_pagetdr_page",
      "signature": "kvm_tdxtdtdr_pagetdr_page",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdcs_pagestdcs_pages",
      "signature": "kvm_tdxtdtdcs_pagestdcs_pages",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdtdcx_nr_pagessizeoftdxvptdcx_pages",
      "signature": "kvm_tdxtdtdcx_nr_pagessizeoftdxvptdcx_pages",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdp_map_page",
      "signature": "via kvm_tdp_map_page(). nr_premapped counts the number of pages that * were added to the EPT structures but not added with TDH.MEM.PAGE.ADD(). * The counter has to be zero on KVM_TDX_FINALIZE_VM, to ensure that there * are no half-initialized shared EPT pages. */ static int tdx_mem_page_record_premap_cnt(struct kvm *kvm, gfn_t gfn, enum pg_level level, kvm_pfn_t pfn)",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdgpapfn_to_page",
      "signature": "kvm_tdxtdgpapfn_to_page",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_tdxtdgpapfn_to_pagepfn",
      "signature": "kvm_tdxtdgpapfn_to_pagepfn",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "get_pageput_page",
      "signature": "get_pageput_page",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "get_user_pages_fastunsignedlongsrc10src_page",
      "signature": "get_user_pages_fastunsignedlongsrc10src_page",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "put_pagesrc_page",
      "signature": "put_pagesrc_page",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_value",
      "signature": "kvm_mmu_set_mmio_spte_value",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reload",
      "signature": "kvm_mmu_reload",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "trace_kvm_page_fault",
      "signature": "trace_kvm_page_fault",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "page_operations"
    },
    {
      "function": "EVMCS1_FIELDPAGE_FAULT_ERROR_CODE_MASKpage_fault_error_code_mask",
      "signature": "EVMCS1_FIELDPAGE_FAULT_ERROR_CODE_MASKpage_fault_error_code_mask",
      "file": "arch/x86/kvm/vmx/hyperv_evmcs.c",
      "category": "page_operations"
    },
    {
      "function": "EVMCS1_FIELDPAGE_FAULT_ERROR_CODE_MATCHpage_fault_error_code_match",
      "signature": "EVMCS1_FIELDPAGE_FAULT_ERROR_CODE_MATCHpage_fault_error_code_match",
      "file": "arch/x86/kvm/vmx/hyperv_evmcs.c",
      "category": "page_operations"
    },
    {
      "function": "FIELDPAGE_FAULT_ERROR_CODE_MASKpage_fault_error_code_mask",
      "signature": "FIELDPAGE_FAULT_ERROR_CODE_MASKpage_fault_error_code_mask",
      "file": "arch/x86/kvm/vmx/vmcs12.c",
      "category": "page_operations"
    },
    {
      "function": "FIELDPAGE_FAULT_ERROR_CODE_MATCHpage_fault_error_code_match",
      "signature": "FIELDPAGE_FAULT_ERROR_CODE_MATCHpage_fault_error_code_match",
      "file": "arch/x86/kvm/vmx/vmcs12.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_fault",
      "signature": "return kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0); } static inline void kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu, int pi_vec)",
      "file": "arch/x86/kvm/vmx/common.h",
      "category": "page_operations"
    },
    {
      "function": "returnkvm_mmu_page_fault",
      "signature": "returnkvm_mmu_page_fault",
      "file": "arch/x86/kvm/vmx/common.h",
      "category": "page_operations"
    },
    {
      "function": "u32page_fault_error_code_mask",
      "signature": "u32page_fault_error_code_mask",
      "file": "arch/x86/kvm/vmx/vmcs12.h",
      "category": "page_operations"
    },
    {
      "function": "u32page_fault_error_code_match",
      "signature": "u32page_fault_error_code_match",
      "file": "arch/x86/kvm/vmx/vmcs12.h",
      "category": "page_operations"
    },
    {
      "function": "CHECK_OFFSETpage_fault_error_code_mask",
      "signature": "CHECK_OFFSETpage_fault_error_code_mask",
      "file": "arch/x86/kvm/vmx/vmcs12.h",
      "category": "page_operations"
    },
    {
      "function": "CHECK_OFFSETpage_fault_error_code_match",
      "signature": "CHECK_OFFSETpage_fault_error_code_match",
      "file": "arch/x86/kvm/vmx/vmcs12.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/vmx/x86_ops.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_host_mapapic_access_page_map",
      "signature": "kvm_host_mapapic_access_page_map",
      "file": "arch/x86/kvm/vmx/vmx.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_is_using_evmcshv_get_vp_assist_page",
      "signature": "kvm_is_using_evmcshv_get_vp_assist_page",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vmxept_identity_pagetable_done",
      "signature": "kvm_vmxept_identity_pagetable_done",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vmxept_identity_map_addrVMX_EPT_IDENTITY_PAGETABLE_ADDR",
      "signature": "kvm_vmxept_identity_map_addrVMX_EPT_IDENTITY_PAGETABLE_ADDR",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vmxpid_tablevoidpage_addresspages",
      "signature": "kvm_vmxpid_tablevoidpage_addresspages",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_make_requestKVM_REQ_APIC_PAGE_RELOAD",
      "signature": "kvm_make_requestKVM_REQ_APIC_PAGE_RELOAD",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_handle_page_fault",
      "signature": "return kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0); } ex_no = intr_info & INTR_INFO_VECTOR_MASK; if (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no)) return handle_rmode_exception(vcpu, ex_no, error_code); switch (ex_no)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_fault",
      "signature": "kvm_page_fault",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_fault",
      "signature": "return kvm_mmu_page_fault(vcpu, gpa, PFERR_RSVD_MASK, NULL, 0); } static int handle_nmi_window(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mark_page_dirtyvcpugpaPAGE_SHIFT",
      "signature": "kvm_vcpu_mark_page_dirtyvcpugpaPAGE_SHIFT",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_faultin_pfnslotgfnFOLL_WRITEwritablerefcounted_page",
      "signature": "kvm_faultin_pfnslotgfnFOLL_WRITEwritablerefcounted_page",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_cleanrefcounted_page",
      "signature": "kvm_release_page_cleanrefcounted_page",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_alloc_apic_access_page",
      "signature": "kvm_alloc_apic_access_page",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_faultin_pfn",
      "signature": "kvm_faultin_pfn",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "get_partition_assist_page",
      "signature": "get_partition_assist_page",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "get_vp_assist_page",
      "signature": "get_vp_assist_page",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "get_free_page",
      "signature": "get_free_page",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_print_sptes",
      "signature": "kvm_mmu_print_sptes",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invlpg",
      "signature": "kvm_mmu_invlpg",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_end",
      "signature": "in kvm_mmu_invalidate_end(). */ mmu_seq = kvm->mmu_invalidate_seq; smp_rmb(); /* * No need to retry if the memslot does not exist or is invalid. KVM * controls the APIC-access page memslot, and only deletes the memslot * if APICv is permanently inhibited, i.e. the memslot won't reappear. */ pfn = __kvm_faultin_pfn(slot, gfn, FOLL_WRITE, &writable, &refcounted_page); if (is_error_noslot_pfn(pfn)) return; read_lock(&vcpu->kvm->mmu_lock); if (mmu_invalidate_retry_gfn(kvm, mmu_seq, gfn)) kvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu); else vmcs_write64(APIC_ACCESS_ADDR, pfn_to_hpa(pfn)); /* * Do not pin the APIC access page in memory so that it can be freely * migrated, the MMU notifier will call us again if it is migrated or * swapped out. KVM backs the memslot with anonymous memory, the pfn * should always point at a refcounted page (if the pfn is valid). */ if (!WARN_ON_ONCE(!refcounted_page)) kvm_release_page_clean(refcounted_page); /* * No need for a manual TLB flush at this point, KVM has already done a * flush if there were SPTEs pointing at the previous page. */ read_unlock(&vcpu->kvm->mmu_lock); } void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_me_spte_mask",
      "signature": "kvm_mmu_set_me_spte_mask",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_set_ept_masks",
      "signature": "kvm_mmu_set_ept_masks",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs_write32PAGE_FAULT_ERROR_CODE_MASK",
      "signature": "vmcs_write32PAGE_FAULT_ERROR_CODE_MASK",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs_write32PAGE_FAULT_ERROR_CODE_MATCH",
      "signature": "vmcs_write32PAGE_FAULT_ERROR_CODE_MATCH",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "is_page_fault",
      "signature": "is_page_fault",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "ifis_page_fault",
      "signature": "ifis_page_fault",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "returnkvm_handle_page_fault",
      "signature": "returnkvm_handle_page_fault",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "trace_kvm_page_fault",
      "signature": "trace_kvm_page_fault",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "returnkvm_mmu_page_fault",
      "signature": "returnkvm_mmu_page_fault",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs_read32PAGE_FAULT_ERROR_CODE_MASK",
      "signature": "vmcs_read32PAGE_FAULT_ERROR_CODE_MASK",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs_read32PAGE_FAULT_ERROR_CODE_MATCH",
      "signature": "vmcs_read32PAGE_FAULT_ERROR_CODE_MATCH",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_hv_get_assist_page",
      "signature": "kvm_hv_get_assist_page",
      "file": "arch/x86/kvm/vmx/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "get_assist_page",
      "signature": "get_assist_page",
      "file": "arch/x86/kvm/vmx/hyperv.c",
      "category": "page_operations"
    },
    {
      "function": "staticinlineboolis_page_fault",
      "signature": "staticinlineboolis_page_fault",
      "file": "arch/x86/kvm/vmx/vmcs.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_unmapvcpuvmxnestedapic_access_page_map",
      "signature": "kvm_vcpu_unmapvcpuvmxnestedapic_access_page_map",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_clear_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "signature": "kvm_clear_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_inject_emulated_page_fault",
      "signature": "kvm_inject_emulated_page_fault",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_init_shadow_ept_mmuvcpuexeconlyept_lpage_level",
      "signature": "kvm_init_shadow_ept_mmuvcpuexeconlyept_lpage_level",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_page_role",
      "signature": "kvm_mmu_page_role",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mapvcpugpa_to_gfnvmcs12virtual_apic_page_addr",
      "signature": "kvm_vcpu_mapvcpugpa_to_gfnvmcs12virtual_apic_page_addr",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "kvm_write_guest_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_make_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "signature": "kvm_make_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mark_page_dirty",
      "signature": "kvm_vcpu_mark_page_dirty",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_check_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "signature": "kvm_check_requestKVM_REQ_GET_NESTED_STATE_PAGES",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_REQ_GET_NESTED_STATE_PAGES",
      "signature": "KVM_REQ_GET_NESTED_STATE_PAGES",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_make_requestKVM_REQ_APIC_PAGE_RELOAD",
      "signature": "kvm_make_requestKVM_REQ_APIC_PAGE_RELOAD",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "kvm_vcpu_write_guest_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_read_guest_pagevcpuvmcs12eptp_list_addressPAGE_SHIFT",
      "signature": "kvm_vcpu_read_guest_pagevcpuvmcs12eptp_list_addressPAGE_SHIFT",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "GET_NESTED_STATE_PAGE",
      "signature": "GET_NESTED_STATE_PAGE",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "get_vmcs12_page",
      "signature": "get_vmcs12_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "get_evmcs_page",
      "signature": "get_evmcs_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "get_nested_state_page",
      "signature": "get_nested_state_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "get_evmcs_pagealsoupdatesvp_assist_page",
      "signature": "get_evmcs_pagealsoupdatesvp_assist_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "get_free_page",
      "signature": "get_free_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "get_nested_state_pagesvmx_get_nested_state_page",
      "signature": "get_nested_state_pagesvmx_get_nested_state_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "put_vmcs12_page",
      "signature": "put_vmcs12_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_roots",
      "signature": "kvm_mmu_free_roots",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOTS_ALL",
      "signature": "KVM_MMU_ROOTS_ALL",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_root_info",
      "signature": "kvm_mmu_root_info",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_NUM_PREV_ROOTS",
      "signature": "KVM_MMU_NUM_PREV_ROOTS",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOT_PREVIOUS",
      "signature": "KVM_MMU_ROOT_PREVIOUS",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_addr",
      "signature": "kvm_mmu_invalidate_addr",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_new_pgd",
      "signature": "kvm_mmu_new_pgd",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_reset_context",
      "signature": "kvm_mmu_reset_context",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_ROOT_CURRENT",
      "signature": "KVM_MMU_ROOT_CURRENT",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_guest_mode_roots",
      "signature": "kvm_mmu_free_guest_mode_roots",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "staticvoidnested_ept_inject_page_fault",
      "signature": "staticvoidnested_ept_inject_page_fault",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "Althoughthecallerkvm_inject_emulated_page_fault",
      "signature": "Althoughthecallerkvm_inject_emulated_page_fault",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "vcpuarchmmuinject_page_faultnested_ept_inject_page_fault",
      "signature": "vcpuarchmmuinject_page_faultnested_ept_inject_page_fault",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "staticboolnested_vmx_is_page_fault_vmexit",
      "signature": "staticboolnested_vmx_is_page_fault_vmexit",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "error_codevmcs12page_fault_error_code_mask",
      "signature": "error_codevmcs12page_fault_error_code_mask",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs12page_fault_error_code_match",
      "signature": "vmcs12page_fault_error_code_match",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "returnnested_vmx_is_page_fault_vmexit",
      "signature": "returnnested_vmx_is_page_fault_vmexit",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs12page_fault_error_code_mask",
      "signature": "vmcs12page_fault_error_code_mask",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "evmcspage_fault_error_code_mask",
      "signature": "evmcspage_fault_error_code_mask",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "evmcspage_fault_error_code_match",
      "signature": "evmcspage_fault_error_code_match",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs_write32PAGE_FAULT_ERROR_CODE_MASK",
      "signature": "vmcs_write32PAGE_FAULT_ERROR_CODE_MASK",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs_write32PAGE_FAULT_ERROR_CODE_MATCH",
      "signature": "vmcs_write32PAGE_FAULT_ERROR_CODE_MATCH",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs_write32PAGE_FAULT_ERROR_CODE_MASKvmcs12page_fault_error_code_mask",
      "signature": "vmcs_write32PAGE_FAULT_ERROR_CODE_MASKvmcs12page_fault_error_code_mask",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "vmcs_write32PAGE_FAULT_ERROR_CODE_MATCHvmcs12page_fault_error_code_match",
      "signature": "vmcs_write32PAGE_FAULT_ERROR_CODE_MATCHvmcs12page_fault_error_code_match",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "elseifis_page_fault",
      "signature": "elseifis_page_fault",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "willbeinjectedwithnested_ept_inject_page_fault",
      "signature": "willbeinjectedwithnested_ept_inject_page_fault",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "arch/x86/kvm/vmx/main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_follow_pfn",
      "signature": "kvm_follow_pfn",
      "file": "virt/kvm/kvm_mm.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_thva_to_pfnstructkvm_follow_pfn",
      "signature": "kvm_pfn_thva_to_pfnstructkvm_follow_pfn",
      "file": "virt/kvm/kvm_mm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFNCACHE",
      "signature": "KVM_PFNCACHE",
      "file": "virt/kvm/kvm_mm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_LOCK_INIT",
      "signature": "define KVM_MMU_LOCK_INIT(kvm) rwlock_init(&(kvm)->mmu_lock) #define KVM_MMU_LOCK(kvm) write_lock(&(kvm)->mmu_lock) #define KVM_MMU_UNLOCK(kvm) write_unlock(&(kvm)->mmu_lock) #else #define KVM_MMU_LOCK_INIT(kvm) spin_lock_init(&(kvm)->mmu_lock) #define KVM_MMU_LOCK(kvm) spin_lock(&(kvm)->mmu_lock) #define KVM_MMU_UNLOCK(kvm) spin_unlock(&(kvm)->mmu_lock)",
      "file": "virt/kvm/kvm_mm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_LOCK",
      "signature": "define KVM_MMU_LOCK(kvm) write_lock(&(kvm)->mmu_lock) #define KVM_MMU_UNLOCK(kvm) write_unlock(&(kvm)->mmu_lock) #else #define KVM_MMU_LOCK_INIT(kvm) spin_lock_init(&(kvm)->mmu_lock) #define KVM_MMU_LOCK(kvm) spin_lock(&(kvm)->mmu_lock) #define KVM_MMU_UNLOCK(kvm) spin_unlock(&(kvm)->mmu_lock)",
      "file": "virt/kvm/kvm_mm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_UNLOCK",
      "signature": "define KVM_MMU_UNLOCK(kvm) write_unlock(&(kvm)->mmu_lock) #else #define KVM_MMU_LOCK_INIT(kvm) spin_lock_init(&(kvm)->mmu_lock) #define KVM_MMU_LOCK(kvm) spin_lock(&(kvm)->mmu_lock) #define KVM_MMU_UNLOCK(kvm) spin_unlock(&(kvm)->mmu_lock)",
      "file": "virt/kvm/kvm_mm.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_flush_remote_tlbs_rangestructkvmkvmgfn_tgfnu64nr_pages",
      "signature": "kvm_flush_remote_tlbs_rangestructkvmkvmgfn_tgfnu64nr_pages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_flush_remote_tlbs_rangekvmgfnnr_pages",
      "signature": "kvm_arch_flush_remote_tlbs_rangekvmgfnnr_pages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_flush_remote_tlbs_rangekvmmemslotbase_gfnmemslotnpages",
      "signature": "kvm_flush_remote_tlbs_rangekvmmemslotbase_gfnmemslotnpages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MEM_LOG_DIRTY_PAGES",
      "signature": "KVM_MEM_LOG_DIRTY_PAGES",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MEM_MAX_NR_PAGES",
      "signature": "KVM_MEM_MAX_NR_PAGES",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_check_memslot_overlapslotsidbase_gfnbase_gfnnpages",
      "signature": "kvm_check_memslot_overlapslotsidbase_gfnbase_gfnnpages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_get_dirty_loggetasnapshotofdirtypages",
      "signature": "kvm_get_dirty_loggetasnapshotofdirtypages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_get_dirty_log_protectgetasnapshotofdirtypages",
      "signature": "kvm_get_dirty_log_protectgetasnapshotofdirtypages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vm_ioctl_get_dirty_loggetandclearthelogofdirtypages",
      "signature": "kvm_vm_ioctl_get_dirty_loggetandclearthelogofdirtypages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_host_page_size",
      "signature": "long kvm_host_page_size(struct kvm_vcpu *vcpu, gfn_t gfn)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_is_ad_tracked_pagestructpagepage",
      "signature": "kvm_is_ad_tracked_pagestructpagepage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_set_page_dirtystructpagepage",
      "signature": "kvm_set_page_dirtystructpagepage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_is_ad_tracked_pagepage",
      "signature": "kvm_is_ad_tracked_pagepage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_set_page_accessedstructpagepage",
      "signature": "kvm_set_page_accessedstructpagepage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_cleanstructpagepage",
      "signature": "kvm_release_page_cleanstructpagepage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_set_page_accessedpage",
      "signature": "kvm_set_page_accessedpage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_release_page_clean",
      "signature": "KVM_INTERNALkvm_release_page_clean",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_dirtystructpagepage",
      "signature": "kvm_release_page_dirtystructpagepage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_set_page_dirtypage",
      "signature": "kvm_set_page_dirtypage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_cleanpage",
      "signature": "kvm_release_page_cleanpage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_release_page_dirty",
      "signature": "KVM_INTERNALkvm_release_page_dirty",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tkvm_resolve_pfnstructkvm_follow_pfnkfpstructpagepage",
      "signature": "kvm_pfn_tkvm_resolve_pfnstructkvm_follow_pfnkfpstructpagepage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_resolve_pfnkfppage",
      "signature": "kvm_resolve_pfnkfppage",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_prefetch_pages",
      "signature": "int kvm_prefetch_pages(struct kvm_memory_slot *slot, gfn_t gfn, struct page **pages, int nr_pages)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_prefetch_pages",
      "signature": "KVM_INTERNALkvm_prefetch_pages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNAL__gfn_to_page",
      "signature": "KVM_INTERNAL__gfn_to_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mark_page_dirty",
      "signature": "void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_set_page_dirtymappinned_page",
      "signature": "kvm_set_page_dirtymappinned_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_set_page_accessedmappinned_page",
      "signature": "kvm_set_page_accessedmappinned_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_read_guest_page",
      "signature": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_page",
      "signature": "KVM_INTERNALkvm_read_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_read_guest_page",
      "signature": "KVM_INTERNALkvm_vcpu_read_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_page",
      "signature": "KVM_INTERNALkvm_write_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_write_guest_page",
      "signature": "KVM_INTERNALkvm_vcpu_write_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_write_guest_pagekvmgfnzero_page",
      "signature": "kvm_write_guest_pagekvmgfnzero_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALmark_page_dirty_in_slot",
      "signature": "KVM_INTERNALmark_page_dirty_in_slot",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALmark_page_dirty",
      "signature": "KVM_INTERNALmark_page_dirty",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_mark_page_dirty",
      "signature": "KVM_INTERNALkvm_vcpu_mark_page_dirty",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_in_dirty_ring",
      "signature": "bool kvm_page_in_dirty_ring(struct kvm *kvm, unsigned long pgoff)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_DIRTY_LOG_PAGE_OFFSET",
      "signature": "KVM_DIRTY_LOG_PAGE_OFFSET",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PIO_PAGE_OFFSET",
      "signature": "KVM_PIO_PAGE_OFFSET",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_COALESCED_MMIO_PAGE_OFFSET",
      "signature": "KVM_COALESCED_MMIO_PAGE_OFFSET",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_dirty_ring_get_page",
      "signature": "kvm_dirty_ring_get_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_page_in_dirty_ringvcpukvmvmavm_pgoffpages",
      "signature": "kvm_page_in_dirty_ringvcpukvmvmavm_pgoffpages",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_runPAGE_SIZE",
      "signature": "kvm_runPAGE_SIZE",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_dirty_gfnsizePAGE_SIZE",
      "signature": "kvm_dirty_gfnsizePAGE_SIZE",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_vm_ioctl_reset_dirty_pages",
      "signature": "int kvm_vm_ioctl_reset_dirty_pages(struct kvm *kvm)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_read_guestgfn_to_pfn",
      "signature": "kvm_read_guestgfn_to_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tkvm_resolve_pfnstructkvm_follow_pfn",
      "signature": "kvm_pfn_tkvm_resolve_pfnstructkvm_follow_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_follow_pfnkfpkvm_pfn_tpfn",
      "signature": "kvm_follow_pfnkfpkvm_pfn_tpfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_resolve_pfn",
      "signature": "kvm_pfn_t kvm_resolve_pfn(struct kvm_follow_pfn *kfp, struct page *page, struct follow_pfnmap_args *map, bool writable)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_follow_pfnkfpkvm_pfn_tp_pfn",
      "signature": "kvm_follow_pfnkfpkvm_pfn_tp_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_RO_FAULT",
      "signature": "KVM_PFN_ERR_RO_FAULT",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_thva_to_pfnstructkvm_follow_pfn",
      "signature": "kvm_pfn_thva_to_pfnstructkvm_follow_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_FAULT",
      "signature": "KVM_PFN_ERR_FAULT",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_SIGPENDING",
      "signature": "KVM_PFN_ERR_SIGPENDING",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_HWPOISON",
      "signature": "KVM_PFN_ERR_HWPOISON",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_NEEDS_IO",
      "signature": "KVM_PFN_ERR_NEEDS_IO",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tkvm_follow_pfnstructkvm_follow_pfn",
      "signature": "kvm_pfn_tkvm_follow_pfnstructkvm_follow_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_NOSLOT",
      "signature": "KVM_PFN_NOSLOT",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_t__kvm_faultin_pfn",
      "signature": "kvm_pfn_t__kvm_faultin_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_follow_pfn",
      "signature": "kvm_pfn_t kvm_follow_pfn(struct kvm_follow_pfn *kfp)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNAL__kvm_faultin_pfn",
      "signature": "KVM_INTERNAL__kvm_faultin_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "get_free_page",
      "signature": "get_free_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "get_user_page",
      "signature": "get_user_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "get_user_pages_fast_onlyaddrnr_page",
      "signature": "get_user_pages_fast_onlyaddrnr_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache",
      "signature": "kvm_mmu_memory_cache",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_topup_memory_cache",
      "signature": "int kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int min)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_nr_free_objects",
      "signature": "int kvm_mmu_memory_cache_nr_free_objects(struct kvm_mmu_memory_cache *mc)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_memory_cache",
      "signature": "void kvm_mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_alloc",
      "signature": "void *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_range",
      "signature": "kvm_mmu_notifier_range",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_arg",
      "signature": "kvm_mmu_notifier_arg",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_return",
      "signature": "kvm_mmu_notifier_return",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_LOCK",
      "signature": "KVM_MMU_LOCK",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_UNLOCK",
      "signature": "KVM_MMU_UNLOCK",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_LOCKLESS_AGING",
      "signature": "KVM_MMU_LOCKLESS_AGING",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_begin",
      "signature": "void kvm_mmu_invalidate_begin(struct kvm *kvm)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_range_add",
      "signature": "void kvm_mmu_invalidate_range_add(struct kvm *kvm, gfn_t start, gfn_t end)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unmap_gfn_range",
      "signature": "bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_invalidate_range_start",
      "signature": "int kvm_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn, const struct mmu_notifier_range *range)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_end",
      "signature": "void kvm_mmu_invalidate_end(struct kvm *kvm)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_invalidate_range_end",
      "signature": "void kvm_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn, const struct mmu_notifier_range *range)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_clear_flush_young",
      "signature": "int kvm_mmu_notifier_clear_flush_young(struct mmu_notifier *mn, struct mm_struct *mm, unsigned long start, unsigned long end)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_clear_young",
      "signature": "int kvm_mmu_notifier_clear_young(struct mmu_notifier *mn, struct mm_struct *mm, unsigned long start, unsigned long end)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_test_young",
      "signature": "int kvm_mmu_notifier_test_young(struct mmu_notifier *mn, struct mm_struct *mm, unsigned long address)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_release",
      "signature": "void kvm_mmu_notifier_release(struct mmu_notifier *mn, struct mm_struct *mm)",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_ops",
      "signature": "kvm_mmu_notifier_ops",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_LOCK_INIT",
      "signature": "KVM_MMU_LOCK_INIT",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "READING_SHADOW_PAGE_TABLES",
      "signature": "READING_SHADOW_PAGE_TABLES",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "satisfiedifthevCPUmigratesEnteringREADING_SHADOW_PAGE_TABLES",
      "signature": "satisfiedifthevCPUmigratesEnteringREADING_SHADOW_PAGE_TABLES",
      "file": "virt/kvm/kvm_main.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_is_error_gpagpaoffset_in_page",
      "signature": "kvm_is_error_gpagpaoffset_in_page",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_unusedpage",
      "signature": "kvm_release_page_unusedpage",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_cleanpage",
      "signature": "kvm_release_page_cleanpage",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_checkstructgfn_to_pfn_cache",
      "signature": "kvm_gpc_checkstructgfn_to_pfn_cache",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_thva_to_pfn_retrystructgfn_to_pfn_cache",
      "signature": "kvm_pfn_thva_to_pfn_retrystructgfn_to_pfn_cache",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tnew_pfnKVM_PFN_ERR_FAULT",
      "signature": "kvm_pfn_tnew_pfnKVM_PFN_ERR_FAULT",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_follow_pfn",
      "signature": "kvm_follow_pfn",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_FAULT",
      "signature": "KVM_PFN_ERR_FAULT",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_refreshstructgfn_to_pfn_cache",
      "signature": "kvm_gpc_refreshstructgfn_to_pfn_cache",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_told_pfn",
      "signature": "kvm_pfn_told_pfn",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_initstructgfn_to_pfn_cache",
      "signature": "kvm_gpc_initstructgfn_to_pfn_cache",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_activatestructgfn_to_pfn_cache",
      "signature": "kvm_gpc_activatestructgfn_to_pfn_cache",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_activate_hvastructgfn_to_pfn_cache",
      "signature": "kvm_gpc_activate_hvastructgfn_to_pfn_cache",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_deactivatestructgfn_to_pfn_cache",
      "signature": "kvm_gpc_deactivatestructgfn_to_pfn_cache",
      "file": "virt/kvm/pfncache.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_async_page_present",
      "signature": "kvm_arch_async_page_present",
      "file": "virt/kvm/async_pf.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_async_page_present_queued",
      "signature": "kvm_arch_async_page_present_queued",
      "file": "virt/kvm/async_pf.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_can_dequeue_async_page_present",
      "signature": "kvm_arch_can_dequeue_async_page_present",
      "file": "virt/kvm/async_pf.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_async_page_ready",
      "signature": "kvm_arch_async_page_ready",
      "file": "virt/kvm/async_pf.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_async_page_not_present",
      "signature": "kvm_arch_async_page_not_present",
      "file": "virt/kvm/async_pf.c",
      "category": "page_operations"
    },
    {
      "function": "get_user_page",
      "signature": "get_user_page",
      "file": "virt/kvm/async_pf.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_dirty_ring_get_page",
      "signature": "page *kvm_dirty_ring_get_page(struct kvm_dirty_ring *ring, u32 offset)",
      "file": "virt/kvm/dirty_ring.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_LOCK",
      "signature": "KVM_MMU_LOCK",
      "file": "virt/kvm/dirty_ring.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_UNLOCK",
      "signature": "KVM_MMU_UNLOCK",
      "file": "virt/kvm/dirty_ring.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfnpage_to_pfnpage",
      "signature": "kvm_pfn_tpfnpage_to_pfnpage",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfnstructpagepage",
      "signature": "kvm_pfn_tpfnstructpagepage",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_populatestructkvmkvmgfn_tstart_gfnvoid__usersrclongnpages",
      "signature": "kvm_gmem_populatestructkvmkvmgfn_tstart_gfnvoid__usersrclongnpages",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tfolio_file_pfn",
      "signature": "kvm_pfn_tfolio_file_pfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfnfolio_file_pfn",
      "signature": "kvm_pfn_tpfnfolio_file_pfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_gmem_preparekvmgfnpfn",
      "signature": "kvm_arch_gmem_preparekvmgfnpfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_get_pfn",
      "signature": "that kvm_gmem_get_pfn() * cannot see this memslot. */ WRITE_ONCE(slot->gmem.file, NULL); } void kvm_gmem_unbind(struct kvm_memory_slot *slot)",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfnpage_to_pfn",
      "signature": "kvm_pfn_tpfnpage_to_pfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_gmem_invalidatepfnpfn",
      "signature": "kvm_arch_gmem_invalidatepfnpfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_get_pfnfileslotindexpfn",
      "signature": "kvm_gmem_get_pfnfileslotindexpfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_INTERNALkvm_gmem_get_pfn",
      "signature": "KVM_INTERNALkvm_gmem_get_pfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_LOCK",
      "signature": "KVM_MMU_LOCK",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_begin",
      "signature": "kvm_mmu_invalidate_begin",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unmap_gfn_range",
      "signature": "kvm_mmu_unmap_gfn_range",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_UNLOCK",
      "signature": "KVM_MMU_UNLOCK",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_end",
      "signature": "kvm_mmu_invalidate_end",
      "file": "virt/kvm/guest_memfd.c",
      "category": "page_operations"
    },
    {
      "function": "KVM_HVA_ERR_BADotherthanPAGE_OFFSET",
      "signature": "KVM_HVA_ERR_BADotherthanPAGE_OFFSET",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_HVA_ERR_BADPAGE_OFFSET",
      "signature": "KVM_HVA_ERR_BADPAGE_OFFSET",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_HVA_ERR_RO_BADPAGE_OFFSETPAGE_SIZE",
      "signature": "KVM_HVA_ERR_RO_BADPAGE_OFFSETPAGE_SIZE",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MEM_MAX_NR_PAGES",
      "signature": "define KVM_MEM_MAX_NR_PAGES ((1UL << 31) - 1) /* * Since at idle each memslot belongs to two memslot sets it has to contain * two embedded nodes for each data structure that it forms a part of. * * Two memslot sets (one active and one inactive)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MEM_LOG_DIRTY_PAGES",
      "signature": "KVM_MEM_LOG_DIRTY_PAGES",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_prefetch_pages",
      "signature": "int kvm_prefetch_pages(struct kvm_memory_slot *slot, gfn_t gfn, struct page **pages, int nr_pages); struct page *__gfn_to_page(struct kvm *kvm, gfn_t gfn, bool write); static inline struct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_unusedstructpagepage",
      "signature": "kvm_release_page_unusedstructpagepage",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_cleanstructpagepage",
      "signature": "kvm_release_page_cleanstructpagepage",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_dirtystructpagepage",
      "signature": "kvm_release_page_dirtystructpagepage",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_faultin_pagestructkvmkvmstructpagepage",
      "signature": "kvm_release_faultin_pagestructkvmkvmstructpagepage",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_unusedpage",
      "signature": "kvm_release_page_unusedpage",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_dirtypage",
      "signature": "kvm_release_page_dirtypage",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_release_page_cleanpage",
      "signature": "kvm_release_page_cleanpage",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_read_guest_page",
      "signature": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset, int len); int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len); int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_get_guest__kvm__gpaPAGE_SHIFT",
      "signature": "kvm_get_guest__kvm__gpaPAGE_SHIFT",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_put_guest__kvm__gpaPAGE_SHIFT",
      "signature": "kvm_put_guest__kvm__gpaPAGE_SHIFT",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_host_page_size",
      "signature": "long kvm_host_page_size(struct kvm_vcpu *vcpu, gfn_t gfn); void mark_page_dirty_in_slot(struct kvm *kvm, const struct kvm_memory_slot *memslot, gfn_t gfn); void mark_page_dirty(struct kvm *kvm, gfn_t gfn); int __kvm_vcpu_map(struct kvm_vcpu *vcpu, gpa_t gpa, struct kvm_host_map *map, bool writable); void kvm_vcpu_unmap(struct kvm_vcpu *vcpu, struct kvm_host_map *map); static inline int kvm_vcpu_map(struct kvm_vcpu *vcpu, gpa_t gpa, struct kvm_host_map *map)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data, int offset, int len); int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_vcpu_mark_page_dirty",
      "signature": "void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_flush_remote_tlbs_rangestructkvmkvmgfn_tgfnu64nr_pages",
      "signature": "kvm_flush_remote_tlbs_rangestructkvmkvmgfn_tgfnu64nr_pages",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_flush_remote_tlbs_rangestructkvmkvmgfn_tgfnu64nr_pages",
      "signature": "kvm_arch_flush_remote_tlbs_rangestructkvmkvmgfn_tgfnu64nr_pages",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_account_pgtable_pagesisthreadsafebecausemod_lruvec_page_state",
      "signature": "kvm_account_pgtable_pagesisthreadsafebecausemod_lruvec_page_state",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_account_pgtable_pages",
      "signature": "void kvm_account_pgtable_pages(void *virt, int nr)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfnstructpagepage",
      "signature": "kvm_pfn_tpfnstructpagepage",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_populatestructkvmkvmgfn_tgfnvoid__usersrclongnpages",
      "signature": "kvm_gmem_populatestructkvmkvmgfn_tgfnvoid__usersrclongnpages",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_MASK",
      "signature": "define KVM_PFN_ERR_MASK (0x7ffULL << 52) #define KVM_PFN_ERR_NOSLOT_MASK (0xfffULL << 52) #define KVM_PFN_NOSLOT (0x1ULL << 63) #define KVM_PFN_ERR_FAULT (KVM_PFN_ERR_MASK) #define KVM_PFN_ERR_HWPOISON (KVM_PFN_ERR_MASK + 1) #define KVM_PFN_ERR_RO_FAULT (KVM_PFN_ERR_MASK + 2) #define KVM_PFN_ERR_SIGPENDING (KVM_PFN_ERR_MASK + 3) #define KVM_PFN_ERR_NEEDS_IO (KVM_PFN_ERR_MASK + 4) /* * error pfns indicate that the gfn is in slot but faild to * translate it to pfn on host. */ static inline bool is_error_pfn(kvm_pfn_t pfn)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_NOSLOT_MASK",
      "signature": "define KVM_PFN_ERR_NOSLOT_MASK (0xfffULL << 52) #define KVM_PFN_NOSLOT (0x1ULL << 63) #define KVM_PFN_ERR_FAULT (KVM_PFN_ERR_MASK) #define KVM_PFN_ERR_HWPOISON (KVM_PFN_ERR_MASK + 1) #define KVM_PFN_ERR_RO_FAULT (KVM_PFN_ERR_MASK + 2) #define KVM_PFN_ERR_SIGPENDING (KVM_PFN_ERR_MASK + 3) #define KVM_PFN_ERR_NEEDS_IO (KVM_PFN_ERR_MASK + 4) /* * error pfns indicate that the gfn is in slot but faild to * translate it to pfn on host. */ static inline bool is_error_pfn(kvm_pfn_t pfn)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_NOSLOT",
      "signature": "define KVM_PFN_NOSLOT (0x1ULL << 63) #define KVM_PFN_ERR_FAULT (KVM_PFN_ERR_MASK) #define KVM_PFN_ERR_HWPOISON (KVM_PFN_ERR_MASK + 1) #define KVM_PFN_ERR_RO_FAULT (KVM_PFN_ERR_MASK + 2) #define KVM_PFN_ERR_SIGPENDING (KVM_PFN_ERR_MASK + 3) #define KVM_PFN_ERR_NEEDS_IO (KVM_PFN_ERR_MASK + 4) /* * error pfns indicate that the gfn is in slot but faild to * translate it to pfn on host. */ static inline bool is_error_pfn(kvm_pfn_t pfn)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_FAULTKVM_PFN_ERR_MASK",
      "signature": "KVM_PFN_ERR_FAULTKVM_PFN_ERR_MASK",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_HWPOISONKVM_PFN_ERR_MASK",
      "signature": "KVM_PFN_ERR_HWPOISONKVM_PFN_ERR_MASK",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_RO_FAULTKVM_PFN_ERR_MASK",
      "signature": "KVM_PFN_ERR_RO_FAULTKVM_PFN_ERR_MASK",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_SIGPENDINGKVM_PFN_ERR_MASK",
      "signature": "KVM_PFN_ERR_SIGPENDINGKVM_PFN_ERR_MASK",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_NEEDS_IOKVM_PFN_ERR_MASK",
      "signature": "KVM_PFN_ERR_NEEDS_IOKVM_PFN_ERR_MASK",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tpfn",
      "signature": "kvm_pfn_tpfn",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_SIGPENDINGindicatesthatfetchingthePFN",
      "signature": "KVM_PFN_ERR_SIGPENDINGindicatesthatfetchingthePFN",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_PFN_ERR_SIGPENDING",
      "signature": "define KVM_PFN_ERR_SIGPENDING (KVM_PFN_ERR_MASK + 3) #define KVM_PFN_ERR_NEEDS_IO (KVM_PFN_ERR_MASK + 4) /* * error pfns indicate that the gfn is in slot but faild to * translate it to pfn on host. */ static inline bool is_error_pfn(kvm_pfn_t pfn)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_t",
      "signature": "kvm_pfn_t",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_t__kvm_faultin_pfn",
      "signature": "kvm_pfn_t__kvm_faultin_pfn",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_pfn_tkvm_faultin_pfn",
      "signature": "kvm_pfn_tkvm_faultin_pfn",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_faultin_pfn",
      "signature": "kvm_pfn_t kvm_faultin_pfn(struct kvm_vcpu *vcpu, gfn_t gfn, bool write, bool *writable, struct page **refcounted_page)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_initinitializegfn_to_pfn_cache",
      "signature": "kvm_gpc_initinitializegfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_initstructgfn_to_pfn_cache",
      "signature": "kvm_gpc_initstructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_activatestructgfn_to_pfn_cache",
      "signature": "kvm_gpc_activatestructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_activate_hvastructgfn_to_pfn_cache",
      "signature": "kvm_gpc_activate_hvastructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_checkcheckvalidityofagfn_to_pfn_cache",
      "signature": "kvm_gpc_checkcheckvalidityofagfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_checkstructgfn_to_pfn_cache",
      "signature": "kvm_gpc_checkstructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_refreshstructgfn_to_pfn_cache",
      "signature": "kvm_gpc_refreshstructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_deactivatedeactivateandunlinkagfn_to_pfn_cache",
      "signature": "kvm_gpc_deactivatedeactivateandunlinkagfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_deactivatestructgfn_to_pfn_cache",
      "signature": "kvm_gpc_deactivatestructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_is_gpa_activestructgfn_to_pfn_cache",
      "signature": "kvm_gpc_is_gpa_activestructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_is_hva_activestructgfn_to_pfn_cache",
      "signature": "kvm_gpc_is_hva_activestructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gpc_mark_dirty_in_slotstructgfn_to_pfn_cache",
      "signature": "kvm_gpc_mark_dirty_in_slotstructgfn_to_pfn_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_get_pfn",
      "signature": "int kvm_gmem_get_pfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, kvm_pfn_t *pfn, struct page **page, int *max_order); #else static inline int kvm_gmem_get_pfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, kvm_pfn_t *pfn, struct page **page, int *max_order)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_gmem_preparestructkvmkvmgfn_tgfnkvm_pfn_tpfn",
      "signature": "kvm_arch_gmem_preparestructkvmkvmgfn_tgfnkvm_pfn_tpfn",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_gmem_populate_cbstructkvmkvmgfn_tgfnkvm_pfn_tpfn",
      "signature": "kvm_gmem_populate_cbstructkvmkvmgfn_tgfnkvm_pfn_tpfn",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_arch_gmem_invalidatekvm_pfn_tstartkvm_pfn_t",
      "signature": "kvm_arch_gmem_invalidatekvm_pfn_tstartkvm_pfn_t",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_arg",
      "signature": "kvm_mmu_notifier_arg",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_topup_memory_cache",
      "signature": "int kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int min); int __kvm_mmu_topup_memory_cache(struct kvm_mmu_memory_cache *mc, int capacity, int min); int kvm_mmu_memory_cache_nr_free_objects(struct kvm_mmu_memory_cache *mc); void kvm_mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc); void *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc); #endif void kvm_mmu_invalidate_begin(struct kvm *kvm); void kvm_mmu_invalidate_range_add(struct kvm *kvm, gfn_t start, gfn_t end); void kvm_mmu_invalidate_end(struct kvm *kvm); bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); long kvm_arch_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf); int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext); void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask); void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot); #ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log); int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log, int *is_dirty, struct kvm_memory_slot **memslot); #endif int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level, bool line_status); int kvm_vm_ioctl_enable_cap(struct kvm *kvm, struct kvm_enable_cap *cap); int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu, struct kvm_translation *tr); int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg); int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu); void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu); int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id); int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu); #ifdef CONFIG_HAVE_KVM_PM_NOTIFIER int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state); #endif #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry); #else static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache",
      "signature": "kvm_mmu_memory_cache",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_nr_free_objects",
      "signature": "int kvm_mmu_memory_cache_nr_free_objects(struct kvm_mmu_memory_cache *mc); void kvm_mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc); void *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc); #endif void kvm_mmu_invalidate_begin(struct kvm *kvm); void kvm_mmu_invalidate_range_add(struct kvm *kvm, gfn_t start, gfn_t end); void kvm_mmu_invalidate_end(struct kvm *kvm); bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); long kvm_arch_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf); int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext); void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask); void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot); #ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log); int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log, int *is_dirty, struct kvm_memory_slot **memslot); #endif int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level, bool line_status); int kvm_vm_ioctl_enable_cap(struct kvm *kvm, struct kvm_enable_cap *cap); int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu, struct kvm_translation *tr); int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg); int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu); void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu); int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id); int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu); #ifdef CONFIG_HAVE_KVM_PM_NOTIFIER int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state); #endif #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry); #else static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_free_memory_cache",
      "signature": "void kvm_mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc); void *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc); #endif void kvm_mmu_invalidate_begin(struct kvm *kvm); void kvm_mmu_invalidate_range_add(struct kvm *kvm, gfn_t start, gfn_t end); void kvm_mmu_invalidate_end(struct kvm *kvm); bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); long kvm_arch_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf); int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext); void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask); void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot); #ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log); int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log, int *is_dirty, struct kvm_memory_slot **memslot); #endif int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level, bool line_status); int kvm_vm_ioctl_enable_cap(struct kvm *kvm, struct kvm_enable_cap *cap); int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu, struct kvm_translation *tr); int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg); int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu); void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu); int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id); int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu); #ifdef CONFIG_HAVE_KVM_PM_NOTIFIER int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state); #endif #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry); #else static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_memory_cache_alloc",
      "signature": "void *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc); #endif void kvm_mmu_invalidate_begin(struct kvm *kvm); void kvm_mmu_invalidate_range_add(struct kvm *kvm, gfn_t start, gfn_t end); void kvm_mmu_invalidate_end(struct kvm *kvm); bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); long kvm_arch_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf); int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext); void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask); void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot); #ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log); int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log, int *is_dirty, struct kvm_memory_slot **memslot); #endif int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level, bool line_status); int kvm_vm_ioctl_enable_cap(struct kvm *kvm, struct kvm_enable_cap *cap); int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu, struct kvm_translation *tr); int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg); int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu); void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu); int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id); int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu); #ifdef CONFIG_HAVE_KVM_PM_NOTIFIER int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state); #endif #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry); #else static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_begin",
      "signature": "void kvm_mmu_invalidate_begin(struct kvm *kvm); void kvm_mmu_invalidate_range_add(struct kvm *kvm, gfn_t start, gfn_t end); void kvm_mmu_invalidate_end(struct kvm *kvm); bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); long kvm_arch_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf); int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext); void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask); void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot); #ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log); int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log, int *is_dirty, struct kvm_memory_slot **memslot); #endif int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level, bool line_status); int kvm_vm_ioctl_enable_cap(struct kvm *kvm, struct kvm_enable_cap *cap); int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu, struct kvm_translation *tr); int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg); int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu); void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu); int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id); int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu); #ifdef CONFIG_HAVE_KVM_PM_NOTIFIER int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state); #endif #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry); #else static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_range_add",
      "signature": "void kvm_mmu_invalidate_range_add(struct kvm *kvm, gfn_t start, gfn_t end); void kvm_mmu_invalidate_end(struct kvm *kvm); bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); long kvm_arch_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf); int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext); void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask); void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot); #ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log); int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log, int *is_dirty, struct kvm_memory_slot **memslot); #endif int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level, bool line_status); int kvm_vm_ioctl_enable_cap(struct kvm *kvm, struct kvm_enable_cap *cap); int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu, struct kvm_translation *tr); int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg); int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu); void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu); int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id); int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu); #ifdef CONFIG_HAVE_KVM_PM_NOTIFIER int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state); #endif #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry); #else static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_invalidate_end",
      "signature": "void kvm_mmu_invalidate_end(struct kvm *kvm); bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); long kvm_arch_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf); int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext); void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask); void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot); #ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log); int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log, int *is_dirty, struct kvm_memory_slot **memslot); #endif int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level, bool line_status); int kvm_vm_ioctl_enable_cap(struct kvm *kvm, struct kvm_enable_cap *cap); int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu, struct kvm_translation *tr); int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg); int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu); void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu); int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id); int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu); #ifdef CONFIG_HAVE_KVM_PM_NOTIFIER int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state); #endif #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry); #else static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_unmap_gfn_range",
      "signature": "bool kvm_mmu_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range); long kvm_arch_dev_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); vm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf); int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext); void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask); void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot); #ifndef CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log); int kvm_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log, int *is_dirty, struct kvm_memory_slot **memslot); #endif int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level, bool line_status); int kvm_vm_ioctl_enable_cap(struct kvm *kvm, struct kvm_enable_cap *cap); int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); long kvm_arch_vm_compat_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg); int kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu); int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu, struct kvm_translation *tr); int kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs); int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs); int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu, struct kvm_mp_state *mp_state); int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu, struct kvm_guest_debug *dbg); int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu); void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu); int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id); int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu); void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu); #ifdef CONFIG_HAVE_KVM_PM_NOTIFIER int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state); #endif #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry); #else static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "kvm_mmu_notifier_invalidate_range_start",
      "signature": "kvm_mmu_notifier_invalidate_range_start",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "READING_SHADOW_PAGE_TABLES",
      "signature": "READING_SHADOW_PAGE_TABLES",
      "file": "include/linux/kvm_host.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MEM_LOG_DIRTY_PAGES",
      "signature": "define KVM_MEM_LOG_DIRTY_PAGES (1UL << 0) #define KVM_MEM_READONLY (1UL << 1) #define KVM_MEM_GUEST_MEMFD (1UL << 2)",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_S390_SIE_PAGE_OFFSET",
      "signature": "KVM_S390_SIE_PAGE_OFFSET",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_CAP_S390_HPAGE_1M",
      "signature": "KVM_CAP_S390_HPAGE_1M",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_CAP_VM_DISABLE_NX_HUGE_PAGES",
      "signature": "KVM_CAP_VM_DISABLE_NX_HUGE_PAGES",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_SET_NR_MMU_PAGES",
      "signature": "KVM_SET_NR_MMU_PAGES",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_GET_NR_MMU_PAGES",
      "signature": "KVM_GET_NR_MMU_PAGES",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_DIRTY_LOG_PAGE_OFFSET",
      "signature": "KVM_DIRTY_LOG_PAGE_OFFSET",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_CAP_ARM_CACHEABLE_PFNMAP_SUPPORTED",
      "signature": "KVM_CAP_ARM_CACHEABLE_PFNMAP_SUPPORTED",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "GET_NR_MMU_PAGE",
      "signature": "GET_NR_MMU_PAGE",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_FSL_BOOKE_NOHV",
      "signature": "KVM_MMU_FSL_BOOKE_NOHV",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    },
    {
      "function": "KVM_MMU_FSL_BOOKE_HV",
      "signature": "KVM_MMU_FSL_BOOKE_HV",
      "file": "include/uapi/linux/kvm.h",
      "category": "page_operations"
    }
  ],
  "address_conversion": [
    {
      "function": "gfn_to_hva",
      "signature": "gfn_to_hva",
      "file": "arch/x86/kvm/lapic.h",
      "category": "address_conversion"
    },
    {
      "function": "kvm_gfn_to_hva",
      "signature": "kvm_gfn_to_hva",
      "file": "arch/x86/kvm/lapic.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "gfn_to_hva",
      "file": "arch/x86/kvm/lapic.c",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa",
      "signature": "gva_to_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa_read",
      "signature": "gva_to_gpa_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa_write",
      "signature": "gva_to_gpa_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa_system",
      "signature": "gva_to_gpa_system",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "gfn_to_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_pfn",
      "signature": "gfn_to_pfn",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_gfn_to_hva",
      "signature": "kvm_gfn_to_hva",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "gfn_to_hva",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_mmu_gva_to_gpa",
      "signature": "kvm_mmu_gva_to_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "vcpu_mmio_gva_to_gpa",
      "signature": "int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva, gpa_t *gpa, struct x86_exception *exception, bool write)",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_vcpu_gfn_to_hva",
      "signature": "kvm_vcpu_gfn_to_hva",
      "file": "arch/x86/kvm/x86.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "gfn_to_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_vcpu_gfn_to_hva",
      "signature": "kvm_vcpu_gfn_to_hva",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "gfn_to_gpa",
      "file": "arch/x86/kvm/mmu.h",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/xen.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_pfn",
      "signature": "gfn_to_pfn",
      "file": "arch/x86/kvm/xen.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "gfn_to_gpa",
      "file": "arch/x86/kvm/xen.c",
      "category": "address_conversion"
    },
    {
      "function": "page_to_pfn",
      "signature": "page_to_pfn",
      "file": "arch/x86/kvm/svm/svm.h",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "address_conversion"
    },
    {
      "function": "page_to_pfn",
      "signature": "page_to_pfn",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "gfn_to_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_page",
      "signature": "virt_to_page",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "address_conversion"
    },
    {
      "function": "page_to_pfn",
      "signature": "page_to_pfn",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_page",
      "signature": "virt_to_page",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "address_conversion"
    },
    {
      "function": "page_to_pfn",
      "signature": "page_to_pfn",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_page",
      "signature": "virt_to_page",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "address_conversion"
    },
    {
      "function": "spte_to_pfn",
      "signature": "kvm_pfn_t spte_to_pfn(u64 pte)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa_write",
      "signature": "gva_to_gpa_write",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa",
      "signature": "gva_to_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "spte_to_pfn",
      "signature": "spte_to_pfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_mmu_gva_to_gpa",
      "signature": "kvm_mmu_gva_to_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "page_to_pfn",
      "signature": "page_to_pfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "__gfn_to_hva",
      "signature": "__gfn_to_hva",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "to gfn_to_hva() assuming writes. Earlier * page fault steps have already verified the guest isn't writing a * read-only memslot. */ hva = __gfn_to_hva_memslot(slot, gfn); /* * Disable IRQs to prevent concurrent tear down of host page tables, * e.g. if the primary MMU promotes a P*D to a huge page and then frees * the original page table. */ local_irq_save(flags); /* * Read each entry once. As above, a non-leaf entry can be promoted to * a huge page _during_ this walk. Re-reading the entry could send the * walk into the weeks, e.g. p*d_leaf() returns false (sees the old * value) and then p*d_offset() walks into the target huge page instead * of the old page table (sees the new value). */ pgd = READ_ONCE(*pgd_offset(kvm->mm, hva)); if (pgd_none(pgd)) goto out; p4d = READ_ONCE(*p4d_offset(&pgd, hva)); if (p4d_none(p4d) || !p4d_present(p4d)) goto out; pud = READ_ONCE(*pud_offset(&p4d, hva)); if (pud_none(pud) || !pud_present(pud)) goto out; if (pud_leaf(pud))",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "nonpaging_gva_to_gpa",
      "signature": "gpa_t nonpaging_gva_to_gpa(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, gpa_t vaddr, u64 access, struct x86_exception *exception)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_vcpu_gfn_to_hva",
      "signature": "kvm_vcpu_gfn_to_hva",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "gfn_to_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "paging64_gva_to_gpa",
      "signature": "paging64_gva_to_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "paging32_gva_to_gpa",
      "signature": "paging32_gva_to_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "ept_gva_to_gpa",
      "signature": "ept_gva_to_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_translate_gpavcpummuvaddr",
      "signature": "kvm_translate_gpavcpummuvaddr",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_page",
      "signature": "virt_to_page",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "spte_to_pfn",
      "signature": "spte_to_pfn",
      "file": "arch/x86/kvm/mmu/tdp_iter.c",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_phys",
      "signature": "virt_to_phys",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "address_conversion"
    },
    {
      "function": "spte_to_pfn",
      "signature": "spte_to_pfn",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_page",
      "signature": "virt_to_page",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa",
      "signature": "when gva_to_gpa() translates an L2 GPA to an L1 GPA. */ static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, gpa_t addr, u64 access, struct x86_exception *exception)",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "return gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t); } /* Note, @addr is a GPA when gva_to_gpa() translates an L2 GPA to an L1 GPA. */ static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, gpa_t addr, u64 access, struct x86_exception *exception)",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "gfn_to_hva",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "address_conversion"
    },
    {
      "function": "spte_to_pfn",
      "signature": "spte_to_pfn",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_hva",
      "signature": "gpa_to_hva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa",
      "signature": "gva_to_gpa",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa_write",
      "signature": "gva_to_gpa_write",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "address_conversion"
    },
    {
      "function": "gva_to_gpa_read",
      "signature": "gva_to_gpa_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "address_conversion"
    },
    {
      "function": "sgx_gva_to_gpa",
      "signature": "int sgx_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t gva, bool write, gpa_t *gpa)",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_mmu_gva_to_gpa",
      "signature": "kvm_mmu_gva_to_gpa",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "address_conversion"
    },
    {
      "function": "sgx_gpa_to_hva",
      "signature": "int sgx_gpa_to_hva(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned long *hva)",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_vcpu_gfn_to_hva",
      "signature": "kvm_vcpu_gfn_to_hva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "TDX_SHARED_BIT_PWL_5 gpa_to_gfn(BIT_ULL(51)) #define TDX_SHARED_BIT_PWL_4 gpa_to_gfn(BIT_ULL(47)) static enum cpuhp_state tdx_cpuhp_state; static const struct tdx_sys_info *tdx_sysinfo; void tdh_vp_rd_failed(struct vcpu_tdx *tdx, char *uclass, u32 field, u64 err)",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "gfn_to_gpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_page",
      "signature": "virt_to_page",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "gfn_to_hva",
      "file": "arch/x86/kvm/vmx/vmx.h",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "gfn_to_hva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_gfn_to_hva",
      "signature": "kvm_gfn_to_hva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_pfn",
      "signature": "kvm_pfn_t hva_to_pfn(struct kvm_follow_pfn *kfp); #ifdef CONFIG_HAVE_KVM_PFNCACHE void gfn_to_pfn_cache_invalidate_start(struct kvm *kvm, unsigned long start, unsigned long end); #else static inline void gfn_to_pfn_cache_invalidate_start(struct kvm *kvm, unsigned long start, unsigned long end)",
      "file": "virt/kvm/kvm_mm.h",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_pfn",
      "signature": "gfn_to_pfn",
      "file": "virt/kvm/kvm_mm.h",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_gfn_memslot",
      "signature": "hva_to_gfn_memslot",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_pfn_fast",
      "signature": "bool hva_to_pfn_fast(struct kvm_follow_pfn *kfp, kvm_pfn_t *pfn)",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_pfn_slow",
      "signature": "int hva_to_pfn_slow(struct kvm_follow_pfn *kfp, kvm_pfn_t *pfn)",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_pfn_remapped",
      "signature": "int hva_to_pfn_remapped(struct vm_area_struct *vma, struct kvm_follow_pfn *kfp, kvm_pfn_t *p_pfn)",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_pfn",
      "signature": "kvm_pfn_t hva_to_pfn(struct kvm_follow_pfn *kfp)",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_pfn",
      "signature": "gfn_to_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "long gfn_to_hva(struct kvm *kvm, gfn_t gfn)",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_vcpu_gfn_to_hva",
      "signature": "long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn)",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "__gfn_to_hva",
      "signature": "__gfn_to_hva",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "page_to_pfn",
      "signature": "page_to_pfn",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "__kvm_gfn_to_hva",
      "signature": "__kvm_gfn_to_hva",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "kvm_gfn_to_hva",
      "signature": "kvm_gfn_to_hva",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_page",
      "signature": "virt_to_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gpa_to_gfn",
      "file": "virt/kvm/pfncache.c",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_pfn_retry",
      "signature": "kvm_pfn_t hva_to_pfn_retry(struct gfn_to_pfn_cache *gpc)",
      "file": "virt/kvm/pfncache.c",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_pfn",
      "signature": "hva_to_pfn",
      "file": "virt/kvm/pfncache.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_pfn",
      "signature": "gfn_to_pfn",
      "file": "virt/kvm/pfncache.c",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "gfn_to_hva",
      "file": "virt/kvm/pfncache.c",
      "category": "address_conversion"
    },
    {
      "function": "page_to_pfn",
      "signature": "page_to_pfn",
      "file": "virt/kvm/guest_memfd.c",
      "category": "address_conversion"
    },
    {
      "function": "gpa_to_gfn",
      "signature": "gfn_t gpa_to_gfn(gpa_t gpa)",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    },
    {
      "function": "hva_to_gfn_memslot",
      "signature": "gfn_t hva_to_gfn_memslot(unsigned long hva, struct kvm_memory_slot *slot)",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_pfn",
      "signature": "gfn_to_pfn",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_hva",
      "signature": "long gfn_to_hva(struct kvm *kvm, gfn_t gfn); unsigned long gfn_to_hva_prot(struct kvm *kvm, gfn_t gfn, bool *writable); unsigned long gfn_to_hva_memslot(struct kvm_memory_slot *slot, gfn_t gfn); unsigned long gfn_to_hva_memslot_prot(struct kvm_memory_slot *slot, gfn_t gfn, bool *writable); static inline void kvm_release_page_unused(struct page *page)",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    },
    {
      "function": "kvm_gfn_to_hva",
      "signature": "kvm_gfn_to_hva",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    },
    {
      "function": "kvm_vcpu_gfn_to_hva",
      "signature": "long kvm_vcpu_gfn_to_hva(struct kvm_vcpu *vcpu, gfn_t gfn); unsigned long kvm_vcpu_gfn_to_hva_prot(struct kvm_vcpu *vcpu, gfn_t gfn, bool *writable); int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data, int offset, int len); int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    },
    {
      "function": "__gfn_to_hva",
      "signature": "__gfn_to_hva",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    },
    {
      "function": "gfn_to_gpa",
      "signature": "gpa_t gfn_to_gpa(gfn_t gfn)",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    },
    {
      "function": "virt_to_page",
      "signature": "virt_to_page",
      "file": "include/linux/kvm_host.h",
      "category": "address_conversion"
    }
  ],
  "mmio_pio": [
    {
      "function": "kvm_io_device_opsioapic_mmio_ops",
      "signature": "kvm_io_device_opsioapic_mmio_ops",
      "file": "arch/x86/kvm/ioapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_iodevice_initioapicdevioapic_mmio_ops",
      "signature": "kvm_iodevice_initioapicdevioapic_mmio_ops",
      "file": "arch/x86/kvm/ioapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_register_devkvmKVM_MMIO_BUS",
      "signature": "kvm_io_bus_register_devkvmKVM_MMIO_BUS",
      "file": "arch/x86/kvm/ioapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_unregister_devkvmKVM_MMIO_BUS",
      "signature": "kvm_io_bus_unregister_devkvmKVM_MMIO_BUS",
      "file": "arch/x86/kvm/ioapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_read",
      "signature": "mmio_read",
      "file": "arch/x86/kvm/ioapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_write",
      "signature": "mmio_write",
      "file": "arch/x86/kvm/ioapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_ops",
      "signature": "mmio_ops",
      "file": "arch/x86/kvm/ioapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_BUS",
      "signature": "MMIO_BUS",
      "file": "arch/x86/kvm/ioapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_in_emulated",
      "signature": "pio_in_emulated",
      "file": "arch/x86/kvm/kvm_emulate.h",
      "category": "mmio_pio"
    },
    {
      "function": "pio_out_emulated",
      "signature": "pio_out_emulated",
      "file": "arch/x86/kvm/kvm_emulate.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_X86_EMULATE_H",
      "signature": "KVM_X86_EMULATE_H",
      "file": "arch/x86/kvm/kvm_emulate.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size, unsigned int port, void *data, unsigned int count, int in); static inline bool user_exit_on_hypercall(struct kvm *kvm, unsigned long hc_nr)",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size, unsigned int port, void *data, unsigned int count, int in); static inline bool user_exit_on_hypercall(struct kvm *kvm, unsigned long hc_nr)",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_info",
      "signature": "mmio_info",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gva",
      "signature": "mmio_gva",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_access",
      "signature": "mmio_access",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gfn",
      "signature": "mmio_gfn",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gen",
      "signature": "mmio_gen",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_GVA_ANY",
      "signature": "define MMIO_GVA_ANY (~(gva_t)0) static inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gpa",
      "signature": "mmio_gpa",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_write",
      "signature": "mmio_write",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_read",
      "signature": "mmio_read",
      "file": "arch/x86/kvm/x86.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_PIO_IN",
      "signature": "KVM_PIO_IN",
      "file": "arch/x86/kvm/trace.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_PIO_OUT",
      "signature": "KVM_PIO_OUT",
      "file": "arch/x86/kvm/trace.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_pio",
      "signature": "kvm_pio",
      "file": "arch/x86/kvm/trace.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_mmio",
      "signature": "kvm_fast_mmio",
      "file": "arch/x86/kvm/trace.h",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_IN",
      "signature": "PIO_IN",
      "file": "arch/x86/kvm/trace.h",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_OUT",
      "signature": "PIO_OUT",
      "file": "arch/x86/kvm/trace.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_emulate_insn_startvcputrace_kvm_emulate_insn",
      "signature": "kvm_emulate_insn_startvcputrace_kvm_emulate_insn",
      "file": "arch/x86/kvm/trace.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_emulate_insn_failedvcputrace_kvm_emulate_insn",
      "signature": "kvm_emulate_insn_failedvcputrace_kvm_emulate_insn",
      "file": "arch/x86/kvm/trace.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_X86_QUIRK_LAPIC_MMIO_HOLE",
      "signature": "KVM_X86_QUIRK_LAPIC_MMIO_HOLE",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_device_opsapic_mmio_ops",
      "signature": "kvm_io_device_opsapic_mmio_ops",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_iodevice_initapicdevapic_mmio_ops",
      "signature": "kvm_iodevice_initapicdevapic_mmio_ops",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_LENGTH",
      "signature": "MMIO_LENGTH",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_in_range",
      "signature": "mmio_in_range",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_read",
      "signature": "mmio_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_HOLE",
      "signature": "MMIO_HOLE",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_write",
      "signature": "mmio_write",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_ops",
      "signature": "mmio_ops",
      "file": "arch/x86/kvm/lapic.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_in_emulated",
      "signature": "int pio_in_emulated(struct x86_emulate_ctxt *ctxt, unsigned int size, unsigned short port, void *dest)",
      "file": "arch/x86/kvm/emulate.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_out_emulated",
      "signature": "pio_out_emulated",
      "file": "arch/x86/kvm/emulate.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_register_devkvmKVM_PIO_BUS",
      "signature": "kvm_io_bus_register_devkvmKVM_PIO_BUS",
      "file": "arch/x86/kvm/i8254.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_unregister_devkvmKVM_PIO_BUS",
      "signature": "kvm_io_bus_unregister_devkvmKVM_PIO_BUS",
      "file": "arch/x86/kvm/i8254.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_BUS",
      "signature": "PIO_BUS",
      "file": "arch/x86/kvm/i8254.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_writevcpuKVM_MMIO_BUS",
      "signature": "kvm_io_bus_writevcpuKVM_MMIO_BUS",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_readvcpuKVM_MMIO_BUS",
      "signature": "kvm_io_bus_readvcpuKVM_MMIO_BUS",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "signature": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmio_fragmentfragvcpummio_fragments",
      "signature": "kvm_mmio_fragmentfragvcpummio_fragments",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmio_fragment",
      "signature": "kvm_mmio_fragment",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_MAX_MMIO_FRAGMENTS",
      "signature": "KVM_MAX_MMIO_FRAGMENTS",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_EXIT_MMIO",
      "signature": "KVM_EXIT_MMIO",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_readvcpuKVM_PIO_BUS",
      "signature": "kvm_io_bus_readvcpuKVM_PIO_BUS",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_writevcpuKVM_PIO_BUS",
      "signature": "kvm_io_bus_writevcpuKVM_PIO_BUS",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_PIO_PAGE_OFFSET",
      "signature": "KVM_PIO_PAGE_OFFSET",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_pioKVM_PIO_IN",
      "signature": "kvm_pioKVM_PIO_IN",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_pioKVM_PIO_INvcpuarchpioportsizecountvcpuarchpio_data",
      "signature": "kvm_pioKVM_PIO_INvcpuarchpioportsizecountvcpuarchpio_data",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_pioKVM_PIO_OUT",
      "signature": "kvm_pioKVM_PIO_OUT",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_pio_out",
      "signature": "int kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size, unsigned short port)",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_pio_in",
      "signature": "int kvm_fast_pio_in(struct kvm_vcpu *vcpu, int size, unsigned short port)",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_pio",
      "signature": "int kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_fast_pio",
      "signature": "KVM_INTERNALkvm_fast_pio",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_invalidate_mmio_sptes",
      "signature": "kvm_mmu_invalidate_mmio_sptes",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes, void *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_sev_es_mmio_write",
      "signature": "KVM_INTERNALkvm_sev_es_mmio_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes, void *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_sev_es_mmio_read",
      "signature": "KVM_INTERNALkvm_sev_es_mmio_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmio",
      "signature": "kvm_mmio",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_mmio",
      "signature": "kvm_fast_mmio",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_created",
      "signature": "mmio_spte_created",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_exits",
      "signature": "mmio_exits",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_CONF_BASE",
      "signature": "MMIO_CONF_BASE",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_write",
      "signature": "mmio_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_BUS",
      "signature": "MMIO_BUS",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_read",
      "signature": "mmio_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_READ",
      "signature": "MMIO_READ",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gpa",
      "signature": "mmio_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gva_to_gpa",
      "signature": "mmio_gva_to_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gva",
      "signature": "mmio_gva",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_access",
      "signature": "mmio_access",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gfn",
      "signature": "mmio_gfn",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_read_completed",
      "signature": "mmio_read_completed",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_fragments",
      "signature": "mmio_fragments",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_WRITE",
      "signature": "MMIO_WRITE",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_READ_UNSATISFIED",
      "signature": "MMIO_READ_UNSATISFIED",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_fragment",
      "signature": "mmio_fragment",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_nr_fragments",
      "signature": "mmio_nr_fragments",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_FRAGMENTS",
      "signature": "MMIO_FRAGMENTS",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_needed",
      "signature": "mmio_needed",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_cur_fragment",
      "signature": "mmio_cur_fragment",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_is_write",
      "signature": "mmio_is_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_in_out",
      "signature": "pio_in_out",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_BUS",
      "signature": "PIO_BUS",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_data",
      "signature": "pio_data",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_PAGE_OFFSET",
      "signature": "PIO_PAGE_OFFSET",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_in",
      "signature": "pio_in",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_IN",
      "signature": "PIO_IN",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_in_emulated",
      "signature": "pio_in_emulated",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_out",
      "signature": "pio_out",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_OUT",
      "signature": "PIO_OUT",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_out_emulated",
      "signature": "pio_out_emulated",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_out_port_0x7e",
      "signature": "pio_out_port_0x7e",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_sptes",
      "signature": "mmio_sptes",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_count",
      "signature": "pio_count",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_xsetbv",
      "signature": "KVM_INTERNALkvm_emulate_xsetbv",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_rdpmc",
      "signature": "KVM_INTERNALkvm_emulate_rdpmc",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNAL__kvm_emulate_msr_read",
      "signature": "KVM_INTERNAL__kvm_emulate_msr_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNAL__kvm_emulate_msr_write",
      "signature": "KVM_INTERNAL__kvm_emulate_msr_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_msr_read",
      "signature": "KVM_INTERNALkvm_emulate_msr_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_msr_write",
      "signature": "KVM_INTERNALkvm_emulate_msr_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_rdmsr",
      "signature": "KVM_INTERNALkvm_emulate_rdmsr",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_rdmsr_imm",
      "signature": "KVM_INTERNALkvm_emulate_rdmsr_imm",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_wrmsr",
      "signature": "KVM_INTERNALkvm_emulate_wrmsr",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_wrmsr_imm",
      "signature": "KVM_INTERNALkvm_emulate_wrmsr_imm",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_invd",
      "signature": "KVM_INTERNALkvm_emulate_invd",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_mwait",
      "signature": "KVM_INTERNALkvm_emulate_mwait",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_monitor",
      "signature": "KVM_INTERNALkvm_emulate_monitor",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fetch_guest_virtstructx86_emulate_ctxt",
      "signature": "kvm_fetch_guest_virtstructx86_emulate_ctxt",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_check_emulate_insn",
      "signature": "int kvm_check_emulate_insn(struct kvm_vcpu *vcpu, int emul_type, void *insn, int insn_len)",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_x86_callcheck_emulate_instruction",
      "signature": "kvm_x86_callcheck_emulate_instruction",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_emulate_prefix__KVM_EMULATE_PREFIX",
      "signature": "kvm_emulate_prefix__KVM_EMULATE_PREFIX",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_wbinvd",
      "signature": "KVM_INTERNALkvm_emulate_wbinvd",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_instruction",
      "signature": "KVM_INTERNALkvm_emulate_instruction",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_instruction_from_buffer",
      "signature": "KVM_INTERNALkvm_emulate_instruction_from_buffer",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNAL____kvm_emulate_hypercall",
      "signature": "KVM_INTERNAL____kvm_emulate_hypercall",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_hypercall",
      "signature": "KVM_INTERNALkvm_emulate_hypercall",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_halt_noskip",
      "signature": "KVM_INTERNALkvm_emulate_halt_noskip",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_halt",
      "signature": "KVM_INTERNALkvm_emulate_halt",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_ap_reset_hold",
      "signature": "KVM_INTERNALkvm_emulate_ap_reset_hold",
      "file": "arch/x86/kvm/x86.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_register_devkvmKVM_PIO_BUS",
      "signature": "kvm_io_bus_register_devkvmKVM_PIO_BUS",
      "file": "arch/x86/kvm/i8259.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_unregister_devkvmKVM_PIO_BUS",
      "signature": "kvm_io_bus_unregister_devkvmKVM_PIO_BUS",
      "file": "arch/x86/kvm/i8259.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_unregister_devvpickvmKVM_PIO_BUS",
      "signature": "kvm_io_bus_unregister_devvpickvmKVM_PIO_BUS",
      "file": "arch/x86/kvm/i8259.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_BUS",
      "signature": "PIO_BUS",
      "file": "arch/x86/kvm/i8259.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_cpuid",
      "signature": "KVM_INTERNALkvm_emulate_cpuid",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_masku64mmio_valueu64mmio_mask",
      "signature": "kvm_mmu_set_mmio_spte_masku64mmio_valueu64mmio_mask",
      "file": "arch/x86/kvm/mmu.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_valuestructkvmkvmu64mmio_value",
      "signature": "kvm_mmu_set_mmio_spte_valuestructkvmkvmu64mmio_value",
      "file": "arch/x86/kvm/mmu.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_caching",
      "signature": "mmio_caching",
      "file": "arch/x86/kvm/mmu.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_mask",
      "signature": "mmio_spte_mask",
      "file": "arch/x86/kvm/mmu.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_value",
      "signature": "mmio_value",
      "file": "arch/x86/kvm/mmu.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_mask",
      "signature": "mmio_mask",
      "file": "arch/x86/kvm/mmu.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_value",
      "signature": "mmio_spte_value",
      "file": "arch/x86/kvm/mmu.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "kvm_sev_es_mmio_read",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "kvm_sev_es_mmio_write",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_caching",
      "signature": "mmio_caching",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_READ",
      "signature": "MMIO_READ",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_WRITE",
      "signature": "MMIO_WRITE",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_read",
      "signature": "mmio_read",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_write",
      "signature": "mmio_write",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_pio",
      "signature": "return kvm_fast_pio(vcpu, size, port, in); } static int nmi_interception(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_mask",
      "signature": "kvm_mmu_set_mmio_spte_mask",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_mask",
      "signature": "mmio_mask",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_mask",
      "signature": "mmio_spte_mask",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_caching",
      "signature": "mmio_caching",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_can_emulate_event_vectoring",
      "signature": "kvm_can_emulate_event_vectoring",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vcpu_can_access_host_mmio",
      "signature": "bool kvm_vcpu_can_access_host_mmio(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_LOW_START",
      "signature": "MMIO_SPTE_GEN_LOW_START",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_LOW_END",
      "signature": "MMIO_SPTE_GEN_LOW_END",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_HIGH_START",
      "signature": "MMIO_SPTE_GEN_HIGH_START",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_HIGH_END",
      "signature": "MMIO_SPTE_GEN_HIGH_END",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_LOW_MASK",
      "signature": "MMIO_SPTE_GEN_LOW_MASK",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_HIGH_MASK",
      "signature": "MMIO_SPTE_GEN_HIGH_MASK",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_ALLOWED_MASK",
      "signature": "MMIO_ALLOWED_MASK",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_LOW_BITS",
      "signature": "define MMIO_SPTE_GEN_LOW_BITS (MMIO_SPTE_GEN_LOW_END - MMIO_SPTE_GEN_LOW_START + 1) #define MMIO_SPTE_GEN_HIGH_BITS (MMIO_SPTE_GEN_HIGH_END - MMIO_SPTE_GEN_HIGH_START + 1) /* remember to adjust the comment above as well if you change these */ static_assert(MMIO_SPTE_GEN_LOW_BITS == 8 && MMIO_SPTE_GEN_HIGH_BITS == 11); #define MMIO_SPTE_GEN_LOW_SHIFT (MMIO_SPTE_GEN_LOW_START - 0) #define MMIO_SPTE_GEN_HIGH_SHIFT (MMIO_SPTE_GEN_HIGH_START - MMIO_SPTE_GEN_LOW_BITS) #define MMIO_SPTE_GEN_MASK GENMASK_ULL(MMIO_SPTE_GEN_LOW_BITS + MMIO_SPTE_GEN_HIGH_BITS - 1, 0) /* * Non-present SPTE value needs to set bit 63 for TDX, in order to suppress * #VE and get EPT violations on non-present PTEs. We can use the * same value also without TDX for both VMX and SVM: * * For SVM NPT, for non-present spte (bit 0 = 0), other bits are ignored. * For VMX EPT, bit 63 is ignored if #VE is disabled. (EPT_VIOLATION_VE=0) * bit 63 is #VE suppress if #VE is enabled. (EPT_VIOLATION_VE=1) */ #ifdef CONFIG_X86_64 #define SHADOW_NONPRESENT_VALUE BIT_ULL(63) static_assert(!(SHADOW_NONPRESENT_VALUE & SPTE_MMU_PRESENT_MASK)); #else #define SHADOW_NONPRESENT_VALUE 0ULL #endif /* * True if A/D bits are supported in hardware and are enabled by KVM. When * enabled, KVM uses A/D bits for all non-nested MMUs. Because L1 can disable * A/D bits in EPTP12, SP and SPTE variants are needed to handle the scenario * where KVM is using A/D bits for L1, but not L2. */ extern bool __read_mostly kvm_ad_enabled; extern u64 __read_mostly shadow_host_writable_mask; extern u64 __read_mostly shadow_mmu_writable_mask; extern u64 __read_mostly shadow_nx_mask; extern u64 __read_mostly shadow_x_mask; /* mutual exclusive with nx_mask */ extern u64 __read_mostly shadow_user_mask; extern u64 __read_mostly shadow_accessed_mask; extern u64 __read_mostly shadow_dirty_mask; extern u64 __read_mostly shadow_mmio_value; extern u64 __read_mostly shadow_mmio_mask; extern u64 __read_mostly shadow_mmio_access_mask; extern u64 __read_mostly shadow_present_mask; extern u64 __read_mostly shadow_me_value; extern u64 __read_mostly shadow_me_mask; /* * SPTEs in MMUs without A/D bits are marked with SPTE_TDP_AD_DISABLED; * shadow_acc_track_mask is the set of bits to be cleared in non-accessed * pages. */ extern u64 __read_mostly shadow_acc_track_mask; /* * This mask must be set on all non-zero Non-Present or Reserved SPTEs in order * to guard against L1TF attacks. */ extern u64 __read_mostly shadow_nonpresent_or_rsvd_mask; /* * The number of high-order 1 bits to use in the mask above. */ #define SHADOW_NONPRESENT_OR_RSVD_MASK_LEN 5 /* * If a thread running without exclusive control of the MMU lock must perform a * multi-part operation on an SPTE, it can set the SPTE to FROZEN_SPTE as a * non-present intermediate value. Other threads which encounter this value * should not modify the SPTE. * * Use a semi-arbitrary value that doesn't set RWX bits, i.e. is not-present on * both AMD and Intel CPUs, and doesn't set PFN bits, i.e. doesn't create a L1TF * vulnerability. * * Only used by the TDP MMU. */ #define FROZEN_SPTE (SHADOW_NONPRESENT_VALUE | 0x5a0ULL) /* Frozen SPTEs must not be misconstrued as shadow present PTEs. */ static_assert(!(FROZEN_SPTE & SPTE_MMU_PRESENT_MASK)); static inline bool is_frozen_spte(u64 spte)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_HIGH_BITS",
      "signature": "define MMIO_SPTE_GEN_HIGH_BITS (MMIO_SPTE_GEN_HIGH_END - MMIO_SPTE_GEN_HIGH_START + 1) /* remember to adjust the comment above as well if you change these */ static_assert(MMIO_SPTE_GEN_LOW_BITS == 8 && MMIO_SPTE_GEN_HIGH_BITS == 11); #define MMIO_SPTE_GEN_LOW_SHIFT (MMIO_SPTE_GEN_LOW_START - 0) #define MMIO_SPTE_GEN_HIGH_SHIFT (MMIO_SPTE_GEN_HIGH_START - MMIO_SPTE_GEN_LOW_BITS) #define MMIO_SPTE_GEN_MASK GENMASK_ULL(MMIO_SPTE_GEN_LOW_BITS + MMIO_SPTE_GEN_HIGH_BITS - 1, 0) /* * Non-present SPTE value needs to set bit 63 for TDX, in order to suppress * #VE and get EPT violations on non-present PTEs. We can use the * same value also without TDX for both VMX and SVM: * * For SVM NPT, for non-present spte (bit 0 = 0), other bits are ignored. * For VMX EPT, bit 63 is ignored if #VE is disabled. (EPT_VIOLATION_VE=0) * bit 63 is #VE suppress if #VE is enabled. (EPT_VIOLATION_VE=1) */ #ifdef CONFIG_X86_64 #define SHADOW_NONPRESENT_VALUE BIT_ULL(63) static_assert(!(SHADOW_NONPRESENT_VALUE & SPTE_MMU_PRESENT_MASK)); #else #define SHADOW_NONPRESENT_VALUE 0ULL #endif /* * True if A/D bits are supported in hardware and are enabled by KVM. When * enabled, KVM uses A/D bits for all non-nested MMUs. Because L1 can disable * A/D bits in EPTP12, SP and SPTE variants are needed to handle the scenario * where KVM is using A/D bits for L1, but not L2. */ extern bool __read_mostly kvm_ad_enabled; extern u64 __read_mostly shadow_host_writable_mask; extern u64 __read_mostly shadow_mmu_writable_mask; extern u64 __read_mostly shadow_nx_mask; extern u64 __read_mostly shadow_x_mask; /* mutual exclusive with nx_mask */ extern u64 __read_mostly shadow_user_mask; extern u64 __read_mostly shadow_accessed_mask; extern u64 __read_mostly shadow_dirty_mask; extern u64 __read_mostly shadow_mmio_value; extern u64 __read_mostly shadow_mmio_mask; extern u64 __read_mostly shadow_mmio_access_mask; extern u64 __read_mostly shadow_present_mask; extern u64 __read_mostly shadow_me_value; extern u64 __read_mostly shadow_me_mask; /* * SPTEs in MMUs without A/D bits are marked with SPTE_TDP_AD_DISABLED; * shadow_acc_track_mask is the set of bits to be cleared in non-accessed * pages. */ extern u64 __read_mostly shadow_acc_track_mask; /* * This mask must be set on all non-zero Non-Present or Reserved SPTEs in order * to guard against L1TF attacks. */ extern u64 __read_mostly shadow_nonpresent_or_rsvd_mask; /* * The number of high-order 1 bits to use in the mask above. */ #define SHADOW_NONPRESENT_OR_RSVD_MASK_LEN 5 /* * If a thread running without exclusive control of the MMU lock must perform a * multi-part operation on an SPTE, it can set the SPTE to FROZEN_SPTE as a * non-present intermediate value. Other threads which encounter this value * should not modify the SPTE. * * Use a semi-arbitrary value that doesn't set RWX bits, i.e. is not-present on * both AMD and Intel CPUs, and doesn't set PFN bits, i.e. doesn't create a L1TF * vulnerability. * * Only used by the TDP MMU. */ #define FROZEN_SPTE (SHADOW_NONPRESENT_VALUE | 0x5a0ULL) /* Frozen SPTEs must not be misconstrued as shadow present PTEs. */ static_assert(!(FROZEN_SPTE & SPTE_MMU_PRESENT_MASK)); static inline bool is_frozen_spte(u64 spte)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_LOW_SHIFT",
      "signature": "define MMIO_SPTE_GEN_LOW_SHIFT (MMIO_SPTE_GEN_LOW_START - 0) #define MMIO_SPTE_GEN_HIGH_SHIFT (MMIO_SPTE_GEN_HIGH_START - MMIO_SPTE_GEN_LOW_BITS) #define MMIO_SPTE_GEN_MASK GENMASK_ULL(MMIO_SPTE_GEN_LOW_BITS + MMIO_SPTE_GEN_HIGH_BITS - 1, 0) /* * Non-present SPTE value needs to set bit 63 for TDX, in order to suppress * #VE and get EPT violations on non-present PTEs. We can use the * same value also without TDX for both VMX and SVM: * * For SVM NPT, for non-present spte (bit 0 = 0), other bits are ignored. * For VMX EPT, bit 63 is ignored if #VE is disabled. (EPT_VIOLATION_VE=0) * bit 63 is #VE suppress if #VE is enabled. (EPT_VIOLATION_VE=1) */ #ifdef CONFIG_X86_64 #define SHADOW_NONPRESENT_VALUE BIT_ULL(63) static_assert(!(SHADOW_NONPRESENT_VALUE & SPTE_MMU_PRESENT_MASK)); #else #define SHADOW_NONPRESENT_VALUE 0ULL #endif /* * True if A/D bits are supported in hardware and are enabled by KVM. When * enabled, KVM uses A/D bits for all non-nested MMUs. Because L1 can disable * A/D bits in EPTP12, SP and SPTE variants are needed to handle the scenario * where KVM is using A/D bits for L1, but not L2. */ extern bool __read_mostly kvm_ad_enabled; extern u64 __read_mostly shadow_host_writable_mask; extern u64 __read_mostly shadow_mmu_writable_mask; extern u64 __read_mostly shadow_nx_mask; extern u64 __read_mostly shadow_x_mask; /* mutual exclusive with nx_mask */ extern u64 __read_mostly shadow_user_mask; extern u64 __read_mostly shadow_accessed_mask; extern u64 __read_mostly shadow_dirty_mask; extern u64 __read_mostly shadow_mmio_value; extern u64 __read_mostly shadow_mmio_mask; extern u64 __read_mostly shadow_mmio_access_mask; extern u64 __read_mostly shadow_present_mask; extern u64 __read_mostly shadow_me_value; extern u64 __read_mostly shadow_me_mask; /* * SPTEs in MMUs without A/D bits are marked with SPTE_TDP_AD_DISABLED; * shadow_acc_track_mask is the set of bits to be cleared in non-accessed * pages. */ extern u64 __read_mostly shadow_acc_track_mask; /* * This mask must be set on all non-zero Non-Present or Reserved SPTEs in order * to guard against L1TF attacks. */ extern u64 __read_mostly shadow_nonpresent_or_rsvd_mask; /* * The number of high-order 1 bits to use in the mask above. */ #define SHADOW_NONPRESENT_OR_RSVD_MASK_LEN 5 /* * If a thread running without exclusive control of the MMU lock must perform a * multi-part operation on an SPTE, it can set the SPTE to FROZEN_SPTE as a * non-present intermediate value. Other threads which encounter this value * should not modify the SPTE. * * Use a semi-arbitrary value that doesn't set RWX bits, i.e. is not-present on * both AMD and Intel CPUs, and doesn't set PFN bits, i.e. doesn't create a L1TF * vulnerability. * * Only used by the TDP MMU. */ #define FROZEN_SPTE (SHADOW_NONPRESENT_VALUE | 0x5a0ULL) /* Frozen SPTEs must not be misconstrued as shadow present PTEs. */ static_assert(!(FROZEN_SPTE & SPTE_MMU_PRESENT_MASK)); static inline bool is_frozen_spte(u64 spte)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_HIGH_SHIFT",
      "signature": "define MMIO_SPTE_GEN_HIGH_SHIFT (MMIO_SPTE_GEN_HIGH_START - MMIO_SPTE_GEN_LOW_BITS) #define MMIO_SPTE_GEN_MASK GENMASK_ULL(MMIO_SPTE_GEN_LOW_BITS + MMIO_SPTE_GEN_HIGH_BITS - 1, 0) /* * Non-present SPTE value needs to set bit 63 for TDX, in order to suppress * #VE and get EPT violations on non-present PTEs. We can use the * same value also without TDX for both VMX and SVM: * * For SVM NPT, for non-present spte (bit 0 = 0), other bits are ignored. * For VMX EPT, bit 63 is ignored if #VE is disabled. (EPT_VIOLATION_VE=0) * bit 63 is #VE suppress if #VE is enabled. (EPT_VIOLATION_VE=1) */ #ifdef CONFIG_X86_64 #define SHADOW_NONPRESENT_VALUE BIT_ULL(63) static_assert(!(SHADOW_NONPRESENT_VALUE & SPTE_MMU_PRESENT_MASK)); #else #define SHADOW_NONPRESENT_VALUE 0ULL #endif /* * True if A/D bits are supported in hardware and are enabled by KVM. When * enabled, KVM uses A/D bits for all non-nested MMUs. Because L1 can disable * A/D bits in EPTP12, SP and SPTE variants are needed to handle the scenario * where KVM is using A/D bits for L1, but not L2. */ extern bool __read_mostly kvm_ad_enabled; extern u64 __read_mostly shadow_host_writable_mask; extern u64 __read_mostly shadow_mmu_writable_mask; extern u64 __read_mostly shadow_nx_mask; extern u64 __read_mostly shadow_x_mask; /* mutual exclusive with nx_mask */ extern u64 __read_mostly shadow_user_mask; extern u64 __read_mostly shadow_accessed_mask; extern u64 __read_mostly shadow_dirty_mask; extern u64 __read_mostly shadow_mmio_value; extern u64 __read_mostly shadow_mmio_mask; extern u64 __read_mostly shadow_mmio_access_mask; extern u64 __read_mostly shadow_present_mask; extern u64 __read_mostly shadow_me_value; extern u64 __read_mostly shadow_me_mask; /* * SPTEs in MMUs without A/D bits are marked with SPTE_TDP_AD_DISABLED; * shadow_acc_track_mask is the set of bits to be cleared in non-accessed * pages. */ extern u64 __read_mostly shadow_acc_track_mask; /* * This mask must be set on all non-zero Non-Present or Reserved SPTEs in order * to guard against L1TF attacks. */ extern u64 __read_mostly shadow_nonpresent_or_rsvd_mask; /* * The number of high-order 1 bits to use in the mask above. */ #define SHADOW_NONPRESENT_OR_RSVD_MASK_LEN 5 /* * If a thread running without exclusive control of the MMU lock must perform a * multi-part operation on an SPTE, it can set the SPTE to FROZEN_SPTE as a * non-present intermediate value. Other threads which encounter this value * should not modify the SPTE. * * Use a semi-arbitrary value that doesn't set RWX bits, i.e. is not-present on * both AMD and Intel CPUs, and doesn't set PFN bits, i.e. doesn't create a L1TF * vulnerability. * * Only used by the TDP MMU. */ #define FROZEN_SPTE (SHADOW_NONPRESENT_VALUE | 0x5a0ULL) /* Frozen SPTEs must not be misconstrued as shadow present PTEs. */ static_assert(!(FROZEN_SPTE & SPTE_MMU_PRESENT_MASK)); static inline bool is_frozen_spte(u64 spte)",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_MASK",
      "signature": "MMIO_SPTE_GEN_MASK",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_value",
      "signature": "mmio_value",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_mask",
      "signature": "mmio_mask",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_access_mask",
      "signature": "mmio_access_mask",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte",
      "signature": "mmio_spte",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_caching",
      "signature": "mmio_caching",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_generation",
      "signature": "mmio_spte_generation",
      "file": "arch/x86/kvm/mmu/spte.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_gengenMMIO_SPTE_GEN_MASK",
      "signature": "kvm_gengenMMIO_SPTE_GEN_MASK",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_invalidate_mmio_sptes",
      "signature": "void kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, u64 gen)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_debug_ratelimitedzappingshadowpagesformmio",
      "signature": "kvm_debug_ratelimitedzappingshadowpagesformmio",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte",
      "signature": "mmio_spte",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_gfn",
      "signature": "mmio_spte_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_access",
      "signature": "mmio_spte_access",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_access_mask",
      "signature": "mmio_access_mask",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_MASK",
      "signature": "MMIO_SPTE_GEN_MASK",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_generation",
      "signature": "mmio_spte_generation",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_created",
      "signature": "mmio_spte_created",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_info",
      "signature": "mmio_info",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_caching",
      "signature": "mmio_caching",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_GVA_ANY",
      "signature": "MMIO_GVA_ANY",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_info_in_cache",
      "signature": "bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gpa",
      "signature": "mmio_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_gva",
      "signature": "mmio_gva",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_page_fault",
      "signature": "mmio_page_fault",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_value",
      "signature": "mmio_value",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_sptes",
      "signature": "mmio_sptes",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "handle_mmio",
      "signature": "handle_mmio",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_page_fault",
      "signature": "mmio_page_fault",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "mmio_pio"
    },
    {
      "function": "handle_mmio",
      "signature": "handle_mmio",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte",
      "signature": "mmio_spte",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_generation",
      "signature": "mmio_spte_generation",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_page_fault",
      "signature": "mmio_page_fault",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "mmio_pio"
    },
    {
      "function": "handle_mmio",
      "signature": "handle_mmio",
      "file": "arch/x86/kvm/mmu/mmutrace.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALenable_mmio_caching",
      "signature": "KVM_INTERNALenable_mmio_caching",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vcpu_memslotsvcpugenerationMMIO_SPTE_GEN_MASK",
      "signature": "kvm_vcpu_memslotsvcpugenerationMMIO_SPTE_GEN_MASK",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_is_mmio_pfn",
      "signature": "bool kvm_is_mmio_pfn(kvm_pfn_t pfn, int *is_host_mmio)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_is_mmio_pfnkvm_pfn_tpfnintis_host_mmio",
      "signature": "kvm_is_mmio_pfnkvm_pfn_tpfnintis_host_mmio",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_track_host_mmio_mapping",
      "signature": "void kvm_track_host_mmio_mapping(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_is_mmio_pfnpfnis_host_mmio",
      "signature": "kvm_is_mmio_pfnpfnis_host_mmio",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vcpu_can_access_host_mmio",
      "signature": "kvm_vcpu_can_access_host_mmio",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_masku64mmio_valueu64mmio_mask",
      "signature": "kvm_mmu_set_mmio_spte_masku64mmio_valueu64mmio_mask",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_mmu_set_mmio_spte_mask",
      "signature": "KVM_INTERNALkvm_mmu_set_mmio_spte_mask",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_valuestructkvmkvmu64mmio_value",
      "signature": "kvm_mmu_set_mmio_spte_valuestructkvmkvmu64mmio_value",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_INTERNALkvm_mmu_set_mmio_spte_value",
      "signature": "KVM_INTERNALkvm_mmu_set_mmio_spte_value",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_mask",
      "signature": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_value, u64 mmio_mask, u64 access_mask)",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_caching",
      "signature": "mmio_caching",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_value",
      "signature": "mmio_value",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_mask",
      "signature": "mmio_mask",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_access_mask",
      "signature": "mmio_access_mask",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_mask",
      "signature": "mmio_spte_mask",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_MASK",
      "signature": "MMIO_SPTE_GEN_MASK",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_LOW_SHIFT",
      "signature": "MMIO_SPTE_GEN_LOW_SHIFT",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_LOW_MASK",
      "signature": "MMIO_SPTE_GEN_LOW_MASK",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_HIGH_SHIFT",
      "signature": "MMIO_SPTE_GEN_HIGH_SHIFT",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SPTE_GEN_HIGH_MASK",
      "signature": "MMIO_SPTE_GEN_HIGH_MASK",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte",
      "signature": "mmio_spte",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_pfn",
      "signature": "mmio_pfn",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_mapping",
      "signature": "mmio_mapping",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_ALLOWED_MASK",
      "signature": "MMIO_ALLOWED_MASK",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_value",
      "signature": "mmio_spte_value",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte",
      "signature": "mmio_spte",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_created",
      "signature": "mmio_spte_created",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte",
      "signature": "mmio_spte",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_value",
      "signature": "kvm_mmu_set_mmio_spte_value",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_writevcpuKVM_FAST_MMIO_BUS",
      "signature": "kvm_io_bus_writevcpuKVM_FAST_MMIO_BUS",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_mmio",
      "signature": "kvm_fast_mmio",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "signature": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_writevcpuKVM_MMIO_BUS",
      "signature": "kvm_io_bus_writevcpuKVM_MMIO_BUS",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_readvcpuKVM_MMIO_BUS",
      "signature": "kvm_io_bus_readvcpuKVM_MMIO_BUS",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_EXIT_MMIO",
      "signature": "KVM_EXIT_MMIO",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_spte_value",
      "signature": "mmio_spte_value",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_out",
      "signature": "pio_out",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_in",
      "signature": "pio_in",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_in_emulated",
      "signature": "pio_in_emulated",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_out_emulated",
      "signature": "pio_out_emulated",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_read",
      "signature": "mmio_read",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_fragments",
      "signature": "mmio_fragments",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_READ",
      "signature": "MMIO_READ",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_write",
      "signature": "mmio_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_BUS",
      "signature": "MMIO_BUS",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_WRITE",
      "signature": "MMIO_WRITE",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_is_write",
      "signature": "mmio_is_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_READ_UNSATISFIED",
      "signature": "MMIO_READ_UNSATISFIED",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_needed",
      "signature": "mmio_needed",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_caching",
      "signature": "mmio_caching",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vcpuvcpugfn_tgfnboolis_mmio",
      "signature": "kvm_vcpuvcpugfn_tgfnboolis_mmio",
      "file": "arch/x86/kvm/vmx/x86_ops.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vcpu_can_access_host_mmio",
      "signature": "kvm_vcpu_can_access_host_mmio",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_pio",
      "signature": "return kvm_fast_pio(vcpu, size, port, in); } void vmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_bus_writevcpuKVM_FAST_MMIO_BUS",
      "signature": "kvm_io_bus_writevcpuKVM_FAST_MMIO_BUS",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_fast_mmio",
      "signature": "kvm_fast_mmio",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vcpuvcpugfn_tgfnboolis_mmio",
      "signature": "kvm_vcpuvcpugfn_tgfnboolis_mmio",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_needed",
      "signature": "mmio_needed",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_BUS",
      "signature": "MMIO_BUS",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_can_emulate_event_vectoring",
      "signature": "kvm_can_emulate_event_vectoring",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_needed",
      "signature": "mmio_needed",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_SHIFT",
      "signature": "MMIO_SHIFT",
      "file": "arch/x86/kvm/vmx/run_flags.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_init",
      "signature": "kvm_coalesced_mmio_init",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_free",
      "signature": "kvm_coalesced_mmio_free",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_PIO_PAGE_OFFSET",
      "signature": "KVM_PIO_PAGE_OFFSET",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_MMIO",
      "signature": "KVM_MMIO",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_COALESCED_MMIO_PAGE_OFFSET",
      "signature": "KVM_COALESCED_MMIO_PAGE_OFFSET",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_CAP_COALESCED_MMIO",
      "signature": "KVM_CAP_COALESCED_MMIO",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_CAP_COALESCED_PIO",
      "signature": "KVM_CAP_COALESCED_PIO",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_REGISTER_COALESCED_MMIO",
      "signature": "KVM_REGISTER_COALESCED_MMIO",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_zone",
      "signature": "kvm_coalesced_mmio_zone",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vm_ioctl_register_coalesced_mmio",
      "signature": "kvm_vm_ioctl_register_coalesced_mmio",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_UNREGISTER_COALESCED_MMIO",
      "signature": "KVM_UNREGISTER_COALESCED_MMIO",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vm_ioctl_unregister_coalesced_mmio",
      "signature": "kvm_vm_ioctl_unregister_coalesced_mmio",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_init",
      "signature": "mmio_init",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_free",
      "signature": "mmio_free",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_PAGE_OFFSET",
      "signature": "PIO_PAGE_OFFSET",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "pio_data",
      "signature": "pio_data",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_PAGE_OFFSET",
      "signature": "MMIO_PAGE_OFFSET",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_ring",
      "signature": "mmio_ring",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_zone",
      "signature": "mmio_zone",
      "file": "virt/kvm/kvm_main.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_COALESCED_MMIO_H__",
      "signature": "KVM_COALESCED_MMIO_H__",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_MMIO",
      "signature": "KVM_MMIO",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_dev",
      "signature": "kvm_coalesced_mmio_dev",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_zone",
      "signature": "kvm_coalesced_mmio_zone",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_init",
      "signature": "int kvm_coalesced_mmio_init(struct kvm *kvm); void kvm_coalesced_mmio_free(struct kvm *kvm); int kvm_vm_ioctl_register_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone); int kvm_vm_ioctl_unregister_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone); #else static inline int kvm_coalesced_mmio_init(struct kvm *kvm)",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_free",
      "signature": "void kvm_coalesced_mmio_free(struct kvm *kvm); int kvm_vm_ioctl_register_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone); int kvm_vm_ioctl_unregister_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone); #else static inline int kvm_coalesced_mmio_init(struct kvm *kvm)",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vm_ioctl_register_coalesced_mmio",
      "signature": "int kvm_vm_ioctl_register_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone); int kvm_vm_ioctl_unregister_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone); #else static inline int kvm_coalesced_mmio_init(struct kvm *kvm)",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vm_ioctl_unregister_coalesced_mmio",
      "signature": "int kvm_vm_ioctl_unregister_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone); #else static inline int kvm_coalesced_mmio_init(struct kvm *kvm)",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_H__",
      "signature": "MMIO_H__",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_dev",
      "signature": "mmio_dev",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_zone",
      "signature": "mmio_zone",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_init",
      "signature": "mmio_init",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_free",
      "signature": "mmio_free",
      "file": "virt/kvm/coalesced_mmio.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_devto_mmio",
      "signature": "kvm_coalesced_mmio_devto_mmio",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_dev",
      "signature": "kvm_coalesced_mmio_dev",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_devdevto_mmio",
      "signature": "kvm_coalesced_mmio_devdevto_mmio",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_ringringdevkvmcoalesced_mmio_ring",
      "signature": "kvm_coalesced_mmio_ringringdevkvmcoalesced_mmio_ring",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_COALESCED_MMIO_MAX",
      "signature": "KVM_COALESCED_MMIO_MAX",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_io_device_opscoalesced_mmio_ops",
      "signature": "kvm_io_device_opscoalesced_mmio_ops",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_init",
      "signature": "int kvm_coalesced_mmio_init(struct kvm *kvm)",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_free",
      "signature": "void kvm_coalesced_mmio_free(struct kvm *kvm)",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vm_ioctl_register_coalesced_mmio",
      "signature": "int kvm_vm_ioctl_register_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone)",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_zone",
      "signature": "kvm_coalesced_mmio_zone",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_iodevice_initdevdevcoalesced_mmio_ops",
      "signature": "kvm_iodevice_initdevdevcoalesced_mmio_ops",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_PIO_BUSKVM_MMIO_BUS",
      "signature": "KVM_PIO_BUSKVM_MMIO_BUS",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_vm_ioctl_unregister_coalesced_mmio",
      "signature": "int kvm_vm_ioctl_unregister_coalesced_mmio(struct kvm *kvm, struct kvm_coalesced_mmio_zone *zone)",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_dev",
      "signature": "mmio_dev",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_in_range",
      "signature": "mmio_in_range",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_write",
      "signature": "mmio_write",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_ring",
      "signature": "mmio_ring",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_MAX",
      "signature": "MMIO_MAX",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_destructor",
      "signature": "mmio_destructor",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_ops",
      "signature": "mmio_ops",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_init",
      "signature": "mmio_init",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_free",
      "signature": "mmio_free",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_zone",
      "signature": "mmio_zone",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_BUS",
      "signature": "PIO_BUS",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_BUS",
      "signature": "MMIO_BUS",
      "file": "virt/kvm/coalesced_mmio.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_IOEVENTFD_FLAG_PIO",
      "signature": "KVM_IOEVENTFD_FLAG_PIO",
      "file": "virt/kvm/eventfd.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_PIO_BUS",
      "signature": "KVM_PIO_BUS",
      "file": "virt/kvm/eventfd.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_MMIO_BUS",
      "signature": "KVM_MMIO_BUS",
      "file": "virt/kvm/eventfd.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_deassign_ioeventfd_idxkvmKVM_FAST_MMIO_BUS",
      "signature": "kvm_deassign_ioeventfd_idxkvmKVM_FAST_MMIO_BUS",
      "file": "virt/kvm/eventfd.c",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_assign_ioeventfd_idxkvmKVM_FAST_MMIO_BUS",
      "signature": "kvm_assign_ioeventfd_idxkvmKVM_FAST_MMIO_BUS",
      "file": "virt/kvm/eventfd.c",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_BUS",
      "signature": "PIO_BUS",
      "file": "virt/kvm/eventfd.c",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_BUS",
      "signature": "MMIO_BUS",
      "file": "virt/kvm/eventfd.c",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_MAX_MMIO_FRAGMENTS",
      "signature": "KVM_MAX_MMIO_FRAGMENTS",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_MMIO_BUS",
      "signature": "KVM_MMIO_BUS",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_PIO_BUS",
      "signature": "KVM_PIO_BUS",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_FAST_MMIO_BUS",
      "signature": "KVM_FAST_MMIO_BUS",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmio_fragment",
      "signature": "kvm_mmio_fragment",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_mmio_fragmentmmio_fragmentsKVM_MAX_MMIO_FRAGMENTS",
      "signature": "kvm_mmio_fragmentmmio_fragmentsKVM_MAX_MMIO_FRAGMENTS",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_MMIO",
      "signature": "KVM_MMIO",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_ringcoalesced_mmio_ring",
      "signature": "kvm_coalesced_mmio_ringcoalesced_mmio_ring",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_FRAGMENTS",
      "signature": "MMIO_FRAGMENTS",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_BUS",
      "signature": "MMIO_BUS",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "PIO_BUS",
      "signature": "PIO_BUS",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_fragment",
      "signature": "mmio_fragment",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_needed",
      "signature": "mmio_needed",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_read_completed",
      "signature": "mmio_read_completed",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_is_write",
      "signature": "mmio_is_write",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_cur_fragment",
      "signature": "mmio_cur_fragment",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_nr_fragments",
      "signature": "mmio_nr_fragments",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_fragments",
      "signature": "mmio_fragments",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_ring",
      "signature": "mmio_ring",
      "file": "include/linux/kvm_host.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_EXIT_MMIO",
      "signature": "KVM_EXIT_MMIO",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_REGISTER_COALESCED_MMIOKVM_UNREGISTER_COALESCED_MMIO",
      "signature": "KVM_REGISTER_COALESCED_MMIOKVM_UNREGISTER_COALESCED_MMIO",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_zone",
      "signature": "kvm_coalesced_mmio_zone",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio",
      "signature": "kvm_coalesced_mmio",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmio_ring",
      "signature": "kvm_coalesced_mmio_ring",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_coalesced_mmiocoalesced_mmio",
      "signature": "kvm_coalesced_mmiocoalesced_mmio",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_COALESCED_MMIO_MAX",
      "signature": "KVM_COALESCED_MMIO_MAX",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_ioeventfd_flag_nr_pio",
      "signature": "kvm_ioeventfd_flag_nr_pio",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "kvm_ioeventfd_flag_nr_fast_mmio",
      "signature": "kvm_ioeventfd_flag_nr_fast_mmio",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_IOEVENTFD_FLAG_PIO1kvm_ioeventfd_flag_nr_pio",
      "signature": "KVM_IOEVENTFD_FLAG_PIO1kvm_ioeventfd_flag_nr_pio",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_CAP_COALESCED_MMIO",
      "signature": "KVM_CAP_COALESCED_MMIO",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_CAP_COALESCED_PIO",
      "signature": "KVM_CAP_COALESCED_PIO",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_REGISTER_COALESCED_MMIO",
      "signature": "KVM_REGISTER_COALESCED_MMIO",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "KVM_UNREGISTER_COALESCED_MMIO",
      "signature": "KVM_UNREGISTER_COALESCED_MMIO",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_zone",
      "signature": "mmio_zone",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "mmio_ring",
      "signature": "mmio_ring",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    },
    {
      "function": "MMIO_MAX",
      "signature": "MMIO_MAX",
      "file": "include/uapi/linux/kvm.h",
      "category": "mmio_pio"
    }
  ],
  "guest_memory": [
    {
      "function": "guest_state_protected0kvm_rip_read",
      "signature": "guest_state_protected0kvm_rip_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "guest_memory"
    },
    {
      "function": "guest_riptracing_kvm_rip_read",
      "signature": "guest_riptracing_kvm_rip_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "guest_memory"
    },
    {
      "function": "guest_tsckvm_read",
      "signature": "guest_tsckvm_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_srcu_read",
      "signature": "kvm_vcpu_srcu_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_read_guest_virt_helperaddrvalbytesvcpuaccess",
      "signature": "kvm_read_guest_virt_helperaddrvalbytesvcpuaccess",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write_guestvcpugpadatatowrite",
      "signature": "kvm_vcpu_write_guestvcpugpadatatowrite",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_can_read",
      "signature": "guest_can_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_virt_helperaddrvalbytesvcpuaccess",
      "signature": "guest_virt_helperaddrvalbytesvcpuaccess",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_tsckvm_read",
      "signature": "guest_tsckvm_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write",
      "signature": "kvm_vcpu_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_srcu_read",
      "signature": "kvm_vcpu_srcu_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_is_bspvcpukvm_rip_read",
      "signature": "kvm_vcpu_is_bspvcpukvm_rip_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write",
      "signature": "kvm_vcpu_write",
      "file": "arch/x86/kvm/smm.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "arch/x86/kvm/smm.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write",
      "signature": "kvm_vcpu_write",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_tsckvm_read",
      "signature": "guest_tsckvm_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_now__pvclock_read",
      "signature": "guest_now__pvclock_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write",
      "signature": "kvm_vcpu_write",
      "file": "arch/x86/kvm/xen.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_uaddrparamsguest_lennFOLL_WRITE",
      "signature": "guest_uaddrparamsguest_lennFOLL_WRITE",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_memfdhasnotalread",
      "signature": "guest_memfdhasnotalread",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_statetransitionsalread",
      "signature": "guest_statetransitionsalread",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_PAGE_MASKPFERR_WRITE",
      "signature": "GUEST_PAGE_MASKPFERR_WRITE",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write",
      "signature": "kvm_vcpu_write",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_ACCESSED_SHIFTPT_ACCESS",
      "signature": "GUEST_ACCESSED_SHIFTPT_ACCESS",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_ACCESS",
      "signature": "GUEST_ACCESS",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_ACCESSED_MASK1PT_GUEST_ACCESS",
      "signature": "GUEST_ACCESSED_MASK1PT_GUEST_ACCESS",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_DIRTY_SHIFTPT_GUEST_ACCESS",
      "signature": "GUEST_DIRTY_SHIFTPT_GUEST_ACCESS",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_DSretrievalfor64bitmodetoavoidVMREAD",
      "signature": "GUEST_DSretrievalfor64bitmodetoavoidVMREAD",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_debugctl_read",
      "signature": "guest_debugctl_read",
      "file": "arch/x86/kvm/vmx/pmu_intel.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_debugctl_write",
      "signature": "guest_debugctl_write",
      "file": "arch/x86/kvm/vmx/pmu_intel.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_FINAL_MASKPFERR_PRIVATE_ACCESS",
      "signature": "GUEST_FINAL_MASKPFERR_PRIVATE_ACCESS",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_debugctl_write",
      "signature": "guest_debugctl_write",
      "file": "arch/x86/kvm/vmx/vmx.h",
      "category": "guest_memory"
    },
    {
      "function": "guest_debugctl_read",
      "signature": "guest_debugctl_read",
      "file": "arch/x86/kvm/vmx/vmx.h",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_IA32_RTIT_CTLisalread",
      "signature": "GUEST_IA32_RTIT_CTLisalread",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_debugctl_read",
      "signature": "guest_debugctl_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_debugctl_write",
      "signature": "guest_debugctl_write",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_CR4vmcs_read",
      "signature": "GUEST_CR4vmcs_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_tr_arvmcs_read",
      "signature": "guest_tr_arvmcs_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_CR3isalread",
      "signature": "GUEST_CR3isalread",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_split_lockkvm_rip_read",
      "signature": "guest_split_lockkvm_rip_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_CR0vmcs_readlCR0_READ",
      "signature": "GUEST_CR0vmcs_readlCR0_READ",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_PDPTR0vmcs_read",
      "signature": "GUEST_PDPTR0vmcs_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_PDPTR2vmcs_read",
      "signature": "GUEST_PDPTR2vmcs_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_RSPvmcs_read",
      "signature": "GUEST_RSPvmcs_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_RFLAGSvmcs_read",
      "signature": "GUEST_RFLAGSvmcs_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_SYSENTER_CSvmcs_read",
      "signature": "GUEST_SYSENTER_CSvmcs_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_S_CETvmcs_read",
      "signature": "GUEST_S_CETvmcs_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_tsclkvm_read",
      "signature": "guest_tsclkvm_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_debugctl_write",
      "signature": "guest_debugctl_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_debugctl_read",
      "signature": "guest_debugctl_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_es_selectorvmcs_read",
      "signature": "guest_es_selectorvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_cs_selectorvmcs_read",
      "signature": "guest_cs_selectorvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ss_selectorvmcs_read",
      "signature": "guest_ss_selectorvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ds_selectorvmcs_read",
      "signature": "guest_ds_selectorvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_fs_selectorvmcs_read",
      "signature": "guest_fs_selectorvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_gs_selectorvmcs_read",
      "signature": "guest_gs_selectorvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ldtr_selectorvmcs_read",
      "signature": "guest_ldtr_selectorvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_tr_selectorvmcs_read",
      "signature": "guest_tr_selectorvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_es_limitvmcs_read",
      "signature": "guest_es_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_cs_limitvmcs_read",
      "signature": "guest_cs_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ss_limitvmcs_read",
      "signature": "guest_ss_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ds_limitvmcs_read",
      "signature": "guest_ds_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_fs_limitvmcs_read",
      "signature": "guest_fs_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_gs_limitvmcs_read",
      "signature": "guest_gs_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ldtr_limitvmcs_read",
      "signature": "guest_ldtr_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_tr_limitvmcs_read",
      "signature": "guest_tr_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_gdtr_limitvmcs_read",
      "signature": "guest_gdtr_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_idtr_limitvmcs_read",
      "signature": "guest_idtr_limitvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_es_ar_bytesvmcs_read",
      "signature": "guest_es_ar_bytesvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ds_ar_bytesvmcs_read",
      "signature": "guest_ds_ar_bytesvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_fs_ar_bytesvmcs_read",
      "signature": "guest_fs_ar_bytesvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_gs_ar_bytesvmcs_read",
      "signature": "guest_gs_ar_bytesvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ldtr_ar_bytesvmcs_read",
      "signature": "guest_ldtr_ar_bytesvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_tr_ar_bytesvmcs_read",
      "signature": "guest_tr_ar_bytesvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_es_basevmcs_read",
      "signature": "guest_es_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_cs_basevmcs_read",
      "signature": "guest_cs_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ss_basevmcs_read",
      "signature": "guest_ss_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ds_basevmcs_read",
      "signature": "guest_ds_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_fs_basevmcs_read",
      "signature": "guest_fs_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_gs_basevmcs_read",
      "signature": "guest_gs_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ldtr_basevmcs_read",
      "signature": "guest_ldtr_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_tr_basevmcs_read",
      "signature": "guest_tr_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_gdtr_basevmcs_read",
      "signature": "guest_gdtr_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_idtr_basevmcs_read",
      "signature": "guest_idtr_basevmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_rspkvm_rsp_read",
      "signature": "guest_rspkvm_rsp_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ripkvm_rip_read",
      "signature": "guest_ripkvm_rip_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_rflagsvmcs_read",
      "signature": "guest_rflagsvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_cs_ar_bytesvmcs_read",
      "signature": "guest_cs_ar_bytesvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_ss_ar_bytesvmcs_read",
      "signature": "guest_ss_ar_bytesvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_cr3vmcs_read",
      "signature": "guest_cr3vmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_pdptr0vmcs_read",
      "signature": "guest_pdptr0vmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_pdptr1vmcs_read",
      "signature": "guest_pdptr1vmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_pdptr2vmcs_read",
      "signature": "guest_pdptr2vmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_pdptr3vmcs_read",
      "signature": "guest_pdptr3vmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_linear_addressvmcs_read",
      "signature": "guest_linear_addressvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_intr_statusvmcs_read",
      "signature": "guest_intr_statusvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_HOST_MASKisalread",
      "signature": "GUEST_HOST_MASKisalread",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "guest_owned_bitsvmcs_read",
      "signature": "guest_owned_bitsvmcs_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_map_read",
      "signature": "kvm_vcpu_map_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write",
      "signature": "kvm_vcpu_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_MEMFDisincompatiblewithreadonlymemslotsaswrite",
      "signature": "GUEST_MEMFDisincompatiblewithreadonlymemslotsaswrite",
      "file": "virt/kvm/kvm_main.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "virt/kvm/kvm_main.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write",
      "signature": "kvm_vcpu_write",
      "file": "virt/kvm/kvm_main.c",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_stats_read",
      "signature": "ssize_t kvm_vcpu_stats_read(struct file *file, char __user *user_buffer, size_t size, loff_t *offset)",
      "file": "virt/kvm/kvm_main.c",
      "category": "guest_memory"
    },
    {
      "function": "GUEST_MODEcontextshouldholdaread",
      "signature": "GUEST_MODEcontextshouldholdaread",
      "file": "include/linux/kvm_host.h",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_srcu_read",
      "signature": "kvm_vcpu_srcu_read",
      "file": "include/linux/kvm_host.h",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_map_read",
      "signature": "kvm_vcpu_map_read",
      "file": "include/linux/kvm_host.h",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_read",
      "signature": "kvm_vcpu_read",
      "file": "include/linux/kvm_host.h",
      "category": "guest_memory"
    },
    {
      "function": "kvm_vcpu_write",
      "signature": "kvm_vcpu_write",
      "file": "include/linux/kvm_host.h",
      "category": "guest_memory"
    }
  ],
  "exported_symbols": [
    {
      "address": "ffffffff8d09a740",
      "type": "t",
      "name": "__pfx_kvm_sev_hc_page_enc_status",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8d09a750",
      "type": "t",
      "name": "kvm_sev_hc_page_enc_status",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8d09a9e0",
      "type": "t",
      "name": "__pfx_kvm_guest_apic_eoi_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8d09a9f0",
      "type": "t",
      "name": "kvm_guest_apic_eoi_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8d09b3d0",
      "type": "t",
      "name": "__pfx_kvm_disable_host_haltpoll",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8d09b3e0",
      "type": "t",
      "name": "kvm_disable_host_haltpoll",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8d09b410",
      "type": "t",
      "name": "__pfx_kvm_enable_host_haltpoll",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8d09b420",
      "type": "t",
      "name": "kvm_enable_host_haltpoll",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8e07d740",
      "type": "T",
      "name": "__pfx_kvm_read_and_reset_apf_flags",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8e07d750",
      "type": "T",
      "name": "kvm_read_and_reset_apf_flags",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8e07d970",
      "type": "t",
      "name": "__pfx_kvm_sched_clock_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8e07d980",
      "type": "t",
      "name": "kvm_sched_clock_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffff8eb0db98",
      "type": "r",
      "name": "__ksymtab_kvm_read_and_reset_apf_flags",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e427",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_gfn_to_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e43b",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_gfn_to_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e492",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_gfn_to_pfn_atomic",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e4ad",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_gfn_to_pfn_atomic",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e4ba",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_gfn_to_pfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e4ce",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_gfn_to_pfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e513",
      "type": "r",
      "name": "__kstrtab_kvm_release_page_clean",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e52a",
      "type": "r",
      "name": "__kstrtabns_kvm_release_page_clean",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e52b",
      "type": "r",
      "name": "__kstrtab_kvm_release_pfn_clean",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e541",
      "type": "r",
      "name": "__kstrtabns_kvm_release_pfn_clean",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e542",
      "type": "r",
      "name": "__kstrtab_kvm_release_page_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e559",
      "type": "r",
      "name": "__kstrtabns_kvm_release_page_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e55a",
      "type": "r",
      "name": "__kstrtab_kvm_release_pfn_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e570",
      "type": "r",
      "name": "__kstrtabns_kvm_release_pfn_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e571",
      "type": "r",
      "name": "__kstrtab_kvm_set_pfn_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e583",
      "type": "r",
      "name": "__kstrtabns_kvm_set_pfn_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e584",
      "type": "r",
      "name": "__kstrtab_kvm_set_pfn_accessed",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e599",
      "type": "r",
      "name": "__kstrtabns_kvm_set_pfn_accessed",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e59a",
      "type": "r",
      "name": "__kstrtab_kvm_read_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e5ae",
      "type": "r",
      "name": "__kstrtabns_kvm_read_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e5af",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_read_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e5c8",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_read_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e5c9",
      "type": "r",
      "name": "__kstrtab_kvm_read_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e5d8",
      "type": "r",
      "name": "__kstrtabns_kvm_read_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e5d9",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_read_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e5ed",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_read_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e5ee",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_read_guest_atomic",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e609",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_read_guest_atomic",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e60a",
      "type": "r",
      "name": "__kstrtab_kvm_write_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e61f",
      "type": "r",
      "name": "__kstrtabns_kvm_write_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e620",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_write_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e63a",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_write_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e63b",
      "type": "r",
      "name": "__kstrtab_kvm_write_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e64b",
      "type": "r",
      "name": "__kstrtabns_kvm_write_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e64c",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_write_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e661",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_write_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e662",
      "type": "r",
      "name": "__kstrtab_kvm_gfn_to_hva_cache_init",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e67c",
      "type": "r",
      "name": "__kstrtabns_kvm_gfn_to_hva_cache_init",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e67d",
      "type": "r",
      "name": "__kstrtab_kvm_write_guest_offset_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e69b",
      "type": "r",
      "name": "__kstrtabns_kvm_write_guest_offset_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e69c",
      "type": "r",
      "name": "__kstrtab_kvm_write_guest_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e6b3",
      "type": "r",
      "name": "__kstrtabns_kvm_write_guest_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e6b4",
      "type": "r",
      "name": "__kstrtab_kvm_read_guest_offset_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e6d1",
      "type": "r",
      "name": "__kstrtabns_kvm_read_guest_offset_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e6d2",
      "type": "r",
      "name": "__kstrtab_kvm_read_guest_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e6e8",
      "type": "r",
      "name": "__kstrtabns_kvm_read_guest_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e724",
      "type": "r",
      "name": "__kstrtab_kvm_vcpu_mark_page_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e73d",
      "type": "r",
      "name": "__kstrtabns_kvm_vcpu_mark_page_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e7cb",
      "type": "r",
      "name": "__kstrtab_kvm_io_bus_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082e7dc",
      "type": "r",
      "name": "__kstrtabns_kvm_io_bus_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082ea90",
      "type": "r",
      "name": "__kstrtab_kvm_inject_emulated_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082eaaf",
      "type": "r",
      "name": "__kstrtabns_kvm_inject_emulated_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082eb42",
      "type": "r",
      "name": "__kstrtab_kvm_load_host_xsave_state",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082eb5c",
      "type": "r",
      "name": "__kstrtabns_kvm_load_host_xsave_state",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082ecee",
      "type": "r",
      "name": "__kstrtab_kvm_read_l1_tsc",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082ecfe",
      "type": "r",
      "name": "__kstrtabns_kvm_read_l1_tsc",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082ed89",
      "type": "r",
      "name": "__kstrtab_kvm_mmu_gva_to_gpa_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082eda1",
      "type": "r",
      "name": "__kstrtabns_kvm_mmu_gva_to_gpa_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082eda2",
      "type": "r",
      "name": "__kstrtab_kvm_mmu_gva_to_gpa_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082edbb",
      "type": "r",
      "name": "__kstrtabns_kvm_mmu_gva_to_gpa_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082edbc",
      "type": "r",
      "name": "__kstrtab_kvm_read_guest_virt",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082edd0",
      "type": "r",
      "name": "__kstrtabns_kvm_read_guest_virt",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082edd1",
      "type": "r",
      "name": "__kstrtab_kvm_write_guest_virt_system",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082eded",
      "type": "r",
      "name": "__kstrtabns_kvm_write_guest_virt_system",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082eef4",
      "type": "r",
      "name": "__kstrtab_kvm_fast_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082ef01",
      "type": "r",
      "name": "__kstrtabns_kvm_fast_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f1f5",
      "type": "r",
      "name": "__kstrtab_kvm_sev_es_mmio_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f20b",
      "type": "r",
      "name": "__kstrtabns_kvm_sev_es_mmio_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f20c",
      "type": "r",
      "name": "__kstrtab_kvm_sev_es_mmio_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f221",
      "type": "r",
      "name": "__kstrtabns_kvm_sev_es_mmio_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f2fa",
      "type": "r",
      "name": "__kstrtab___tracepoint_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f315",
      "type": "r",
      "name": "__kstrtabns___tracepoint_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f316",
      "type": "r",
      "name": "__kstrtab___traceiter_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f330",
      "type": "r",
      "name": "__kstrtabns___traceiter_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f331",
      "type": "r",
      "name": "__kstrtab___SCK__tp_func_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f34e",
      "type": "r",
      "name": "__kstrtabns___SCK__tp_func_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f34f",
      "type": "r",
      "name": "__kstrtab___SCT__tp_func_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f36c",
      "type": "r",
      "name": "__kstrtabns___SCT__tp_func_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f3dc",
      "type": "r",
      "name": "__kstrtab___tracepoint_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f3f8",
      "type": "r",
      "name": "__kstrtabns___tracepoint_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f3f9",
      "type": "r",
      "name": "__kstrtab___traceiter_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f414",
      "type": "r",
      "name": "__kstrtabns___traceiter_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f415",
      "type": "r",
      "name": "__kstrtab___SCK__tp_func_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f433",
      "type": "r",
      "name": "__kstrtabns___SCK__tp_func_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f434",
      "type": "r",
      "name": "__kstrtab___SCT__tp_func_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f452",
      "type": "r",
      "name": "__kstrtabns___SCT__tp_func_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f94d",
      "type": "r",
      "name": "__kstrtab___tracepoint_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f96f",
      "type": "r",
      "name": "__kstrtabns___tracepoint_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f970",
      "type": "r",
      "name": "__kstrtab___traceiter_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f991",
      "type": "r",
      "name": "__kstrtabns___traceiter_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f992",
      "type": "r",
      "name": "__kstrtab___SCK__tp_func_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f9b6",
      "type": "r",
      "name": "__kstrtabns___SCK__tp_func_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f9b7",
      "type": "r",
      "name": "__kstrtab___SCT__tp_func_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc082f9db",
      "type": "r",
      "name": "__kstrtabns___SCT__tp_func_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0830259",
      "type": "r",
      "name": "__kstrtab_kvm_lapic_readable_reg_mask",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0830275",
      "type": "r",
      "name": "__kstrtabns_kvm_lapic_readable_reg_mask",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc08302bc",
      "type": "r",
      "name": "__kstrtab_kvm_apic_write_nodecode",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc08302d4",
      "type": "r",
      "name": "__kstrtabns_kvm_apic_write_nodecode",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc08302d5",
      "type": "r",
      "name": "__kstrtab_kvm_alloc_apic_access_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc08302f0",
      "type": "r",
      "name": "__kstrtabns_kvm_alloc_apic_access_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0830401",
      "type": "r",
      "name": "__kstrtab_kvm_hv_assist_page_enabled",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc083041c",
      "type": "r",
      "name": "__kstrtabns_kvm_hv_assist_page_enabled",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc083041d",
      "type": "r",
      "name": "__kstrtab_kvm_hv_get_assist_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0830434",
      "type": "r",
      "name": "__kstrtabns_kvm_hv_get_assist_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0830468",
      "type": "r",
      "name": "__kstrtab_kvm_handle_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc083047e",
      "type": "r",
      "name": "__kstrtabns_kvm_handle_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc08304e7",
      "type": "r",
      "name": "__kstrtab_kvm_mmu_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc08304fa",
      "type": "r",
      "name": "__kstrtabns_kvm_mmu_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc083054c",
      "type": "r",
      "name": "__kstrtab_kvm_mmu_set_mmio_spte_mask",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0830567",
      "type": "r",
      "name": "__kstrtabns_kvm_mmu_set_mmio_spte_mask",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5280",
      "type": "t",
      "name": "__pfx___kvm_write_track_remove_gfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b45b0",
      "type": "t",
      "name": "kvm_mmu_try_split_huge_pages",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5030",
      "type": "t",
      "name": "__pfx_kvm_page_track_write_tracking_enabled",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0753490",
      "type": "t",
      "name": "kvm_io_bus_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1870",
      "type": "t",
      "name": "__traceiter_kvm_mmu_pagetable_walk",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1c50",
      "type": "t",
      "name": "__traceiter_kvm_mmu_unsync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc076ca40",
      "type": "t",
      "name": "__pfx_kvm_sev_es_mmio_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07abb50",
      "type": "t",
      "name": "kvm_mmu_gfn_allow_lpage",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07504a0",
      "type": "t",
      "name": "kvm_vcpu_mark_page_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bba0",
      "type": "t",
      "name": "kvm_read_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1c40",
      "type": "t",
      "name": "__pfx___traceiter_kvm_mmu_unsync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0799270",
      "type": "t",
      "name": "kvm_vcpu_reserved_gpa_bits_raw",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07dbee0",
      "type": "d",
      "name": "__tracepoint_kvm_mmu_pagetable_walk",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbc98",
      "type": "t",
      "name": "__SCT__kvm_x86_write_tsc_multiplier",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0769480",
      "type": "t",
      "name": "__probestub_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a21a0",
      "type": "t",
      "name": "__traceiter_kvm_mmu_split_huge_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0766050",
      "type": "t",
      "name": "__pfx_kvm_mmu_gva_to_gpa_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c5d10",
      "type": "d",
      "name": "__SCK__tp_func_kvm_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b4c90",
      "type": "t",
      "name": "__pfx_kvm_mmu_invalidate_mmio_sptes",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744aa0",
      "type": "t",
      "name": "__pfx___traceiter_kvm_test_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077fe10",
      "type": "t",
      "name": "__pfx_kvm_arch_async_page_present_queued",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0758a70",
      "type": "t",
      "name": "__traceiter_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0756290",
      "type": "t",
      "name": "__pfx_kvm_vm_ioctl_unregister_coalesced_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07adbc0",
      "type": "t",
      "name": "__pfx_kvm_mmu_unprotect_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07503a0",
      "type": "t",
      "name": "kvm_vcpu_gfn_to_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0793370",
      "type": "t",
      "name": "__pfx_kvm_hv_vapic_msr_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb7c0",
      "type": "t",
      "name": "__SCT__tp_func_kvm_set_spte_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074c380",
      "type": "t",
      "name": "__pfx_kvm_release_page_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0790d20",
      "type": "t",
      "name": "__pfx_kvm_inhibit_apic_access_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbe20",
      "type": "t",
      "name": "__SCT__tp_func_kvm_mmu_pagetable_walk",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07adbd0",
      "type": "t",
      "name": "kvm_mmu_unprotect_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744a50",
      "type": "t",
      "name": "__traceiter_kvm_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07507b0",
      "type": "t",
      "name": "kvm_host_page_size",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb788",
      "type": "t",
      "name": "__SCT__tp_func_kvm_async_pf_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c6360",
      "type": "d",
      "name": "__SCK__kvm_x86_set_apic_access_page_addr",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750490",
      "type": "t",
      "name": "__pfx_kvm_vcpu_mark_page_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0765f40",
      "type": "t",
      "name": "__pfx_kvm_inject_emulated_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bf30",
      "type": "t",
      "name": "__pfx_kvm_write_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5150",
      "type": "t",
      "name": "kvm_page_track_write_tracking_alloc",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1bc0",
      "type": "t",
      "name": "__traceiter_kvm_mmu_sync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0758e20",
      "type": "t",
      "name": "__pfx___traceiter_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a2220",
      "type": "t",
      "name": "__probestub_kvm_mmu_split_huge_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb7d0",
      "type": "t",
      "name": "__SCT__tp_func_kvm_test_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07517b0",
      "type": "t",
      "name": "kvm_release_pfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07907c0",
      "type": "t",
      "name": "__pfx_kvm_x2apic_icr_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b45a0",
      "type": "t",
      "name": "__pfx_kvm_mmu_try_split_huge_pages",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0753370",
      "type": "t",
      "name": "kvm_io_bus_write_cookie",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074afd0",
      "type": "t",
      "name": "__pfx_kvm_set_pfn_accessed",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750440",
      "type": "t",
      "name": "kvm_vcpu_write_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1cb0",
      "type": "t",
      "name": "__traceiter_kvm_mmu_prepare_zap_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074b1d0",
      "type": "t",
      "name": "kvm_set_pfn_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744990",
      "type": "t",
      "name": "__traceiter_kvm_unmap_hva_range",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bdb0",
      "type": "t",
      "name": "kvm_read_guest_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074d7f0",
      "type": "t",
      "name": "kvm_pfn_to_refcounted_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0768340",
      "type": "t",
      "name": "__pfx_kvm_write_guest_virt_system",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c5d20",
      "type": "d",
      "name": "__SCK__tp_func_kvm_set_spte_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744680",
      "type": "t",
      "name": "__pfx___traceiter_kvm_async_pf_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0765ff0",
      "type": "t",
      "name": "kvm_mmu_gva_to_gpa_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c62c0",
      "type": "d",
      "name": "__SCK__kvm_x86_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0756080",
      "type": "t",
      "name": "__pfx_kvm_coalesced_mmio_init",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d55b0",
      "type": "d",
      "name": "__SCK__tp_func_kvm_mmu_sync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bed0",
      "type": "t",
      "name": "__pfx_kvm_write_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749080",
      "type": "t",
      "name": "__pfx___probestub_kvm_set_spte_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07dbd00",
      "type": "d",
      "name": "__tracepoint_kvm_mmu_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07dbbe0",
      "type": "d",
      "name": "__tracepoint_kvm_mmu_prepare_zap_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc079e1c0",
      "type": "t",
      "name": "__pfx_kvm_hv_setup_tsc_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07db5e0",
      "type": "d",
      "name": "__tracepoint_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbb58",
      "type": "t",
      "name": "__SCT__kvm_x86_flush_tlb_gva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0751380",
      "type": "t",
      "name": "kvm_vcpu_gfn_to_pfn_atomic",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a5ff0",
      "type": "t",
      "name": "__probestub_kvm_mmu_unsync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc079c0c0",
      "type": "t",
      "name": "kvm_hv_get_assist_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d55a0",
      "type": "d",
      "name": "__SCK__tp_func_kvm_mmu_unsync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a5fe0",
      "type": "t",
      "name": "__pfx___probestub_kvm_mmu_unsync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07ae7a0",
      "type": "t",
      "name": "__pfx_kvm_mmu_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0756160",
      "type": "t",
      "name": "kvm_vm_ioctl_register_coalesced_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc078d7e0",
      "type": "t",
      "name": "kvm_lapic_readable_reg_mask",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07598c0",
      "type": "t",
      "name": "__pfx___probestub_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744570",
      "type": "t",
      "name": "__traceiter_kvm_try_async_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0766060",
      "type": "t",
      "name": "kvm_mmu_gva_to_gpa_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5080",
      "type": "t",
      "name": "kvm_page_track_free_memslot",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0799260",
      "type": "t",
      "name": "__pfx_kvm_vcpu_reserved_gpa_bits_raw",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d96c0",
      "type": "d",
      "name": "__tracepoint_kvm_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d9780",
      "type": "d",
      "name": "__tracepoint_kvm_unmap_hva_range",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0768350",
      "type": "t",
      "name": "kvm_write_guest_virt_system",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0793380",
      "type": "t",
      "name": "kvm_hv_vapic_msr_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb808",
      "type": "t",
      "name": "__SCT__tp_func_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074b1c0",
      "type": "t",
      "name": "__pfx_kvm_set_pfn_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0766730",
      "type": "t",
      "name": "kvm_read_guest_virt",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077fbe0",
      "type": "t",
      "name": "__pfx_kvm_arch_async_page_present",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bf40",
      "type": "t",
      "name": "kvm_write_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07449e0",
      "type": "t",
      "name": "__pfx___traceiter_kvm_set_spte_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749460",
      "type": "t",
      "name": "__pfx___probestub_kvm_try_async_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0748c60",
      "type": "t",
      "name": "kvm_io_bus_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5410",
      "type": "t",
      "name": "kvm_mmu_set_mmio_spte_mask",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0757540",
      "type": "t",
      "name": "kvm_arch_allow_write_without_running_vcpu",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07539d0",
      "type": "t",
      "name": "__pfx_kvm_vm_create_worker_thread",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749590",
      "type": "t",
      "name": "__probestub_kvm_test_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07506e0",
      "type": "t",
      "name": "__pfx_kvm_vcpu_write_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a18d0",
      "type": "t",
      "name": "__probestub_kvm_mmu_pagetable_walk",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c5dc0",
      "type": "d",
      "name": "__SCK__tp_func_kvm_try_async_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc079e400",
      "type": "t",
      "name": "kvm_hv_request_tsc_page_update",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0758e90",
      "type": "t",
      "name": "__pfx___probestub_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07499c0",
      "type": "t",
      "name": "kvm_gfn_to_hva_cache_init",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c5d00",
      "type": "d",
      "name": "__SCK__tp_func_kvm_test_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b50c0",
      "type": "t",
      "name": "__pfx_kvm_page_track_create_memslot",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07abb10",
      "type": "t",
      "name": "__pfx_kvm_mmu_gfn_disallow_lpage",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0751370",
      "type": "t",
      "name": "__pfx_kvm_vcpu_gfn_to_pfn_atomic",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1c10",
      "type": "t",
      "name": "__pfx___probestub_kvm_mmu_sync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5140",
      "type": "t",
      "name": "__pfx_kvm_page_track_write_tracking_alloc",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07adb50",
      "type": "t",
      "name": "__pfx_kvm_mmu_change_mmu_pages",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1c20",
      "type": "t",
      "name": "__probestub_kvm_mmu_sync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744420",
      "type": "t",
      "name": "__pfx___traceiter_kvm_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744430",
      "type": "t",
      "name": "__traceiter_kvm_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07589b0",
      "type": "t",
      "name": "__traceiter_kvm_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b3a90",
      "type": "t",
      "name": "__pfx_kvm_mmu_track_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0790d30",
      "type": "t",
      "name": "kvm_inhibit_apic_access_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07dad40",
      "type": "d",
      "name": "__tracepoint_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c5d30",
      "type": "d",
      "name": "__SCK__tp_func_kvm_unmap_hva_range",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0756150",
      "type": "t",
      "name": "__pfx_kvm_vm_ioctl_register_coalesced_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bee0",
      "type": "t",
      "name": "kvm_write_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749550",
      "type": "t",
      "name": "__pfx___probestub_kvm_unmap_hva_range",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b4630",
      "type": "t",
      "name": "kvm_mmu_slot_try_split_huge_pages",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077aaa0",
      "type": "t",
      "name": "kvm_mmu_gva_to_gpa_system",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c6530",
      "type": "d",
      "name": "__SCK__kvm_x86_flush_tlb_gva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07507a0",
      "type": "t",
      "name": "__pfx_kvm_host_page_size",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b51b0",
      "type": "t",
      "name": "__kvm_write_track_add_gfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b4620",
      "type": "t",
      "name": "__pfx_kvm_mmu_slot_try_split_huge_pages",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bda0",
      "type": "t",
      "name": "__pfx_kvm_read_guest_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077fe20",
      "type": "t",
      "name": "kvm_arch_async_page_present_queued",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077fbf0",
      "type": "t",
      "name": "kvm_arch_async_page_present",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744ab0",
      "type": "t",
      "name": "__traceiter_kvm_test_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bcb0",
      "type": "t",
      "name": "kvm_read_guest_offset_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07539e0",
      "type": "t",
      "name": "kvm_vm_create_worker_thread",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a18c0",
      "type": "t",
      "name": "__pfx___probestub_kvm_mmu_pagetable_walk",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0792220",
      "type": "t",
      "name": "__pfx_kvm_apic_write_nodecode",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1ca0",
      "type": "t",
      "name": "__pfx___traceiter_kvm_mmu_prepare_zap_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750630",
      "type": "t",
      "name": "__pfx_kvm_vcpu_read_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bbf0",
      "type": "t",
      "name": "__pfx_kvm_read_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07732a0",
      "type": "t",
      "name": "kvm_load_host_xsave_state",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc078d7d0",
      "type": "t",
      "name": "__pfx_kvm_lapic_readable_reg_mask",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b9c30",
      "type": "t",
      "name": "__pfx_kvm_tdp_mmu_try_split_huge_pages",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07db3a0",
      "type": "d",
      "name": "__tracepoint_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749470",
      "type": "t",
      "name": "__probestub_kvm_try_async_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750550",
      "type": "t",
      "name": "kvm_vcpu_read_guest_atomic",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0756120",
      "type": "t",
      "name": "kvm_coalesced_mmio_free",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750540",
      "type": "t",
      "name": "__pfx_kvm_vcpu_read_guest_atomic",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc079e3f0",
      "type": "t",
      "name": "__pfx_kvm_hv_request_tsc_page_update",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0758a40",
      "type": "t",
      "name": "__probestub_kvm_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bca0",
      "type": "t",
      "name": "__pfx_kvm_read_guest_offset_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0793270",
      "type": "t",
      "name": "__pfx_kvm_x2apic_msr_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc075aff0",
      "type": "t",
      "name": "kvm_read_l1_tsc",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1b30",
      "type": "t",
      "name": "__traceiter_kvm_mmu_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b3e10",
      "type": "t",
      "name": "kvm_mmu_invpcid_gva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb7c8",
      "type": "t",
      "name": "__SCT__tp_func_kvm_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077fe50",
      "type": "t",
      "name": "__pfx_kvm_arch_can_dequeue_async_page_present",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074d770",
      "type": "t",
      "name": "kvm_is_zone_device_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc079bed0",
      "type": "t",
      "name": "__pfx_kvm_hv_assist_page_enabled",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07504e0",
      "type": "t",
      "name": "__pfx_kvm_vcpu_read_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07499b0",
      "type": "t",
      "name": "__pfx_kvm_gfn_to_hva_cache_init",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744690",
      "type": "t",
      "name": "__traceiter_kvm_async_pf_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750a00",
      "type": "t",
      "name": "kvm_vcpu_gfn_to_hva_prot",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbe50",
      "type": "t",
      "name": "__SCT__tp_func_kvm_mmu_sync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0759850",
      "type": "t",
      "name": "__pfx___traceiter_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744560",
      "type": "t",
      "name": "__pfx___traceiter_kvm_try_async_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d55c0",
      "type": "d",
      "name": "__SCK__tp_func_kvm_mmu_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074d7e0",
      "type": "t",
      "name": "__pfx_kvm_pfn_to_refcounted_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07512f0",
      "type": "t",
      "name": "kvm_vcpu_gfn_to_pfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc078d0e0",
      "type": "t",
      "name": "kvm_pic_read_irq",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07abd10",
      "type": "t",
      "name": "__pfx_kvm_mmu_slot_gfn_write_protect",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d2da0",
      "type": "d",
      "name": "__SCK__tp_func_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc078dd10",
      "type": "t",
      "name": "kvm_alloc_apic_access_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0758a30",
      "type": "t",
      "name": "__pfx___probestub_kvm_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5290",
      "type": "t",
      "name": "__kvm_write_track_remove_gfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c62b0",
      "type": "d",
      "name": "__SCK__kvm_x86_write_tsc_multiplier",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074d760",
      "type": "t",
      "name": "__pfx_kvm_is_zone_device_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d5590",
      "type": "d",
      "name": "__SCK__tp_func_kvm_mmu_prepare_zap_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbea8",
      "type": "t",
      "name": "__SCT__tp_func_kvm_mmu_split_huge_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5340",
      "type": "t",
      "name": "kvm_gfn_is_write_tracked",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077fe60",
      "type": "t",
      "name": "kvm_arch_can_dequeue_async_page_present",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744a40",
      "type": "t",
      "name": "__pfx___traceiter_kvm_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0757530",
      "type": "t",
      "name": "__pfx_kvm_arch_allow_write_without_running_vcpu",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbc40",
      "type": "t",
      "name": "__SCT__kvm_x86_set_apic_access_page_addr",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07db880",
      "type": "d",
      "name": "__tracepoint_kvm_mmu_split_huge_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1b90",
      "type": "t",
      "name": "__probestub_kvm_mmu_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0753360",
      "type": "t",
      "name": "__pfx_kvm_io_bus_write_cookie",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b3aa0",
      "type": "t",
      "name": "kvm_mmu_track_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bb90",
      "type": "t",
      "name": "__pfx_kvm_read_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0765f50",
      "type": "t",
      "name": "kvm_inject_emulated_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07dbc40",
      "type": "d",
      "name": "__tracepoint_kvm_mmu_unsync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07adb60",
      "type": "t",
      "name": "kvm_mmu_change_mmu_pages",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749050",
      "type": "t",
      "name": "__pfx___probestub_kvm_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074b800",
      "type": "t",
      "name": "__pfx_kvm_release_page_clean",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0769470",
      "type": "t",
      "name": "__pfx___probestub_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0756110",
      "type": "t",
      "name": "__pfx_kvm_coalesced_mmio_free",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07517a0",
      "type": "t",
      "name": "__pfx_kvm_release_pfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07504f0",
      "type": "t",
      "name": "kvm_vcpu_read_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074c110",
      "type": "t",
      "name": "__pfx_kvm_write_guest_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07578f0",
      "type": "t",
      "name": "__pfx_kvm_dirty_ring_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1b80",
      "type": "t",
      "name": "__pfx___probestub_kvm_mmu_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077fa80",
      "type": "t",
      "name": "__pfx_kvm_arch_async_page_not_present",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749500",
      "type": "t",
      "name": "__probestub_kvm_async_pf_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07db640",
      "type": "d",
      "name": "__tracepoint_kvm_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b9c40",
      "type": "t",
      "name": "kvm_tdp_mmu_try_split_huge_pages",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc075afe0",
      "type": "t",
      "name": "__pfx_kvm_read_l1_tsc",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0773290",
      "type": "t",
      "name": "__pfx_kvm_load_host_xsave_state",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a2210",
      "type": "t",
      "name": "__pfx___probestub_kvm_mmu_split_huge_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074b810",
      "type": "t",
      "name": "kvm_release_page_clean",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07449f0",
      "type": "t",
      "name": "__traceiter_kvm_set_spte_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a2190",
      "type": "t",
      "name": "__pfx___traceiter_kvm_mmu_split_huge_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07af020",
      "type": "t",
      "name": "kvm_handle_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d5610",
      "type": "d",
      "name": "__SCK__tp_func_kvm_mmu_pagetable_walk",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750430",
      "type": "t",
      "name": "__pfx_kvm_vcpu_write_guest_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07ae620",
      "type": "t",
      "name": "kvm_tdp_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b37e0",
      "type": "t",
      "name": "__pfx_kvm_arch_async_page_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07512e0",
      "type": "t",
      "name": "__pfx_kvm_vcpu_gfn_to_pfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bff0",
      "type": "t",
      "name": "__pfx_kvm_write_guest_offset_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749560",
      "type": "t",
      "name": "__probestub_kvm_unmap_hva_range",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0765fe0",
      "type": "t",
      "name": "__pfx_kvm_mmu_gva_to_gpa_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074d9d0",
      "type": "t",
      "name": "__pfx_kvm_release_pfn_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749060",
      "type": "t",
      "name": "__probestub_kvm_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1bb0",
      "type": "t",
      "name": "__pfx___traceiter_kvm_mmu_sync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0776920",
      "type": "t",
      "name": "__pfx_kvm_inject_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074c000",
      "type": "t",
      "name": "kvm_write_guest_offset_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1b20",
      "type": "t",
      "name": "__pfx___traceiter_kvm_mmu_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0793280",
      "type": "t",
      "name": "kvm_x2apic_msr_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07abb20",
      "type": "t",
      "name": "kvm_mmu_gfn_disallow_lpage",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc079c0b0",
      "type": "t",
      "name": "__pfx_kvm_hv_get_assist_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0758ea0",
      "type": "t",
      "name": "__probestub_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d9720",
      "type": "d",
      "name": "__tracepoint_kvm_set_spte_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07ae100",
      "type": "t",
      "name": "kvm_mmu_hugepage_adjust",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb760",
      "type": "t",
      "name": "__SCT__tp_func_kvm_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07ae0f0",
      "type": "t",
      "name": "__pfx_kvm_mmu_hugepage_adjust",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b4470",
      "type": "t",
      "name": "kvm_mmu_slot_remove_write_access",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d99c0",
      "type": "d",
      "name": "__tracepoint_kvm_async_pf_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07ae7b0",
      "type": "t",
      "name": "kvm_mmu_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07555c0",
      "type": "t",
      "name": "__pfx_kvm_stats_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc078dd00",
      "type": "t",
      "name": "__pfx_kvm_alloc_apic_access_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c5d90",
      "type": "d",
      "name": "__SCK__tp_func_kvm_async_pf_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0758e30",
      "type": "t",
      "name": "__traceiter_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0744980",
      "type": "t",
      "name": "__pfx___traceiter_kvm_unmap_hva_range",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d9660",
      "type": "d",
      "name": "__tracepoint_kvm_test_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749580",
      "type": "t",
      "name": "__pfx___probestub_kvm_test_age_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b4460",
      "type": "t",
      "name": "__pfx_kvm_mmu_slot_remove_write_access",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07c5de0",
      "type": "d",
      "name": "__SCK__tp_func_kvm_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07af010",
      "type": "t",
      "name": "__pfx_kvm_handle_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07444b0",
      "type": "t",
      "name": "__probestub_kvm_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc079bee0",
      "type": "t",
      "name": "kvm_hv_assist_page_enabled",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07933f0",
      "type": "t",
      "name": "__pfx_kvm_hv_vapic_msr_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0793310",
      "type": "t",
      "name": "kvm_x2apic_msr_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0756090",
      "type": "t",
      "name": "kvm_coalesced_mmio_init",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074afe0",
      "type": "t",
      "name": "kvm_set_pfn_accessed",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb7b8",
      "type": "t",
      "name": "__SCT__tp_func_kvm_unmap_hva_range",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d2e10",
      "type": "d",
      "name": "__SCK__tp_func_kvm_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbe60",
      "type": "t",
      "name": "__SCT__tp_func_kvm_mmu_prepare_zap_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb800",
      "type": "t",
      "name": "__SCT__tp_func_kvm_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07abd20",
      "type": "t",
      "name": "kvm_mmu_slot_gfn_write_protect",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750640",
      "type": "t",
      "name": "kvm_vcpu_read_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbe48",
      "type": "t",
      "name": "__SCT__tp_func_kvm_mmu_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07444a0",
      "type": "t",
      "name": "__pfx___probestub_kvm_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0793300",
      "type": "t",
      "name": "__pfx_kvm_x2apic_msr_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d2e00",
      "type": "d",
      "name": "__SCK__tp_func_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0766720",
      "type": "t",
      "name": "__pfx_kvm_read_guest_virt",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a6050",
      "type": "t",
      "name": "__probestub_kvm_mmu_prepare_zap_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b9ef0",
      "type": "t",
      "name": "__pfx_kvm_tdp_mmu_write_protect_gfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074bc00",
      "type": "t",
      "name": "kvm_read_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a6040",
      "type": "t",
      "name": "__pfx___probestub_kvm_mmu_prepare_zap_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074c120",
      "type": "t",
      "name": "kvm_write_guest_cached",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07abb40",
      "type": "t",
      "name": "__pfx_kvm_mmu_gfn_allow_lpage",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb770",
      "type": "t",
      "name": "__SCT__tp_func_kvm_try_async_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0750390",
      "type": "t",
      "name": "__pfx_kvm_vcpu_gfn_to_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074da20",
      "type": "t",
      "name": "__pfx_kvm_release_pfn_clean",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0793400",
      "type": "t",
      "name": "kvm_hv_vapic_msr_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0757900",
      "type": "t",
      "name": "kvm_dirty_ring_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb8c0",
      "type": "t",
      "name": "__SCT__tp_func_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07907d0",
      "type": "t",
      "name": "kvm_x2apic_icr_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d5500",
      "type": "d",
      "name": "__SCK__tp_func_kvm_mmu_split_huge_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b37f0",
      "type": "t",
      "name": "kvm_arch_async_page_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b4ca0",
      "type": "t",
      "name": "kvm_mmu_invalidate_mmio_sptes",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07598d0",
      "type": "t",
      "name": "__probestub_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d9ba0",
      "type": "d",
      "name": "__tracepoint_kvm_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b51a0",
      "type": "t",
      "name": "__pfx___kvm_write_track_add_gfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc078d0d0",
      "type": "t",
      "name": "__pfx_kvm_pic_read_irq",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbc90",
      "type": "t",
      "name": "__SCT__kvm_x86_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07dbca0",
      "type": "d",
      "name": "__tracepoint_kvm_mmu_sync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0773f40",
      "type": "t",
      "name": "kvm_fast_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077aa90",
      "type": "t",
      "name": "__pfx_kvm_mmu_gva_to_gpa_system",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0748c50",
      "type": "t",
      "name": "__pfx_kvm_io_bus_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5070",
      "type": "t",
      "name": "__pfx_kvm_page_track_free_memslot",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07a1860",
      "type": "t",
      "name": "__pfx___traceiter_kvm_mmu_pagetable_walk",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5330",
      "type": "t",
      "name": "__pfx_kvm_gfn_is_write_tracked",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07589a0",
      "type": "t",
      "name": "__pfx___traceiter_kvm_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d2c90",
      "type": "d",
      "name": "__SCK__tp_func_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b9f00",
      "type": "t",
      "name": "kvm_tdp_mmu_write_protect_gfn",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0759860",
      "type": "t",
      "name": "__traceiter_kvm_write_tsc_offset",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074da30",
      "type": "t",
      "name": "kvm_release_pfn_clean",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07555d0",
      "type": "t",
      "name": "kvm_stats_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bbe58",
      "type": "t",
      "name": "__SCT__tp_func_kvm_mmu_unsync_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc076bb20",
      "type": "t",
      "name": "kvm_sev_es_mmio_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc079e1d0",
      "type": "t",
      "name": "kvm_hv_setup_tsc_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07bb838",
      "type": "t",
      "name": "__SCT__tp_func_kvm_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0776930",
      "type": "t",
      "name": "kvm_inject_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074c390",
      "type": "t",
      "name": "kvm_release_page_dirty",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5400",
      "type": "t",
      "name": "__pfx_kvm_mmu_set_mmio_spte_mask",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07ae610",
      "type": "t",
      "name": "__pfx_kvm_tdp_page_fault",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0773f30",
      "type": "t",
      "name": "__pfx_kvm_fast_pio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0753480",
      "type": "t",
      "name": "__pfx_kvm_io_bus_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07562a0",
      "type": "t",
      "name": "kvm_vm_ioctl_unregister_coalesced_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07506f0",
      "type": "t",
      "name": "kvm_vcpu_write_guest",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc076ca50",
      "type": "t",
      "name": "kvm_sev_es_mmio_write",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07d9ae0",
      "type": "d",
      "name": "__tracepoint_kvm_try_async_get_page",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0758a60",
      "type": "t",
      "name": "__pfx___traceiter_kvm_fast_mmio",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07509f0",
      "type": "t",
      "name": "__pfx_kvm_vcpu_gfn_to_hva_prot",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07494f0",
      "type": "t",
      "name": "__pfx___probestub_kvm_async_pf_ready",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b5040",
      "type": "t",
      "name": "kvm_page_track_write_tracking_enabled",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b3e00",
      "type": "t",
      "name": "__pfx_kvm_mmu_invpcid_gva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc076bb10",
      "type": "t",
      "name": "__pfx_kvm_sev_es_mmio_read",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc077fa90",
      "type": "t",
      "name": "kvm_arch_async_page_not_present",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0749090",
      "type": "t",
      "name": "__probestub_kvm_set_spte_hva",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc07b50d0",
      "type": "t",
      "name": "kvm_page_track_create_memslot",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc0792230",
      "type": "t",
      "name": "kvm_apic_write_nodecode",
      "source": "/proc/kallsyms"
    },
    {
      "address": "ffffffffc074d9e0",
      "type": "t",
      "name": "kvm_release_pfn_dirty",
      "source": "/proc/kallsyms"
    }
  ],
  "ioctl_handlers": [
    {
      "ioctl": "KVM_STATS_TYPE_INSTANT",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_MR_CREATE",
      "handler": "kvm_free_memslot",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_MR_MOVE",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_SET_DEVICE_ATTR",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_CAP_USER_MEMORY",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_CAP_NR_MEMSLOTS",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_CAP_DIRTY_LOG_RING",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_CREATE_VCPU",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_IRQ_LINE_STATUS",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_CHECK_EXTENSION",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_GET_API_VERSION",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_CREATE_VM",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_STAT_VM",
      "handler": "if",
      "file": "virt/kvm/kvm_main.c"
    },
    {
      "ioctl": "KVM_STAT_VM",
      "handler": "__simple_attr_check_format",
      "file": "virt/kvm/kvm_main.c"
    }
  ],
  "vmx_handlers": [
    {
      "function": "handle_rmode_exception",
      "signature": "int handle_rmode_exception(struct kvm_vcpu *vcpu, int vec, u32 err_code)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_machine_check",
      "signature": "int handle_machine_check(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_exception_nmi",
      "signature": "int handle_exception_nmi(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_triple_fault",
      "signature": "int handle_triple_fault(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_io",
      "signature": "int handle_io(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_set_cr0",
      "signature": "int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_set_cr4",
      "signature": "int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_desc",
      "signature": "int handle_desc(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_cr",
      "signature": "int handle_cr(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_dr",
      "signature": "int handle_dr(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_tpr_below_threshold",
      "signature": "int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_interrupt_window",
      "signature": "int handle_interrupt_window(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_invlpg",
      "signature": "int handle_invlpg(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_apic_access",
      "signature": "int handle_apic_access(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_apic_eoi_induced",
      "signature": "int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_apic_write",
      "signature": "int handle_apic_write(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_task_switch",
      "signature": "int handle_task_switch(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_ept_violation",
      "signature": "int handle_ept_violation(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_ept_misconfig",
      "signature": "int handle_ept_misconfig(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_nmi_window",
      "signature": "int handle_nmi_window(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_invalid_guest_state",
      "signature": "int handle_invalid_guest_state(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_pause",
      "signature": "int handle_pause(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_monitor_trap",
      "signature": "int handle_monitor_trap(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_invpcid",
      "signature": "int handle_invpcid(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_pml_full",
      "signature": "int handle_pml_full(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_preemption_timer",
      "signature": "int handle_preemption_timer(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_vmx_instruction",
      "signature": "int handle_vmx_instruction(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_tdx_instruction",
      "signature": "int handle_tdx_instruction(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_encls",
      "signature": "int handle_encls(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_bus_lock_vmexit",
      "signature": "int handle_bus_lock_vmexit(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_notify",
      "signature": "int handle_notify(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_rdmsr_imm",
      "signature": "int handle_rdmsr_imm(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "handle_wrmsr_imm",
      "signature": "int handle_wrmsr_imm(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    },
    {
      "function": "__vmx_handle_exit",
      "signature": "int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "type": "vmx_exit_handler"
    }
  ],
  "svm_handlers": [
    {
      "function": "svm_handle_invalid_exit",
      "signature": "int svm_handle_invalid_exit(struct kvm_vcpu *vcpu, u64 exit_code)",
      "file": "arch/x86/kvm/svm/svm.c",
      "type": "svm_exit_handler"
    },
    {
      "function": "svm_handle_exit",
      "signature": "int svm_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)",
      "file": "arch/x86/kvm/svm/svm.c",
      "type": "svm_exit_handler"
    }
  ],
  "summary": {
    "total_functions": 2894,
    "categories": {
      "memory_read": 397,
      "memory_write": 281,
      "page_operations": 1138,
      "address_conversion": 104,
      "mmio_pio": 365,
      "guest_memory": 115,
      "exported_symbols": 444,
      "ioctl_handlers": 14,
      "vmx_handlers": 34,
      "svm_handlers": 2
    }
  }
}
