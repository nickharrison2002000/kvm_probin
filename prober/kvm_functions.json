{
  "memory_read": [
    {
      "function": "guest_cpuid_hasstructkvm_vcpuvcpuunsignedintx86_featureconststructcpuid_regcpuidx86_feature_cpuidx86_featurestructkvm_cpuid_entry2entryu32regXSAVESisaspecialsnowflakeDuetolackofadedicatedinterceptonSVMKVMmustassumethatXSAVESandthusXRSTORSisusablebytheguestifthehostsupportsXSAVESandXSAVEisexposedtotheguestBecausetheguestcanexecuteXSAVESandXRSTORSiecanindirectlyconsumeXSSKVMmustensureXSSiszeroedwhenrunningtheguestiemustsetXSAVESinvCPUcapabilitiesButtorejectdirectXSSreadsandwritestominimizethevirt",
      "signature": "guest_cpuid_hasstructkvm_vcpuvcpuunsignedintx86_featureconststructcpuid_regcpuidx86_feature_cpuidx86_featurestructkvm_cpuid_entry2entryu32regXSAVESisaspecialsnowflakeDuetolackofadedicatedinterceptonSVMKVMmustassumethatXSAVESandthusXRSTORSisusablebytheguestifthehostsupportsXSAVESandXSAVEisexposedtotheguestBecausetheguestcanexecuteXSAVESandXRSTORSiecanindirectlyconsumeXSSKVMmustensureXSSiszeroedwhenrunningtheguestiemustsetXSAVESinvCPUcapabilitiesButtorejectdirectXSSreadsandwritestominimizethevirt",
      "file": "arch/x86/kvm/cpuid.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_cpu_capsNR_KVM_CPU_CAPS__read_mostly",
      "signature": "kvm_cpu_capsNR_KVM_CPU_CAPS__read_mostly",
      "file": "arch/x86/kvm/cpuid.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_msr_read",
      "signature": "int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_vapic_msr_read",
      "signature": "int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_readable_reg_mask",
      "signature": "u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "int kvm_read_guest_virt(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception); int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception); int handle_ud(struct kvm_vcpu *vcpu); void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu, struct kvm_queued_exception *ex); int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata); void kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code); int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type, void *insn, int insn_len); int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, int emulation_type, void *insn, int insn_len); fastpath_t handle_fastpath_wrmsr(struct kvm_vcpu *vcpu); fastpath_t handle_fastpath_wrmsr_imm(struct kvm_vcpu *vcpu, u32 msr, int reg); fastpath_t handle_fastpath_hlt(struct kvm_vcpu *vcpu); fastpath_t handle_fastpath_invd(struct kvm_vcpu *vcpu); extern struct kvm_caps kvm_caps; extern struct kvm_host_values kvm_host; extern bool enable_pmu; /* * Get a filtered version of KVM's supported XCR0 that strips out dynamic * features for which the current process doesn't (yet)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "long kvm_register_read(struct kvm_vcpu *vcpu, int reg)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read_raw",
      "signature": "kvm_register_read_raw",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size, unsigned int port, void *data, unsigned int count, int in); static inline bool user_exit_on_hypercall(struct kvm *kvm, unsigned long hc_nr)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virt",
      "signature": "read_guest_virt",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_read"
    },
    {
      "function": "KVM_HdefinedTRACE_HEADER_MULTI_READ",
      "signature": "KVM_HdefinedTRACE_HEADER_MULTI_READ",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_apic_read",
      "signature": "kvm_apic_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read",
      "signature": "kvm_msr_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read_ex",
      "signature": "kvm_msr_read_ex",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_cr_read",
      "signature": "kvm_cr_read",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "return kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val, sizeof(*val)); } static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_msr_read",
      "signature": "int kvm_lapic_msr_read(struct kvm_lapic *apic, u32 reg, u64 *data); static int kvm_lapic_msr_write(struct kvm_lapic *apic, u32 reg, u64 data); static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_make_requestKVM_REQ_APF_READY",
      "signature": "kvm_make_requestKVM_REQ_APF_READY",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_readable_reg_mask",
      "signature": "u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_lapic_readable_reg_mask",
      "signature": "KVM_INTERNALkvm_lapic_readable_reg_mask",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_reg_read",
      "signature": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len, void *data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_apic_read",
      "signature": "kvm_apic_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_icr_read",
      "signature": "u64 kvm_x2apic_icr_read(struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_icr_writeapickvm_x2apic_icr_read",
      "signature": "kvm_x2apic_icr_writeapickvm_x2apic_icr_read",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_unlock",
      "signature": "kvm_vcpu_srcu_read_unlock",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_lock",
      "signature": "kvm_vcpu_srcu_read_lock",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_msr_read",
      "signature": "int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_vapic_msr_read",
      "signature": "int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_read"
    },
    {
      "function": "read_emulatedstructx86_emulate_ctxtctxtunsignedlongaddrvoiddestunsignedsizeintrcstructread_cachemcctxtmem",
      "signature": "read_emulatedstructx86_emulate_ctxtctxtunsignedlongaddrvoiddestunsignedsizeintrcstructread_cachemcctxtmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "em_lgdt_lidtstructx86_emulate_ctxtctxtboollgdtstructdesc_ptrdesc_ptrintrcifctxtmodeX86EMUL_MODE_PROT64ctxtop_bytes8rcread_descriptorctxtctxtsrcaddrmem",
      "signature": "em_lgdt_lidtstructx86_emulate_ctxtctxtboollgdtstructdesc_ptrdesc_ptrintrcifctxtmodeX86EMUL_MODE_PROT64ctxtop_bytes8rcread_descriptorctxtctxtsrcaddrmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "em_fxrstorstructx86_emulate_ctxtctxtstructfxregs_statefx_stateintrcsize_tsizerccheck_fxsrctxtifrcX86EMUL_CONTINUEreturnrcsizefxstate_sizectxtrcsegmented_read_stdctxtctxtmemopaddrmem",
      "signature": "em_fxrstorstructx86_emulate_ctxtctxtstructfxregs_statefx_stateintrcsize_tsizerccheck_fxsrctxtifrcX86EMUL_CONTINUEreturnrcsizefxstate_sizectxtrcsegmented_read_stdctxtctxtmemopaddrmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "ifctxtmemoptypeOP_REGctxtmemopaddrregdecode_registerctxtctxtmodrm_rmtruefetch_register_operandctxtmem",
      "signature": "ifctxtmemoptypeOP_REGctxtmemopaddrregdecode_registerctxtctxtmodrm_rmtruefetch_register_operandctxtmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "ifctxtsrc2typeOP_MEMrcsegmented_readctxtctxtsrc2addrmem",
      "signature": "ifctxtsrc2typeOP_MEMrcsegmented_readctxtctxtsrc2addrmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_sse_reg",
      "signature": "kvm_read_sse_reg",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_mmx_reg",
      "signature": "kvm_read_mmx_reg",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0_bits",
      "signature": "ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "ulong kvm_read_cr0(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4_bits",
      "signature": "ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "ulong kvm_read_cr3(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "ulong kvm_read_cr4(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_edx_eax",
      "signature": "u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_lname_read",
      "signature": "kvm_lname_read",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read_raw",
      "signature": "long kvm_register_read_raw(struct kvm_vcpu *vcpu, int reg)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "long kvm_rip_read(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsp_read",
      "signature": "long kvm_rsp_read(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_pdptr_read",
      "signature": "u64 kvm_pdptr_read(struct kvm_vcpu *vcpu, int index)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/hyperv.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_pmu_emulated_event_selectors__read_mostly",
      "signature": "kvm_pmu_emulated_event_selectors__read_mostly",
      "file": "arch/x86/kvm/pmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pmu_opskvm_pmu_ops__read_mostly",
      "signature": "kvm_pmu_opskvm_pmu_ops__read_mostly",
      "file": "arch/x86/kvm/pmu.c",
      "category": "memory_read"
    },
    {
      "function": "load_pdptrsstructkvm_vcpuvcpuunsignedlongcr3structkvm_mmummuvcpuarchwalk_mmugfn_tpdpt_gfncr3PAGE_SHIFTgpa_treal_gpaintiintretu64pdpteARRAY_SIZEmmupdptrsIftheMMUisnestedCR3holdsanL2GPAandneedstobetranslatedtoanL1GPAreal_gpakvm_translate_gpavcpummugfn_to_gpapdpt_gfnPFERR_USER_MASKPFERR_WRITE_MASKNULLifreal_gpaINVALID_GPAreturn0NotetheoffsetPDPTRsare32bytealignedwhenusingPAEpagingretkvm_vcpu_read_guest_pagevcpugpa_to_gfnreal_gpa",
      "signature": "load_pdptrsstructkvm_vcpuvcpuunsignedlongcr3structkvm_mmummuvcpuarchwalk_mmugfn_tpdpt_gfncr3PAGE_SHIFTgpa_treal_gpaintiintretu64pdpteARRAY_SIZEmmupdptrsIftheMMUisnestedCR3holdsanL2GPAandneedstobetranslatedtoanL1GPAreal_gpakvm_translate_gpavcpummugfn_to_gpapdpt_gfnPFERR_USER_MASKPFERR_WRITE_MASKNULLifreal_gpaINVALID_GPAreturn0NotetheoffsetPDPTRsare32bytealignedwhenusingPAEpagingretkvm_vcpu_read_guest_pagevcpugpa_to_gfnreal_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt_helpergva_taddrvoidvalunsignedintbytesstructkvm_vcpuvcpuu64accessstructx86_exceptionexceptionstructkvm_mmummuvcpuarchwalk_mmuvoiddatavalintrX86EMUL_CONTINUEwhilebytesgpa_tgpammugva_to_gpavcpummuaddraccessexceptionunsignedoffsetaddrPAGE_SIZE1unsignedtoreadminbytesunsignedPAGE_SIZEoffsetintretifgpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULTretkvm_vcpu_read_guest_pagevcpugpa",
      "signature": "kvm_read_guest_virt_helpergva_taddrvoidvalunsignedintbytesstructkvm_vcpuvcpuu64accessstructx86_exceptionexceptionstructkvm_mmummuvcpuarchwalk_mmuvoiddatavalintrX86EMUL_CONTINUEwhilebytesgpa_tgpammugva_to_gpavcpummuaddraccessexceptionunsignedoffsetaddrPAGE_SIZE1unsignedtoreadminbytesunsignedPAGE_SIZEoffsetintretifgpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULTretkvm_vcpu_read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_fetch_guest_virtstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionstructkvm_vcpuvcpuemul_to_vcpuctxtstructkvm_mmummuvcpuarchwalk_mmuu64accesskvm_x86_callget_cplvcpu3PFERR_USER_MASK0unsignedoffsetintretInlinekvm_read_guest_virt_helperforspeedgpa_tgpammugva_to_gpavcpummuaddraccessPFERR_FETCH_MASKexceptionifunlikelygpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULToffsetaddrPAGE_SIZE1ifWARN_ONoffsetbytesPAGE_SIZEbytesunsignedPAGE_SIZEoffsetretkvm_vcpu_read_guest_pagevcpugpa",
      "signature": "kvm_fetch_guest_virtstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionstructkvm_vcpuvcpuemul_to_vcpuctxtstructkvm_mmummuvcpuarchwalk_mmuu64accesskvm_x86_callget_cplvcpu3PFERR_USER_MASK0unsignedoffsetintretInlinekvm_read_guest_virt_helperforspeedgpa_tgpammugva_to_gpavcpummuaddraccessPFERR_FETCH_MASKexceptionifunlikelygpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULToffsetaddrPAGE_SIZE1ifWARN_ONoffsetbytesPAGE_SIZEbytesunsignedPAGE_SIZEoffsetretkvm_vcpu_read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virtstructkvm_vcpuvcpugva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionu64accesskvm_x86_callget_cplvcpu3PFERR_USER_MASK0FIXMEthisshouldcallhandle_emulation_failureifX86EMUL_IO_NEEDEDisreturnedbutourcallersarenotreadyforthatandtheyblindlycallkvm_inject_page_faultEnsurethattheyatleastdonotleakuninitializedkernelstackmemoryintocr2anderrorcodememsetexception0sizeofexceptionreturnkvm_read_guest_virt",
      "signature": "kvm_read_guest_virtstructkvm_vcpuvcpugva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionu64accesskvm_x86_callget_cplvcpu3PFERR_USER_MASK0FIXMEthisshouldcallhandle_emulation_failureifX86EMUL_IO_NEEDEDisreturnedbutourcallersarenotreadyforthatandtheyblindlycallkvm_inject_page_faultEnsurethattheyatleastdonotleakuninitializedkernelstackmemoryintocr2anderrorcodememsetexception0sizeofexceptionreturnkvm_read_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "emulator_read_stdstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionboolsystemstructkvm_vcpuvcpuemul_to_vcpuctxtu64access0ifsystemaccessPFERR_IMPLICIT_ACCESSelseifkvm_x86_callget_cplvcpu3accessPFERR_USER_MASKreturnkvm_read_guest_virt",
      "signature": "emulator_read_stdstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionboolsystemstructkvm_vcpuvcpuemul_to_vcpuctxtu64access0ifsystemaccessPFERR_IMPLICIT_ACCESSelseifkvm_x86_callget_cplvcpu3accessPFERR_USER_MASKreturnkvm_read_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_emulatestructkvm_vcpuvcpugpa_tgpavoidvalintbytesreturnkvm_vcpu_read_guestvcpugpa",
      "signature": "read_emulatestructkvm_vcpuvcpugpa_tgpavoidvalintbytesreturnkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_exit_mmiostructkvm_vcpuvcpugpa_tgpavoidvalintbytestrace_kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIEDbytesgpa",
      "signature": "read_exit_mmiostructkvm_vcpuvcpugpa_tgpavoidvalintbytestrace_kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIEDbytesgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "emulator_read_write_onepageunsignedlongaddrvoidvalunsignedintbytesstructx86_exceptionexceptionstructkvm_vcpuvcpuconststructread_write_emulator_opsopsgpa_tgpainthandledretboolwriteopswritestructkvm_mmio_fragmentfragstructx86_emulate_ctxtctxtvcpuarchemulate_ctxtIftheexitwasduetoaNPFwemayalreadyhaveaGPA",
      "signature": "emulator_read_write_onepageunsignedlongaddrvoidvalunsignedintbytesstructx86_exceptionexceptionstructkvm_vcpuvcpuconststructread_write_emulator_opsopsgpa_tgpainthandledretboolwriteopswritestructkvm_mmio_fragmentfragstructx86_emulate_ctxtctxtvcpuarchemulate_ctxtIftheexitwasduetoaNPFwemayalreadyhaveaGPA",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_update_cpu_dirty_loggingstructkvmkvmboolenableintnr_slotsifkvmarchcpu_dirty_log_sizereturnnr_slotsatomic_readkvmnr_mem",
      "signature": "kvm_mmu_update_cpu_dirty_loggingstructkvmkvmboolenableintnr_slotsifkvmarchcpu_dirty_log_sizereturnnr_slotsatomic_readkvmnr_mem",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_writestructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledwrite_emultorread_write_mmiovcpugpa",
      "signature": "kvm_sev_es_mmio_writestructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledwrite_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_readstructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledread_emultorread_write_mmiovcpugpa",
      "signature": "kvm_sev_es_mmio_readstructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledread_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0_bits",
      "signature": "kvm_read_cr0_bits",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_edx_eax",
      "signature": "kvm_read_edx_eax",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "kvm_read_guest",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt_helper",
      "signature": "int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes, struct kvm_vcpu *vcpu, u64 access, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "int kvm_read_guest_virt(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_offset_cached",
      "signature": "kvm_read_guest_offset_cached",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_capskvm_caps__read_mostly",
      "signature": "kvm_capskvm_caps__read_mostly",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_host_valueskvm_host__read_mostly",
      "signature": "kvm_host_valueskvm_host__read_mostly",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x86_opskvm_x86_ops__read_mostly",
      "signature": "kvm_x86_opskvm_x86_ops__read_mostly",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_cr0vcpukvm_read_cr0_bits",
      "signature": "kvm_set_cr0vcpukvm_read_cr0_bits",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_xcrvcpukvm_rcx_readvcpukvm_read_edx_eax",
      "signature": "kvm_set_xcrvcpukvm_rcx_readvcpukvm_read_edx_eax",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read",
      "signature": "int kvm_msr_read(struct kvm_vcpu *vcpu, u32 index, u64 *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_msr_read",
      "signature": "int kvm_emulate_msr_read(struct kvm_vcpu *vcpu, u32 index, u64 *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNAL__kvm_emulate_msr_read",
      "signature": "KVM_INTERNAL__kvm_emulate_msr_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_allowedvcpuindexKVM_MSR_FILTER_READ",
      "signature": "kvm_msr_allowedvcpuindexKVM_MSR_FILTER_READ",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_msr_read",
      "signature": "KVM_INTERNALkvm_emulate_msr_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read_ex",
      "signature": "kvm_msr_read_ex",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_rdmsrvcpukvm_rcx_read",
      "signature": "kvm_emulate_rdmsrvcpukvm_rcx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_wrmsrvcpukvm_rcx_read",
      "signature": "kvm_emulate_wrmsrvcpukvm_rcx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_wrmsrvcpumsrkvm_register_read",
      "signature": "kvm_emulate_wrmsrvcpumsrkvm_register_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_l1_tsc",
      "signature": "KVM_INTERNALkvm_read_l1_tsc",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_x2apic_msr_read",
      "signature": "return kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data); case MSR_IA32_TSC_DEADLINE: msr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu); break; case MSR_IA32_TSC_ADJUST: msr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr; break; case MSR_IA32_MISC_ENABLE: msr_info->data = vcpu->arch.ia32_misc_enable_msr; break; case MSR_IA32_SMBASE: if (!IS_ENABLED(CONFIG_KVM_SMM) || !msr_info->host_initiated) return 1; msr_info->data = vcpu->arch.smbase; break; case MSR_SMI_COUNT: msr_info->data = vcpu->arch.smi_count; break; case MSR_IA32_PERF_STATUS: /* TSC increment by tick */ msr_info->data = 1000ULL; /* CPU multiplier */ msr_info->data |= (((uint64_t)4ULL) << 40); break; case MSR_EFER: msr_info->data = vcpu->arch.efer; break; case MSR_KVM_WALL_CLOCK: if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE)) return 1; msr_info->data = vcpu->kvm->arch.wall_clock; break; case MSR_KVM_WALL_CLOCK_NEW: if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2)) return 1; msr_info->data = vcpu->kvm->arch.wall_clock; break; case MSR_KVM_SYSTEM_TIME: if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE)) return 1; msr_info->data = vcpu->arch.time; break; case MSR_KVM_SYSTEM_TIME_NEW: if (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2)) return 1; msr_info->data = vcpu->arch.time; break; case MSR_KVM_ASYNC_PF_EN: if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF)) return 1; msr_info->data = vcpu->arch.apf.msr_en_val; break; case MSR_KVM_ASYNC_PF_INT: if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT)) return 1; msr_info->data = vcpu->arch.apf.msr_int_val; break; case MSR_KVM_ASYNC_PF_ACK: if (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT)) return 1; msr_info->data = 0; break; case MSR_KVM_STEAL_TIME: if (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME)) return 1; msr_info->data = vcpu->arch.st.msr_val; break; case MSR_KVM_PV_EOI_EN: if (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI)) return 1; msr_info->data = vcpu->arch.pv_eoi.msr_val; break; case MSR_KVM_POLL_CONTROL: if (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL)) return 1; msr_info->data = vcpu->arch.msr_kvm_poll_control; break; case MSR_IA32_P5_MC_ADDR: case MSR_IA32_P5_MC_TYPE: case MSR_IA32_MCG_CAP: case MSR_IA32_MCG_CTL: case MSR_IA32_MCG_STATUS: case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1: case MSR_IA32_MC0_CTL2 ... MSR_IA32_MCx_CTL2(KVM_MAX_MCE_BANKS) - 1: return get_msr_mce(vcpu, msr_info->index, &msr_info->data, msr_info->host_initiated); case MSR_IA32_XSS: if (!msr_info->host_initiated && !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES)) return 1; msr_info->data = vcpu->arch.ia32_xss; break; case MSR_K7_CLK_CTL: /* * Provide expected ramp-up count for K7. All other * are set to zero, indicating minimum divisors for * every field. * * This prevents guest kernels on AMD host with CPU * type 6, model 8 and higher from exploding due to * the rdmsr failing. */ msr_info->data = 0x20000000; break; #ifdef CONFIG_KVM_HYPERV case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15: case HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER: case HV_X64_MSR_SYNDBG_OPTIONS: case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4: case HV_X64_MSR_CRASH_CTL: case HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT: case HV_X64_MSR_REENLIGHTENMENT_CONTROL: case HV_X64_MSR_TSC_EMULATION_CONTROL: case HV_X64_MSR_TSC_EMULATION_STATUS: case HV_X64_MSR_TSC_INVARIANT_CONTROL: return kvm_hv_get_msr_common(vcpu, msr_info->index, &msr_info->data, msr_info->host_initiated); #endif case MSR_IA32_BBL_CR_CTL3: /* This legacy MSR exists but isn't fully documented in current * silicon. It is however accessed by winxp in very narrow * scenarios where it sets bit #19, itself documented as * a \"reserved\" bit. Best effort attempt to source coherent * read data here should the balance of the register be * interpreted by the guest: * * L2 cache control register 3: 64GB range, 256KB size, * enabled, latency 0x1, configured */ msr_info->data = 0xbe702111; break; case MSR_AMD64_OSVW_ID_LENGTH: if (!guest_cpu_cap_has(vcpu, X86_FEATURE_OSVW)) return 1; msr_info->data = vcpu->arch.osvw.length; break; case MSR_AMD64_OSVW_STATUS: if (!guest_cpu_cap_has(vcpu, X86_FEATURE_OSVW)) return 1; msr_info->data = vcpu->arch.osvw.status; break; case MSR_PLATFORM_INFO: if (!msr_info->host_initiated && !vcpu->kvm->arch.guest_can_read_msr_platform_info) return 1; msr_info->data = vcpu->arch.msr_platform_info; break; case MSR_MISC_FEATURES_ENABLES: msr_info->data = vcpu->arch.msr_misc_features_enables; break; case MSR_K7_HWCR: msr_info->data = vcpu->arch.msr_hwcr; break; #ifdef CONFIG_X86_64 case MSR_IA32_XFD: if (!msr_info->host_initiated && !guest_cpu_cap_has(vcpu, X86_FEATURE_XFD)) return 1; msr_info->data = vcpu->arch.guest_fpu.fpstate->xfd; break; case MSR_IA32_XFD_ERR: if (!msr_info->host_initiated && !guest_cpu_cap_has(vcpu, X86_FEATURE_XFD)) return 1; msr_info->data = vcpu->arch.guest_fpu.xfd_err; break; #endif case MSR_IA32_U_CET: case MSR_IA32_PL0_SSP ... MSR_IA32_PL3_SSP: kvm_get_xstate_msr(vcpu, msr_info); break; default: if (kvm_pmu_is_valid_msr(vcpu, msr_info->index)) return kvm_pmu_get_msr(vcpu, msr_info); return KVM_MSR_RET_UNSUPPORTED; } return 0; } EXPORT_SYMBOL_FOR_KVM_INTERNAL(kvm_get_msr_common); /* * Read or write a bunch of msrs. All parameters are kernel addresses. * * @return number of msrs set successfully. */ static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs, struct kvm_msr_entry *entries, int (*do_msr)(struct kvm_vcpu *vcpu, unsigned index, u64 *data))",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_CAP_READONLY_MEM",
      "signature": "KVM_CAP_READONLY_MEM",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_has_readonly_mem",
      "signature": "kvm_arch_has_readonly_mem",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_ready_for_interrupt_injection",
      "signature": "int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_lock",
      "signature": "kvm_vcpu_srcu_read_lock",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_unlock",
      "signature": "kvm_vcpu_srcu_read_unlock",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_iodevice_read",
      "signature": "kvm_iodevice_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_io_bus_read",
      "signature": "kvm_io_bus_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_read",
      "signature": "gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_mmu_gva_to_gpa_read",
      "signature": "KVM_INTERNALkvm_mmu_gva_to_gpa_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_virt",
      "signature": "KVM_INTERNALkvm_read_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_writevcpukvm_rip_read",
      "signature": "kvm_rip_writevcpukvm_rip_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_cr0vcpumk_cr_64kvm_read_cr0",
      "signature": "kvm_set_cr0vcpumk_cr_64kvm_read_cr0",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_cr4vcpumk_cr_64kvm_read_cr4",
      "signature": "kvm_set_cr4vcpumk_cr_64kvm_read_cr4",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read_raw",
      "signature": "return kvm_register_read_raw(emul_to_vcpu(ctxt), reg); } static void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "return kvm_rip_read(vcpu); } int kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbx_read",
      "signature": "kvm_rbx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsi_read",
      "signature": "kvm_rsi_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_check_requestKVM_REQ_APF_READY",
      "signature": "kvm_check_requestKVM_REQ_APF_READY",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdi_read",
      "signature": "kvm_rdi_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsp_read",
      "signature": "kvm_rsp_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbp_read",
      "signature": "kvm_rbp_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r8_read",
      "signature": "kvm_r8_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r9_read",
      "signature": "kvm_r9_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r10_read",
      "signature": "kvm_r10_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r11_read",
      "signature": "kvm_r11_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r12_read",
      "signature": "kvm_r12_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r13_read",
      "signature": "kvm_r13_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r14_read",
      "signature": "kvm_r14_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r15_read",
      "signature": "kvm_r15_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pdptr_read",
      "signature": "kvm_pdptr_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_is_bspvcpukvm_rip_read",
      "signature": "kvm_vcpu_is_bspvcpukvm_rip_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3vcpukvm_read_cr4",
      "signature": "kvm_read_cr3vcpukvm_read_cr4",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MR_FLAGS_ONLYnew_flagsKVM_MEM_READONLY",
      "signature": "KVM_MR_FLAGS_ONLYnew_flagsKVM_MEM_READONLY",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_async_pf_ready",
      "signature": "kvm_async_pf_ready",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_make_requestKVM_REQ_APF_READY",
      "signature": "kvm_make_requestKVM_REQ_APF_READY",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes, void *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_sev_es_mmio_read",
      "signature": "KVM_INTERNALkvm_sev_es_mmio_read",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_pagevcpugpa_to_gfnreal_gpa",
      "signature": "read_guest_pagevcpugpa_to_gfnreal_gpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virt_helpergva",
      "signature": "read_guest_virt_helpergva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_pagevcpugpa",
      "signature": "read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virt",
      "signature": "read_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_emulatestructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_write_emulatestructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_write_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_write_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_emulatestructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_emulatestructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpugpa",
      "signature": "read_guestvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "READ_UNSATISFIEDbytesgpa",
      "signature": "READ_UNSATISFIEDbytesgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_emulatevcpugpa",
      "signature": "read_write_emulatevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_mmiovcpugpa",
      "signature": "read_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_write_exit_mmiovcpugpa",
      "signature": "read_write_exit_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virtvcpugva",
      "signature": "read_guest_virtvcpugva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "read_emultorread_write_mmiovcpugpa",
      "signature": "read_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_sse_reg",
      "signature": "void kvm_read_sse_reg(int reg, sse128_t *data)",
      "file": "arch/x86/kvm/fpu.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_mmx_reg",
      "signature": "void kvm_read_mmx_reg(int reg, u64 *data)",
      "file": "arch/x86/kvm/fpu.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_pic_read_irq",
      "signature": "int kvm_pic_read_irq(struct kvm *kvm)",
      "file": "arch/x86/kvm/i8259.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read_raw",
      "signature": "kvm_register_read_raw",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read",
      "signature": "kvm_msr_read",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pic_read_irq",
      "signature": "int kvm_pic_read_irq(struct kvm *kvm); void kvm_pic_update_irq(struct kvm_pic *s); int kvm_pic_set_irq(struct kvm_kernel_irq_routing_entry *e, struct kvm *kvm, int irq_source_id, int level, bool line_status); int kvm_setup_default_ioapic_and_pic_routing(struct kvm *kvm); int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip); int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip); static inline int irqchip_full(struct kvm *kvm)",
      "file": "arch/x86/kvm/irq.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_setup_tsc_pagestructkvmkvmstructpvclock_vcpu_time_infohv_clockstructkvm_hvhvto_kvm_hvkvmu32tsc_sequ64gfnBUILD_BUG_ONsizeoftsc_seqsizeofhvtsc_reftsc_sequenceBUILD_BUG_ONoffsetofstructms_hyperv_tsc_pagetsc_sequence0guardmutexhvhv_lockifhvhv_tsc_page_statusHV_TSC_PAGE_BROKENhvhv_tsc_page_statusHV_TSC_PAGE_SEThvhv_tsc_page_statusHV_TSC_PAGE_UNSETreturnifhvhv_tsc_pageHV_X64_MSR_TSC_REFERENCE_ENABLEreturngfnhvhv_tsc_pageHV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFTBecausetheTSCparametersonlyvarywhenthereisachangeinthemasterclockdonotbotherwithcachingifunlikelykvm_read_guestkvmgfn_to_gpagfntsc_seqsizeoftsc_seqgotoout_erriftsc_seqtsc_page_update_unsafehvifkvm_read_guestkvmgfn_to_gpa",
      "signature": "kvm_hv_setup_tsc_pagestructkvmkvmstructpvclock_vcpu_time_infohv_clockstructkvm_hvhvto_kvm_hvkvmu32tsc_sequ64gfnBUILD_BUG_ONsizeoftsc_seqsizeofhvtsc_reftsc_sequenceBUILD_BUG_ONoffsetofstructms_hyperv_tsc_pagetsc_sequence0guardmutexhvhv_lockifhvhv_tsc_page_statusHV_TSC_PAGE_BROKENhvhv_tsc_page_statusHV_TSC_PAGE_SEThvhv_tsc_page_statusHV_TSC_PAGE_UNSETreturnifhvhv_tsc_pageHV_X64_MSR_TSC_REFERENCE_ENABLEreturngfnhvhv_tsc_pageHV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFTBecausetheTSCparametersonlyvarywhenthereisachangeinthemasterclockdonotbotherwithcachingifunlikelykvm_read_guestkvmgfn_to_gpagfntsc_seqsizeoftsc_seqgotoout_erriftsc_seqtsc_page_update_unsafehvifkvm_read_guestkvmgfn_to_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_send_ipistructkvm_vcpuvcpustructkvm_hv_hcallhcstructkvm_vcpu_hvhv_vcputo_hv_vcpuvcpuu64sparse_bankshv_vcpusparse_banksstructkvmkvmvcpukvmstructhv_send_ipi_exsend_ipi_exstructhv_send_ipisend_ipiu64valid_bank_masku32vectorboolall_cpusiflapic_in_kernelvcpureturnHV_STATUS_INVALID_HYPERCALL_INPUTifhccodeHVCALL_SEND_IPIifhcfastifunlikelykvm_read_guestkvmhcingpa",
      "signature": "kvm_hv_send_ipistructkvm_vcpuvcpustructkvm_hv_hcallhcstructkvm_vcpu_hvhv_vcputo_hv_vcpuvcpuu64sparse_bankshv_vcpusparse_banksstructkvmkvmvcpukvmstructhv_send_ipi_exsend_ipi_exstructhv_send_ipisend_ipiu64valid_bank_masku32vectorboolall_cpusiflapic_in_kernelvcpureturnHV_STATUS_INVALID_HYPERCALL_INPUTifhccodeHVCALL_SEND_IPIifhcfastifunlikelykvm_read_guestkvmhcingpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "ifhcfastifunlikelykvm_read_guestkvmhcingpa",
      "signature": "ifhcfastifunlikelykvm_read_guestkvmhcingpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_hypercall_completestructkvm_vcpuvcpuu64resultu32tlb_lock_count0intretifhv_result_successresultis_guest_modevcpukvm_hv_is_tlb_flush_hcallvcpukvm_read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "signature": "kvm_hv_hypercall_completestructkvm_vcpuvcpuu64resultu32tlb_lock_count0intretifhv_result_successresultis_guest_modevcpukvm_hv_is_tlb_flush_hcallvcpukvm_read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hvcall_signal_eventstructkvm_vcpuvcpustructkvm_hv_hcallhcstructkvm_hvhvto_kvm_hvvcpukvmstructeventfd_ctxeventfdifunlikelyhcfastintretgpa_tgpahcingpaifgpa__alignof__hcingpa1offset_in_pagegpasizeofhcingpaPAGE_SIZEreturnHV_STATUS_INVALID_ALIGNMENTretkvm_vcpu_read_guestvcpugpa",
      "signature": "kvm_hvcall_signal_eventstructkvm_vcpuvcpustructkvm_hv_hcallhcstructkvm_hvhvto_kvm_hvvcpukvmstructeventfd_ctxeventfdifunlikelyhcfastintretgpa_tgpahcingpaifgpa__alignof__hcingpa1offset_in_pagegpasizeofhcingpaPAGE_SIZEreturnHV_STATUS_INVALID_ALIGNMENTretkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "return kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &hv_vcpu->vp_assist_page, sizeof(struct hv_vp_assist_page)); } EXPORT_SYMBOL_FOR_KVM_INTERNAL(kvm_hv_get_assist_page); static void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "return kvm_read_guest(kvm, hc->ingpa + hc->data_offset, data, cnt * sizeof(*data)); } static u64 kvm_get_sparse_vp_set(struct kvm *kvm, struct kvm_hv_hcall *hc, u64 *sparse_banks)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_sse_reg",
      "signature": "kvm_read_sse_reg",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_vapic_msr_read",
      "signature": "return kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata); case HV_X64_MSR_ICR: return kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata); case HV_X64_MSR_TPR: return kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata); case HV_X64_MSR_VP_ASSIST_PAGE: data = hv_vcpu->hv_vapic; break; case HV_X64_MSR_VP_RUNTIME: data = current_task_runtime_100ns() + hv_vcpu->runtime_offset; break; case HV_X64_MSR_SCONTROL: case HV_X64_MSR_SVERSION: case HV_X64_MSR_SIEFP: case HV_X64_MSR_SIMP: case HV_X64_MSR_EOM: case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: return synic_get_msr(to_hv_synic(vcpu), msr, pdata, host)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_hv_hypercall_read_xmm",
      "signature": "void kvm_hv_hypercall_read_xmm(struct kvm_hv_hcall *hc)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r8_read",
      "signature": "kvm_r8_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbx_read",
      "signature": "kvm_rbx_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdi_read",
      "signature": "kvm_rdi_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsi_read",
      "signature": "kvm_rsi_read",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestkvmgfn_to_gpa",
      "signature": "read_guestkvmgfn_to_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestkvmhcingpa",
      "signature": "read_guestkvmhcingpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "signature": "read_guestvcpukvmto_hv_vcpuvcpunestedpa_page_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpugpa",
      "signature": "read_guestvcpugpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pic_read_irq",
      "signature": "return kvm_pic_read_irq(v->kvm); /* PIC */ #endif WARN_ON_ONCE(!irqchip_split(v->kvm)); return get_userspace_extint(v); } EXPORT_SYMBOL_FOR_KVM_INTERNAL(kvm_cpu_get_extint); /* * Read pending interrupt vector and intack. */ int kvm_cpu_get_interrupt(struct kvm_vcpu *v)",
      "file": "arch/x86/kvm/irq.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_cpu_capsNR_KVM_CPU_CAPS__read_mostly",
      "signature": "kvm_cpu_capsNR_KVM_CPU_CAPS__read_mostly",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_read",
      "signature": "kvm_msr_read",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "return kvm_read_cr3(vcpu) & (X86_CR3_LAM_U48 | X86_CR3_LAM_U57); } static inline void kvm_mmu_load_pgd(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_get_pcidvcpukvm_read_cr3",
      "signature": "kvm_get_pcidvcpukvm_read_cr3",
      "file": "arch/x86/kvm/mmu.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_xen_schedop_pollstructkvm_vcpuvcpuboollongmodeu64paramu64rstructsched_pollsched_pollevtchn_port_tportportsstructx86_exceptioneintiiflapic_in_kernelvcpuvcpukvmarchxenhvm_configflagsKVM_XEN_HVM_CONFIG_EVTCHN_SENDreturnfalseifIS_ENABLEDCONFIG_64BITlongmodestructcompat_sched_pollsp32SanitycheckthatthecompatstructdefinitioniscorrectBUILD_BUG_ONsizeofsp3216ifkvm_read_guest_virt",
      "signature": "kvm_xen_schedop_pollstructkvm_vcpuvcpuboollongmodeu64paramu64rstructsched_pollsched_pollevtchn_port_tportportsstructx86_exceptioneintiiflapic_in_kernelvcpuvcpukvmarchxenhvm_configflagsKVM_XEN_HVM_CONFIG_EVTCHN_SENDreturnfalseifIS_ENABLEDCONFIG_64BITlongmodestructcompat_sched_pollsp32SanitycheckthatthecompatstructdefinitioniscorrectBUILD_BUG_ONsizeofsp3216ifkvm_read_guest_virt",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_xen_hcall_evtchn_sendstructkvm_vcpuvcpuu64paramu64rstructevtchnfdevtchnfdstructevtchn_sendsendstructx86_exceptioneSanitycheckthisstructureisthesamefor32bitand64bitBUILD_BUG_ONsizeofsend4ifkvm_read_guest_virt",
      "signature": "kvm_xen_hcall_evtchn_sendstructkvm_vcpuvcpuu64paramu64rstructevtchnfdevtchnfdstructevtchn_sendsendstructx86_exceptioneSanitycheckthisstructureisthesamefor32bitand64bitBUILD_BUG_ONsizeofsend4ifkvm_read_guest_virt",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "kvm_read_guest_virt",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbx_read",
      "signature": "kvm_rbx_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsi_read",
      "signature": "kvm_rsi_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdi_read",
      "signature": "kvm_rdi_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbp_read",
      "signature": "kvm_rbp_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r10_read",
      "signature": "kvm_r10_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r8_read",
      "signature": "kvm_r8_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_r9_read",
      "signature": "kvm_r9_read",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virt",
      "signature": "read_guest_virt",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virtvcpugva",
      "signature": "read_guest_virtvcpugva",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_read"
    },
    {
      "function": "avic_vcpu_putstructkvm_vcpuvcpuNotereadingthePhys",
      "signature": "avic_vcpu_putstructkvm_vcpuvcpuNotereadingthePhys",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_read"
    },
    {
      "function": "avic_vcpu_blockingstructkvm_vcpuvcpuifkvm_vcpu_apicv_activevcpureturnUnloadtheAVICwhenthevCPUisabouttoblock_before_thevCPUactuallyblocksNoteanyIRQsthatarrivebeforeIsRunning0willnotcauseanincompleteIPIvmexitonthesourcekvm_vcpu_check_blockhandlesthisbycheckingvIRRonelasttimebeforeblockingThememorybarrierimplicitinset_current_stateorderswritingIsRunning0beforereadingthevIRRTheprocessorneedsamatchingmem",
      "signature": "avic_vcpu_blockingstructkvm_vcpuvcpuifkvm_vcpu_apicv_activevcpureturnUnloadtheAVICwhenthevCPUisabouttoblock_before_thevCPUactuallyblocksNoteanyIRQsthatarrivebeforeIsRunning0willnotcauseanincompleteIPIvmexitonthesourcekvm_vcpu_check_blockhandlesthisbycheckingvIRRonelasttimebeforeblockingThememorybarrierimplicitinset_current_stateorderswritingIsRunning0beforereadingthevIRRTheprocessorneedsamatchingmem",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_read"
    },
    {
      "function": "snp_handle_ext_guest_reqstructvcpu_svmsvmgpa_treq_gpagpa_tresp_gpastructkvmkvmsvmvcpukvmu8msg_typeifsev_snp_guestkvmreturnEINVALifkvm_read_guestkvmreq_gpa",
      "signature": "snp_handle_ext_guest_reqstructvcpu_svmsvmgpa_treq_gpagpa_tresp_gpastructkvmkvmsvmvcpukvmu8msg_typeifsev_snp_guestkvmreturnEINVALifkvm_read_guestkvmreq_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "kvm_read_guest",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_sev_es_mmio_read",
      "signature": "kvm_sev_es_mmio_read",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestsvmvcpukvmscratch_gpa",
      "signature": "read_guestsvmvcpukvmscratch_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestkvmreq_gpa",
      "signature": "read_guestkvmreq_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_and_reset_apf_flags",
      "signature": "kvm_read_and_reset_apf_flags",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_READ",
      "signature": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_READ",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_skinitto_svmvcpuvmcbsaveripkvm_rax_read",
      "signature": "kvm_skinitto_svmvcpuvmcbsaveripkvm_rax_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_cr_read",
      "signature": "kvm_cr_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_drvcpudrkvm_register_read",
      "signature": "kvm_set_drvcpudrkvm_register_read",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_read"
    },
    {
      "function": "nested_svm_get_tdp_pdptrstructkvm_vcpuvcpuintindexstructvcpu_svmsvmto_svmvcpuu64cr3svmnestedctlnested_cr3u64pdpteintretNotenCR3isassumedtobe32bytealignedietheCPUignoresnCR340whenloadingPDPTEsfrommemoryretkvm_vcpu_read_guest_pagevcpugpa",
      "signature": "nested_svm_get_tdp_pdptrstructkvm_vcpuvcpuintindexstructvcpu_svmsvmto_svmvcpuu64cr3svmnestedctlnested_cr3u64pdpteintretNotenCR3isassumedtobe32bytealignedietheCPUignoresnCR340whenloadingPDPTEsfrommemoryretkvm_vcpu_read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "fori0inested_svm_nr_msrpm_merge_offsetsiconstintpnested_svm_msrpm_merge_offsetsinsvm_msrpm_merge_tl1_valgpa_tgpagpasvmnestedctlmsrpm_base_papsizeofl1_valifkvm_vcpu_read_guestvcpugpa",
      "signature": "fori0inested_svm_nr_msrpm_merge_offsetsiconstintpnested_svm_msrpm_merge_offsetsinsvm_msrpm_merge_tl1_valgpa_tgpagpasvmnestedctlmsrpm_base_papsizeofl1_valifkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "nested_svm_intercept_ioiostructvcpu_svmsvmunsignedportsizeiopm_lenu16valmasku8start_bitu64gpaifvmcb12_is_interceptsvmnestedctlINTERCEPT_IOIO_PROTreturnNESTED_EXIT_HOSTportsvmvmcbcontrolexit_info_116sizesvmvmcbcontrolexit_info_1SVM_IOIO_SIZE_MASKSVM_IOIO_SIZE_SHIFTgpasvmnestedctliopm_base_paport8start_bitport8iopm_lenstart_bitsize821mask0xf4sizestart_bitval0ifkvm_vcpu_read_guestsvmvcpugpa",
      "signature": "nested_svm_intercept_ioiostructvcpu_svmsvmunsignedportsizeiopm_lenu16valmasku8start_bitu64gpaifvmcb12_is_interceptsvmnestedctlINTERCEPT_IOIO_PROTreturnNESTED_EXIT_HOSTportsvmvmcbcontrolexit_info_116sizesvmvmcbcontrolexit_info_1SVM_IOIO_SIZE_MASKSVM_IOIO_SIZE_SHIFTgpasvmnestedctliopm_base_paport8start_bitport8iopm_lenstart_bitsize821mask0xf4sizestart_bitval0ifkvm_vcpu_read_guestsvmvcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsp_read",
      "signature": "kvm_rsp_read",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_pagevcpugpa",
      "signature": "read_guest_pagevcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpugpa",
      "signature": "read_guestvcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestsvmvcpugpa",
      "signature": "read_guestsvmvcpugpa",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdp_mmu_read_spte",
      "signature": "u64 kvm_tdp_mmu_read_spte(tdp_ptep_t sptep)",
      "file": "arch/x86/kvm/mmu/tdp_iter.h",
      "category": "memory_read"
    },
    {
      "function": "host_pfn_mapping_levelstructkvmkvmgfn_tgfnconststructkvm_memory_slotslotintlevelPG_LEVEL_4Kunsignedlonghvaunsignedlongflagspgd_tpgdp4d_tp4dpud_tpudpmd_tpmdNoteusingthealreadyretrievedmemslotand__gfn_to_hva_memslotisnotsolelyforperformanceitsalsonecessarytoavoidthewritablecheckin__gfn_to_hva_manywhichwillalwaysfailonreadonlymemslotsduetogfn_to_hvaassumingwritesEarlierpagefaultstepshavealreadyverifiedtheguestisntwritingareadonlymemslothva__gfn_to_hva_memslotslotgfnDisableIRQstopreventconcurrentteardownofhostpagetablesegiftheprimaryMMUpromotesaPDtoahugepageandthenfreestheoriginalpagetablelocal_irq_saveflagsReadeachentryonceAsaboveanonleafentrycanbepromotedtoahugepage_during_thiswalkRereadingtheentrycouldsendthewalkintotheweeksegpd_leafreturnsfalseseestheoldvalueandthenpd_offsetwalksintothetargethugepageinsteadoftheoldpagetableseesthenewvaluepgdREAD_ONCEpgd_offsetkvmmmhvaifpgd_nonepgdgotooutp4dREAD_ONCEp4d_offsetpgdhvaifp4d_nonep4dp4d_presentp4dgotooutpudREAD_ONCEpud_offsetp4dhva",
      "signature": "host_pfn_mapping_levelstructkvmkvmgfn_tgfnconststructkvm_memory_slotslotintlevelPG_LEVEL_4Kunsignedlonghvaunsignedlongflagspgd_tpgdp4d_tp4dpud_tpudpmd_tpmdNoteusingthealreadyretrievedmemslotand__gfn_to_hva_memslotisnotsolelyforperformanceitsalsonecessarytoavoidthewritablecheckin__gfn_to_hva_manywhichwillalwaysfailonreadonlymemslotsduetogfn_to_hvaassumingwritesEarlierpagefaultstepshavealreadyverifiedtheguestisntwritingareadonlymemslothva__gfn_to_hva_memslotslotgfnDisableIRQstopreventconcurrentteardownofhostpagetablesegiftheprimaryMMUpromotesaPDtoahugepageandthenfreestheoriginalpagetablelocal_irq_saveflagsReadeachentryonceAsaboveanonleafentrycanbepromotedtoahugepage_during_thiswalkRereadingtheentrycouldsendthewalkintotheweeksegpd_leafreturnsfalseseestheoldvalueandthenpd_offsetwalksintothetargethugepageinsteadoftheoldpagetableseesthenewvaluepgdREAD_ONCEpgd_offsetkvmmmhvaifpgd_nonepgdgotooutp4dREAD_ONCEp4d_offsetpgdhvaifp4d_nonep4dp4d_presentp4dgotooutpudREAD_ONCEpud_offsetp4dhva",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "is_obsolete_rootstructkvmkvmhpa_troot_hpastructkvm_mmu_pagespifVALID_PAGEroot_hpareturnfalseWhenfreeingobsoleterootstreatrootsasobsoleteiftheydonthaveanassociatedshadowpageasitsimpossibletodetermineifsuchrootsarefreshorstaleThisdoesmeanKVMwillgetfalsepositivesandfreerootsthatdontstrictlyneedtobefreedbutsuchfalsepositivesarerelativelyrareaonlyPAEpagingandnestedNPThaverootswithoutshadowpagesoranyshadowpagingflavorwithadummyrootseenotebelowbremotereloadsduetoamem",
      "signature": "is_obsolete_rootstructkvmkvmhpa_troot_hpastructkvm_mmu_pagespifVALID_PAGEroot_hpareturnfalseWhenfreeingobsoleterootstreatrootsasobsoleteiftheydonthaveanassociatedshadowpageasitsimpossibletodetermineifsuchrootsarefreshorstaleThisdoesmeanKVMwillgetfalsepositivesandfreerootsthatdontstrictlyneedtobefreedbutsuchfalsepositivesarerelativelyrareaonlyPAEpagingandnestedNPThaverootswithoutshadowpagesoranyshadowpagingflavorwithadummyrootseenotebelowbremotereloadsduetoamem",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "ifbytes4bytes8rkvm_vcpu_read_guest_atomicvcpugpa",
      "signature": "ifbytes4bytes8rkvm_vcpu_read_guest_atomicvcpugpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytesgfn_tgfngpaPAGE_SHIFTstructkvm_mmu_pagespLIST_HEADinvalid_listu64entrygentryspteintnpteboolflushfalseWhenemulatingguestwritesensurethewrittenvalueisvisibletoanytaskthatishandlingpagefaultsbeforecheckingwhetherornotKVMisshadowingaguestPTEThisensureseitherKVMwillcreatethecorrectSPTEinthepagefaulthandlerorthistaskwillseeanonzeroindirect_shadow_pagesPairswiththesmp_mbinaccount_shadowedsmp_mbifvcpukvmarchindirect_shadow_pagesreturnwrite_lockvcpukvmmmu_lockgentrymmu_pte_write_fetch_gptevcpugpa",
      "signature": "kvm_mmu_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytesgfn_tgfngpaPAGE_SHIFTstructkvm_mmu_pagespLIST_HEADinvalid_listu64entrygentryspteintnpteboolflushfalseWhenemulatingguestwritesensurethewrittenvalueisvisibletoanytaskthatishandlingpagefaultsbeforecheckingwhetherornotKVMisshadowingaguestPTEThisensureseitherKVMwillcreatethecorrectSPTEinthepagefaulthandlerorthistaskwillseeanonzeroindirect_shadow_pagesPairswiththesmp_mbinaccount_shadowedsmp_mbifvcpukvmarchindirect_shadow_pagesreturnwrite_lockvcpukvmmmu_lockgentrymmu_pte_write_fetch_gptevcpugpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_sp_dirty_logging_enabledstructkvmkvmstructkvm_mmu_pagespstructkvm_memory_slotslotSkipthememslotlookupifdirtytrackingcantpossiblybeenabledasmemslotlookupsarerelativelyexpensiveIfamemslotupdateisinprogressreadinganincorrectvalueofkvmnr_memslots_dirty_loggingisnotaproblemifitisbecomingzeroKVMwilldoanunnecessarymemslotlookupifitisbecomingnonzerothepagewillbezappedunnecessarilyEitherwaythisonlyaffectsefficiencyinracysituationsandnotcorrectnessifatomic_readkvmnr_mem",
      "signature": "kvm_mmu_sp_dirty_logging_enabledstructkvmkvmstructkvm_mmu_pagespstructkvm_memory_slotslotSkipthememslotlookupifdirtytrackingcantpossiblybeenabledasmemslotlookupsarerelativelyexpensiveIfamemslotupdateisinprogressreadinganincorrectvalueofkvmnr_memslots_dirty_loggingisnotaproblemifitisbecomingzeroKVMwilldoanunnecessarymemslotlookupifitisbecomingnonzerothepagewillbezappedunnecessarilyEitherwaythisonlyaffectsefficiencyinracysituationsandnotcorrectnessifatomic_readkvmnr_mem",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0_bits",
      "signature": "kvm_read_cr0_bits",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4_bits",
      "signature": "kvm_read_cr4_bits",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "return kvm_read_cr3(vcpu); } static inline unsigned long kvm_mmu_get_guest_pgd(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rmap_lock_readonly",
      "signature": "long kvm_rmap_lock_readonly(struct kvm_rmap_head *rmap_head)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rmap_unlock_readonly",
      "signature": "void kvm_rmap_unlock_readonly(struct kvm_rmap_head *rmap_head, unsigned long old_val)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_async_page_ready",
      "signature": "void kvm_arch_async_page_ready(struct kvm_vcpu *vcpu, struct kvm_async_pf *work)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MEM_READONLY",
      "signature": "KVM_MEM_READONLY",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pdptr_read",
      "signature": "kvm_pdptr_read",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_atomic",
      "signature": "kvm_vcpu_read_guest_atomic",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicvcpugpa",
      "signature": "read_guest_atomicvcpugpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdp_mmu_read_spte",
      "signature": "kvm_tdp_mmu_read_spte",
      "file": "arch/x86/kvm/mmu/tdp_iter.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MMU_WARN_ONatomic64_read",
      "signature": "KVM_MMU_WARN_ONatomic64_read",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdp_mmu_read_spte",
      "signature": "kvm_tdp_mmu_read_spte",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_read"
    },
    {
      "function": "iflevelPG_LEVEL_4KmaskPTE_PREFETCH_NUMsizeofpt_element_t1base_gpapte_gpamaskindexpte_gpabase_gpasizeofpt_element_trkvm_vcpu_read_guest_atomicvcpubase_gpa",
      "signature": "iflevelPG_LEVEL_4KmaskPTE_PREFETCH_NUMsizeofpt_element_t1base_gpapte_gpamaskindexpte_gpabase_gpasizeofpt_element_trkvm_vcpu_read_guest_atomicvcpubase_gpa",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_atomic",
      "signature": "kvm_vcpu_read_guest_atomic",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicvcpubase_gpa",
      "signature": "read_guest_atomicvcpubase_gpa",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicvcpupte_gpa",
      "signature": "read_guest_atomicvcpupte_gpa",
      "file": "arch/x86/kvm/mmu/paging_tmpl.h",
      "category": "memory_read"
    },
    {
      "function": "sgx_gva_to_gpastructkvm_vcpuvcpugva_tgvaboolwritegpa_tgpastructx86_exceptionexifwritegpakvm_mmu_gva_to_gpa_writevcpugvaexelsegpakvm_mmu_gva_to_gpa_readvcpugva",
      "signature": "sgx_gva_to_gpastructkvm_vcpuvcpugva_tgvaboolwritegpa_tgpastructx86_exceptionexifwritegpakvm_mmu_gva_to_gpa_writevcpugvaexelsegpakvm_mmu_gva_to_gpa_readvcpugva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "handle_encls_ecreatestructkvm_vcpuvcpugva_tpageinfo_gvasecs_gvagva_tmetadata_gvacontents_gvagpa_tmetadata_gpacontents_gpasecs_gpaunsignedlongmetadata_hvacontents_hvasecs_hvastructsgx_pageinfopageinfostructsgx_secscontentsstructx86_exceptionexintrifsgx_get_encls_gvavcpukvm_rbx_readvcpu3232pageinfo_gvasgx_get_encls_gvavcpukvm_rcx_readvcpu40964096secs_gvareturn1CopythePAGEINFOtolocalmemoryitspointersneedtobetranslatedieweneedtodoadeepcopytranslaterkvm_read_guest_virtvcpupageinfo_gva",
      "signature": "handle_encls_ecreatestructkvm_vcpuvcpugva_tpageinfo_gvasecs_gvagva_tmetadata_gvacontents_gvagpa_tmetadata_gpacontents_gpasecs_gpaunsignedlongmetadata_hvacontents_hvasecs_hvastructsgx_pageinfopageinfostructsgx_secscontentsstructx86_exceptionexintrifsgx_get_encls_gvavcpukvm_rbx_readvcpu3232pageinfo_gvasgx_get_encls_gvavcpukvm_rcx_readvcpu40964096secs_gvareturn1CopythePAGEINFOtolocalmemoryitspointersneedtobetranslatedieweneedtodoadeepcopytranslaterkvm_read_guest_virtvcpupageinfo_gva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "handle_encls_einitstructkvm_vcpuvcpuunsignedlongsig_hvasecs_hvatoken_hvarflagsstructvcpu_vmxvmxto_vmxvcpugva_tsig_gvasecs_gvatoken_gvagpa_tsig_gpasecs_gpatoken_gpaintrettrapnrifsgx_get_encls_gvavcpukvm_rbx_readvcpu18084096sig_gvasgx_get_encls_gvavcpukvm_rcx_readvcpu40964096secs_gvasgx_get_encls_gvavcpukvm_rdx_readvcpu304512token_gva",
      "signature": "handle_encls_einitstructkvm_vcpuvcpuunsignedlongsig_hvasecs_hvatoken_hvarflagsstructvcpu_vmxvmxto_vmxvcpugva_tsig_gvasecs_gvatoken_gvagpa_tsig_gpasecs_gpatoken_gpaintrettrapnrifsgx_get_encls_gvavcpukvm_rbx_readvcpu18084096sig_gvasgx_get_encls_gvavcpukvm_rcx_readvcpu40964096secs_gvasgx_get_encls_gvavcpukvm_rdx_readvcpu304512token_gva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "kvm_read_guest_virt",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_read",
      "signature": "kvm_mmu_gva_to_gpa_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rbx_read",
      "signature": "kvm_rbx_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rdx_read",
      "signature": "kvm_rdx_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virtvcpupageinfo_gva",
      "signature": "read_guest_virtvcpupageinfo_gva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_read"
    },
    {
      "function": "tdx_complete_mmio_readstructkvm_vcpuvcpuunsignedlongval0gpa_tgpaintsizegpavcpummio_fragments0gpasizevcpummio_fragments0lenmemcpyvalvcpurunmmiodatasizetdvmcall_set_return_valvcpuvaltrace_kvm_mmioKVM_TRACE_MMIO_READsizegpa",
      "signature": "tdx_complete_mmio_readstructkvm_vcpuvcpuunsignedlongval0gpa_tgpaintsizegpavcpummio_fragments0gpasizevcpummio_fragments0lenmemcpyvalvcpurunmmiodatasizetdvmcall_set_return_valvcpuvaltrace_kvm_mmioKVM_TRACE_MMIO_READsizegpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "tdx_mmio_readstructkvm_vcpuvcpugpa_tgpaintsizeunsignedlongvalifkvm_io_bus_readvcpuKVM_MMIO_BUSgpasizevalreturnEOPNOTSUPPtdvmcall_set_return_valvcpuvaltrace_kvm_mmioKVM_TRACE_MMIO_READsizegpa",
      "signature": "tdx_mmio_readstructkvm_vcpuvcpugpa_tgpaintsizeunsignedlongvalifkvm_io_bus_readvcpuKVM_MMIO_BUSgpasizevalreturnEOPNOTSUPPtdvmcall_set_return_valvcpuvaltrace_kvm_mmioKVM_TRACE_MMIO_READsizegpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "tdx_emulate_mmiostructkvm_vcpuvcpustructvcpu_tdxtdxto_tdxvcpuintsizewriterunsignedlongvalgpa_tgpasizetdxvp_enter_argsr12writetdxvp_enter_argsr13gpatdxvp_enter_argsr14valwritetdxvp_enter_argsr150ifsize1size2size4size8gotoerrorifwrite0write1gotoerrorTDGVPVMCALLMMIOallowsonlysharedGPAitmakesnosensetodoMMIOemulationforprivateGPAifvt_is_tdx_private_gpavcpukvmgpavt_is_tdx_private_gpavcpukvmgpasize1gotoerrorgpagpagfn_to_gpakvm_gfn_direct_bitsvcpukvmifwritertdx_mmio_writevcpugpasizevalelsertdx_mmio_readvcpugpa",
      "signature": "tdx_emulate_mmiostructkvm_vcpuvcpustructvcpu_tdxtdxto_tdxvcpuintsizewriterunsignedlongvalgpa_tgpasizetdxvp_enter_argsr12writetdxvp_enter_argsr13gpatdxvp_enter_argsr14valwritetdxvp_enter_argsr150ifsize1size2size4size8gotoerrorifwrite0write1gotoerrorTDGVPVMCALLMMIOallowsonlysharedGPAitmakesnosensetodoMMIOemulationforprivateGPAifvt_is_tdx_private_gpavcpukvmgpavt_is_tdx_private_gpavcpukvmgpasize1gotoerrorgpagpagfn_to_gpakvm_gfn_direct_bitsvcpukvmifwritertdx_mmio_writevcpugpasizevalelsertdx_mmio_readvcpugpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_edx_eax",
      "signature": "kvm_read_edx_eax",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_io_bus_read",
      "signature": "kvm_io_bus_read",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "signature": "kvm_mmioKVM_TRACE_MMIO_READ_UNSATISFIED",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_BUG_ONatomic64_read",
      "signature": "KVM_BUG_ONatomic64_read",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdxtsc_offsettd_tdcs_exec_read64",
      "signature": "kvm_tdxtsc_offsettd_tdcs_exec_read64",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_tdxtsc_multipliertd_tdcs_exec_read64",
      "signature": "kvm_tdxtsc_multipliertd_tdcs_exec_read64",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "READ_UNSATISFIEDsizegpa",
      "signature": "READ_UNSATISFIEDsizegpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_read"
    },
    {
      "function": "vmcs_loadstructvmcsvmcsu64phys_addr__pavmcsifkvm_is_using_evmcsreturnevmcs_loadphys",
      "signature": "vmcs_loadstructvmcsvmcsu64phys_addr__pavmcsifkvm_is_using_evmcsreturnevmcs_loadphys",
      "file": "arch/x86/kvm/vmx/vmx_ops.h",
      "category": "memory_read"
    },
    {
      "function": "handle_ept_violationstructkvm_vcpuvcpuunsignedlongexit_qualificationvmx_get_exit_qualvcpugpa_tgpaEPTviolationhappenedwhileexecutingiretfromNMIblockedbyNMIbithastobesetbeforenextVMentryThereareerratathatmaycausethisbittonotbesetAAK134BY25ifto_vmxvcpuidt_vectoring_infoVECTORING_INFO_VALID_MASKenable_vnmiexit_qualificationINTR_INFO_UNBLOCK_NMIvmcs_set_bitsGUEST_INTERRUPTIBILITY_INFOGUEST_INTR_STATE_NMIgpavmcs_read64GUEST_PHYS",
      "signature": "handle_ept_violationstructkvm_vcpuvcpuunsignedlongexit_qualificationvmx_get_exit_qualvcpugpa_tgpaEPTviolationhappenedwhileexecutingiretfromNMIblockedbyNMIbithastobesetbeforenextVMentryThereareerratathatmaycausethisbittonotbesetAAK134BY25ifto_vmxvcpuidt_vectoring_infoVECTORING_INFO_VALID_MASKenable_vnmiexit_qualificationINTR_INFO_UNBLOCK_NMIvmcs_set_bitsGUEST_INTERRUPTIBILITY_INFOGUEST_INTR_STATE_NMIgpavmcs_read64GUEST_PHYS",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "handle_ept_misconfigstructkvm_vcpuvcpugpa_tgpaifvmx_check_emulate_instructionvcpuEMULTYPE_PFNULL0return1AnestedguestcannotoptimizeMMIOvmexitsbecausewehaveannGPAhereinsteadoftherequiredGPAgpavmcs_read64GUEST_PHYS",
      "signature": "handle_ept_misconfigstructkvm_vcpuvcpugpa_tgpaifvmx_check_emulate_instructionvcpuEMULTYPE_PFNULL0return1AnestedguestcannotoptimizeMMIOvmexitsbecausewehaveannGPAhereinsteadoftherequiredGPAgpavmcs_read64GUEST_PHYS",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "__vmx_handle_exitstructkvm_vcpuvcpufastpath_texit_fastpathstructvcpu_vmxvmxto_vmxvcpuunionvmx_exit_reasonexit_reasonvmx_get_exit_reasonvcpuu32vectoring_infovmxidt_vectoring_infou16exit_handler_indexFlushloggedGPAsPMLbufferthiswillmakedirty_bitmapmoreupdatedAnothergoodisinkvm_vm_ioctl_get_dirty_logbeforequeryingdirty_bitmapweonlyneedtokickallvcpusoutofguestmodeasifvcpusisinrootmodethePMLbuffermusthasbeenflushedalreadyNotePMLisneverenabledinhardwarewhilerunningL2ifenable_pmlis_guest_modevcpuvmx_flush_pml_buffervcpuKVMshouldneverreachthispointwithapendingnestedVMEnterMorespecificallyshortcircuitingVMEntrytoemulateL2duetoinvalidgueststateshouldneverhappenasthatmeansKVMknowinglyallowedanestedVMEnterwithaninvalidvmcs12MorebelowifKVM_BUG_ONvmxnestednested_run_pendingvcpukvmreturnEIOifis_guest_modevcpuPMLisneverenabledwhenrunningL2bailimmediatelyifaPMLfullexitoccursassomethingishorriblywrongifexit_reasonbasicEXIT_REASON_PML_FULLgotounexpected_vmexitThehostphysicaladdressesofsomepagesofguestmemoryareloadedintothevmcs02egvmcs12sVirt",
      "signature": "__vmx_handle_exitstructkvm_vcpuvcpufastpath_texit_fastpathstructvcpu_vmxvmxto_vmxvcpuunionvmx_exit_reasonexit_reasonvmx_get_exit_reasonvcpuu32vectoring_infovmxidt_vectoring_infou16exit_handler_indexFlushloggedGPAsPMLbufferthiswillmakedirty_bitmapmoreupdatedAnothergoodisinkvm_vm_ioctl_get_dirty_logbeforequeryingdirty_bitmapweonlyneedtokickallvcpusoutofguestmodeasifvcpusisinrootmodethePMLbuffermusthasbeenflushedalreadyNotePMLisneverenabledinhardwarewhilerunningL2ifenable_pmlis_guest_modevcpuvmx_flush_pml_buffervcpuKVMshouldneverreachthispointwithapendingnestedVMEnterMorespecificallyshortcircuitingVMEntrytoemulateL2duetoinvalidgueststateshouldneverhappenasthatmeansKVMknowinglyallowedanestedVMEnterwithaninvalidvmcs12MorebelowifKVM_BUG_ONvmxnestednested_run_pendingvcpukvmreturnEIOifis_guest_modevcpuPMLisneverenabledwhenrunningL2bailimmediatelyifaPMLfullexitoccursassomethingishorriblywrongifexit_reasonbasicEXIT_REASON_PML_FULLgotounexpected_vmexitThehostphysicaladdressesofsomepagesofguestmemoryareloadedintothevmcs02egvmcs12sVirt",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_ldt",
      "signature": "kvm_read_ldt",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0_bits",
      "signature": "kvm_read_cr0_bits",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr3",
      "signature": "kvm_read_cr3",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_and_reset_apf_flags",
      "signature": "kvm_read_and_reset_apf_flags",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_READ",
      "signature": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_READ",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_lapic_readable_reg_mask",
      "signature": "kvm_lapic_readable_reg_mask",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rundebugarchdr7vmcs_readl",
      "signature": "kvm_rundebugarchdr7vmcs_readl",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_cr_read",
      "signature": "kvm_cr_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_cr_write0kvm_read_cr0_bits",
      "signature": "kvm_cr_write0kvm_read_cr0_bits",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_drvcpudrkvm_register_read",
      "signature": "kvm_set_drvcpudrkvm_register_read",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_read"
    },
    {
      "function": "nested_vmx_load_msrstructkvm_vcpuvcpuu64gpau32countu32istructvmx_msr_entryeu32max_msr_list_sizenested_vmx_max_atomic_switch_msrsvcpufori0icountiifWARN_ON_ONCEimax_msr_list_sizegotofailifkvm_vcpu_read_guestvcpugpa",
      "signature": "nested_vmx_load_msrstructkvm_vcpuvcpuu64gpau32countu32istructvmx_msr_entryeu32max_msr_list_sizenested_vmx_max_atomic_switch_msrsvcpufori0icountiifWARN_ON_ONCEimax_msr_list_sizegotofailifkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "nested_vmx_store_msrstructkvm_vcpuvcpuu64gpau32countu64datau32istructvmx_msr_entryeu32max_msr_list_sizenested_vmx_max_atomic_switch_msrsvcpufori0icountiifWARN_ON_ONCEimax_msr_list_sizereturnEINVALifread_and_check_msr_entryvcpugpa",
      "signature": "nested_vmx_store_msrstructkvm_vcpuvcpuu64gpau32countu64datau32istructvmx_msr_entryeu32max_msr_list_sizenested_vmx_max_atomic_switch_msrsvcpufori0icountiifWARN_ON_ONCEimax_msr_list_sizereturnEINVALifread_and_check_msr_entryvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "nested_msr_store_list_has_msrstructkvm_vcpuvcpuu32msr_indexstructvmcs12vmcs12get_vmcs12vcpuu32countvmcs12vm_exit_msr_store_countu64gpavmcs12vm_exit_msr_store_addrstructvmx_msr_entryeu32ifori0icountiifread_and_check_msr_entryvcpugpa",
      "signature": "nested_msr_store_list_has_msrstructkvm_vcpuvcpuu32msr_indexstructvmcs12vmcs12get_vmcs12vcpuu32countvmcs12vm_exit_msr_store_countu64gpavmcs12vm_exit_msr_store_addrstructvmx_msr_entryeu32ifori0icountiifread_and_check_msr_entryvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "fori0ivmcs12vm_entry_msr_load_countigpavmcs12vm_entry_msr_load_addrisizeofgifkvm_vcpu_read_guestvcpugpa",
      "signature": "fori0ivmcs12vm_entry_msr_load_countigpavmcs12vm_entry_msr_load_addrisizeofgifkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "forj0jvmcs12vm_exit_msr_load_countjgpavmcs12vm_exit_msr_load_addrjsizeofhifkvm_vcpu_read_guestvcpugpa",
      "signature": "forj0jvmcs12vm_exit_msr_load_countjgpavmcs12vm_exit_msr_load_addrjsizeofhifkvm_vcpu_read_guestvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "handle_vmwritestructkvm_vcpuvcpustructvmcs12vmcs12is_guest_modevcpuget_shadow_vmcs12vcpuget_vmcs12vcpuunsignedlongexit_qualificationvmx_get_exit_qualvcpuu32instr_infovmcs_read32VMX_INSTRUCTION_INFOstructvcpu_vmxvmxto_vmxvcpustructx86_exceptioneunsignedlongfieldshortoffsetgva_tgvaintlenrThevaluetowritemightbe32or64bitsdependingonL1slongmodeandeventuallyweneedtowritethatintoafieldofseveralpossiblelengthsThecodebelowfirstzeroextendsthevalueto64bitvalueandthencopiesonlytheappropriatenumberofbitsintothevmcs12fieldu64value0ifnested_vmx_check_permissionvcpureturn1InVMXnonrootoperationwhentheVMCSlinkpointerisINVALID_GPAanyVMWRITEsetstheALUflagsforVMfailInvalidifvmxnestedcurrent_vmptrINVALID_GPAis_guest_modevcpuget_vmcs12vcpuvmcs_link_pointerINVALID_GPAreturnnested_vmx_failInvalidvcpuifinstr_infoBIT10valuekvm_register_readvcpuinstr_info30xfelselenis_64_bit_modevcpu84ifget_vmx_mem_addressvcpuexit_qualificationinstr_infofalselengvareturn1rkvm_read_guest_virtvcpugva",
      "signature": "handle_vmwritestructkvm_vcpuvcpustructvmcs12vmcs12is_guest_modevcpuget_shadow_vmcs12vcpuget_vmcs12vcpuunsignedlongexit_qualificationvmx_get_exit_qualvcpuu32instr_infovmcs_read32VMX_INSTRUCTION_INFOstructvcpu_vmxvmxto_vmxvcpustructx86_exceptioneunsignedlongfieldshortoffsetgva_tgvaintlenrThevaluetowritemightbe32or64bitsdependingonL1slongmodeandeventuallyweneedtowritethatintoafieldofseveralpossiblelengthsThecodebelowfirstzeroextendsthevalueto64bitvalueandthencopiesonlytheappropriatenumberofbitsintothevmcs12fieldu64value0ifnested_vmx_check_permissionvcpureturn1InVMXnonrootoperationwhentheVMCSlinkpointerisINVALID_GPAanyVMWRITEsetstheALUflagsforVMfailInvalidifvmxnestedcurrent_vmptrINVALID_GPAis_guest_modevcpuget_vmcs12vcpuvmcs_link_pointerINVALID_GPAreturnnested_vmx_failInvalidvcpuifinstr_infoBIT10valuekvm_register_readvcpuinstr_info30xfelselenis_64_bit_modevcpu84ifget_vmx_mem_addressvcpuexit_qualificationinstr_infofalselengvareturn1rkvm_read_guest_virtvcpugva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "kvm_read_guest_cached",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_l1_tsc",
      "signature": "kvm_read_l1_tsc",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_offset_cached",
      "signature": "kvm_read_guest_offset_cached",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_virt",
      "signature": "kvm_read_guest_virt",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr0",
      "signature": "kvm_read_cr0",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_cr4",
      "signature": "kvm_read_cr4",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "kvm_read_guest",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_pdptr_read",
      "signature": "kvm_pdptr_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_map_readonly",
      "signature": "kvm_vcpu_map_readonly",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "kvm_vcpu_read_guest",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_emulate_msr_read",
      "signature": "kvm_emulate_msr_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_nested_vmenterkvm_rip_read",
      "signature": "kvm_nested_vmenterkvm_rip_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rsp_read",
      "signature": "kvm_rsp_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_drvcpu7vmcs_readl",
      "signature": "kvm_set_drvcpu7vmcs_readl",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_register_read",
      "signature": "kvm_register_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rcx_read",
      "signature": "kvm_rcx_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "kvm_vcpu_read_guest_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_rax_read",
      "signature": "kvm_rax_read",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestvcpugpa",
      "signature": "read_guestvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_and_check_msr_entrystructkvm_vcpuvcpuu64gpa",
      "signature": "read_and_check_msr_entrystructkvm_vcpuvcpuu64gpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_and_check_msr_entryvcpugpa",
      "signature": "read_and_check_msr_entryvcpugpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_virtvcpugva",
      "signature": "read_guest_virtvcpugva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_stats_read",
      "signature": "ssize_t kvm_stats_read(char *id, const struct kvm_stats_header *header, const struct _kvm_stats_desc *desc, void *stats, size_t size_stats, char __user *user_buffer, size_t size, loff_t *offset)",
      "file": "virt/kvm/binary_stats.c",
      "category": "memory_read"
    },
    {
      "function": "check_memory_region_flagsstructkvmkvmconststructkvm_userspace_memory_region2memu32valid_flagsKVM_MEM_LOG_DIRTY_PAGESifIS_ENABLEDCONFIG_KVM_GUEST_MEMFDvalid_flagsKVM_MEM_GUEST_MEMFDDirtyloggingprivatememoryisnotcurrentlysupportedifmemflagsKVM_MEM_GUEST_MEMFDvalid_flagsKVM_MEM_LOG_DIRTY_PAGESGUEST_MEMFDisincompatiblewithreadonlymemslotsaswritestoreadonlymemslotshaveemulatedMMIOnotpagefaultsemanticsandKVMdoesntallowemulatedMMIOforprivatememoryifkvm_arch_has_readonly_mem",
      "signature": "check_memory_region_flagsstructkvmkvmconststructkvm_userspace_memory_region2memu32valid_flagsKVM_MEM_LOG_DIRTY_PAGESifIS_ENABLEDCONFIG_KVM_GUEST_MEMFDvalid_flagsKVM_MEM_GUEST_MEMFDDirtyloggingprivatememoryisnotcurrentlysupportedifmemflagsKVM_MEM_GUEST_MEMFDvalid_flagsKVM_MEM_LOG_DIRTY_PAGESGUEST_MEMFDisincompatiblewithreadonlymemslotsaswritestoreadonlymemslotshaveemulatedMMIOnotpagefaultsemanticsandKVMdoesntallowemulatedMMIOforprivatememoryifkvm_arch_has_readonly_mem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_commit_memory_regionstructkvmkvmstructkvm_memory_slotoldconststructkvm_memory_slotnewenumkvm_mr_changechangeintold_flagsoldoldflags0intnew_flagsnewnewflags0UpdatethetotalnumberofmemslotpagesbeforecallingthearchhooksothatarchitecturescanconsumetheresultdirectlyifchangeKVM_MR_DELETEkvmnr_memslot_pagesoldnpageselseifchangeKVM_MR_CREATEkvmnr_memslot_pagesnewnpagesifold_flagsnew_flagsKVM_MEM_LOG_DIRTY_PAGESintchangenew_flagsKVM_MEM_LOG_DIRTY_PAGES11atomic_setkvmnr_memslots_dirty_loggingatomic_readkvmnr_mem",
      "signature": "kvm_commit_memory_regionstructkvmkvmstructkvm_memory_slotoldconststructkvm_memory_slotnewenumkvm_mr_changechangeintold_flagsoldoldflags0intnew_flagsnewnewflags0UpdatethetotalnumberofmemslotpagesbeforecallingthearchhooksothatarchitecturescanconsumetheresultdirectlyifchangeKVM_MR_DELETEkvmnr_memslot_pagesoldnpageselseifchangeKVM_MR_CREATEkvmnr_memslot_pagesnewnpagesifold_flagsnew_flagsKVM_MEM_LOG_DIRTY_PAGESintchangenew_flagsKVM_MEM_LOG_DIRTY_PAGES11atomic_setkvmnr_memslots_dirty_loggingatomic_readkvmnr_mem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_memslotstructkvmkvmstructkvm_memory_slotoldstructkvm_memory_slotnewenumkvm_mr_changechangestructkvm_memory_slotinvalid_slotintrReleasedinkvm_swap_active_memslotsMustbeheldfrombeforethecurrentmemslotsarecopieduntilafterthenewmemslotsareinstalledwithrcu_assign_pointerthenreleasedbeforethesynchronizesrcuinkvm_swap_active_memslotsWhenmodifyingmemslotsoutsideoftheslots_lockmustbeheldbeforereadingthepointertothecurrentmem",
      "signature": "kvm_set_memslotstructkvmkvmstructkvm_memory_slotoldstructkvm_memory_slotnewenumkvm_mr_changechangestructkvm_memory_slotinvalid_slotintrReleasedinkvm_swap_active_memslotsMustbeheldfrombeforethecurrentmemslotsarecopieduntilafterthenewmemslotsareinstalledwithrcu_assign_pointerthenreleasedbeforethesynchronizesrcuinkvm_swap_active_memslotsWhenmodifyingmemslotsoutsideoftheslots_lockmustbeheldbeforereadingthepointertothecurrentmem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_set_memory_regionstructkvmkvmconststructkvm_userspace_memory_region2memstructkvm_memory_slotoldnewstructkvm_memslotsslotsenumkvm_mr_changechangeunsignedlongnpagesgfn_tbase_gfnintas_ididintrlockdep_assert_heldkvmslots_lockrcheck_memory_region_flagskvmmemifrreturnras_idmemslot16idu16memslotGeneralsanitychecksifmemmemory_sizePAGE_SIZE1memmemory_sizeunsignedlongmemmemory_sizereturnEINVALifmemguest_phys_addrPAGE_SIZE1returnEINVALWecanreadtheguestmem",
      "signature": "kvm_set_memory_regionstructkvmkvmconststructkvm_userspace_memory_region2memstructkvm_memory_slotoldnewstructkvm_memslotsslotsenumkvm_mr_changechangeunsignedlongnpagesgfn_tbase_gfnintas_ididintrlockdep_assert_heldkvmslots_lockrcheck_memory_region_flagskvmmemifrreturnras_idmemslot16idu16memslotGeneralsanitychecksifmemmemory_sizePAGE_SIZE1memmemory_sizeunsignedlongmemmemory_sizereturnEINVALifmemguest_phys_addrPAGE_SIZE1returnEINVALWecanreadtheguestmem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_enable_virtualization_cpuvoidif__this_cpu_readvirt",
      "signature": "kvm_enable_virtualization_cpuvoidif__this_cpu_readvirt",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_disable_virtualization_cpuvoidignif__this_cpu_readvirt",
      "signature": "kvm_disable_virtualization_cpuvoidignif__this_cpu_readvirt",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_page",
      "signature": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_atomic",
      "signature": "kvm_read_guest_atomic",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_offset_cached",
      "signature": "int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MEM_LOG_DIRTY_PAGESKVM_MEM_READONLY",
      "signature": "KVM_MEM_LOG_DIRTY_PAGESKVM_MEM_READONLY",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_has_readonly_mem",
      "signature": "kvm_arch_has_readonly_mem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_MEM_READONLY",
      "signature": "KVM_MEM_READONLY",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_GENERIC_DIRTYLOG_READ_PROTECT",
      "signature": "KVM_GENERIC_DIRTYLOG_READ_PROTECT",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_page",
      "signature": "KVM_INTERNALkvm_read_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_read_guest_page",
      "signature": "KVM_INTERNALkvm_vcpu_read_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest",
      "signature": "KVM_INTERNALkvm_read_guest",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_read_guest",
      "signature": "KVM_INTERNALkvm_vcpu_read_guest",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_atomic",
      "signature": "int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_read_guest_atomic",
      "signature": "KVM_INTERNALkvm_vcpu_read_guest_atomic",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_offset_cached",
      "signature": "KVM_INTERNALkvm_read_guest_offset_cached",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_read_guest_cached",
      "signature": "KVM_INTERNALkvm_read_guest_cached",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_stats_read",
      "signature": "ssize_t kvm_vcpu_stats_read(struct file *file, char __user *user_buffer, size_t size, loff_t *offset)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_stats_read",
      "signature": "return kvm_stats_read(vcpu->stats_id, &kvm_vcpu_stats_header, &kvm_vcpu_stats_desc[0], &vcpu->stat, sizeof(vcpu->stat), user_buffer, size, offset); } static int kvm_vcpu_stats_release(struct inode *inode, struct file *file)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_vm_stats_read",
      "signature": "ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer, size_t size, loff_t *offset)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_io_bus_read",
      "signature": "int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, void *val)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_iodevice_read",
      "signature": "kvm_iodevice_read",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "KVM_INTERNALkvm_io_bus_read",
      "signature": "KVM_INTERNALkvm_io_bus_read",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "read_gueststructkvmkvmgpa_tgpa",
      "signature": "read_gueststructkvmkvmgpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "read_gueststructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_gueststructkvm_vcpuvcpugpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicstructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_guest_atomicstructkvm_vcpuvcpugpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "read_guestkvmgpa",
      "signature": "read_guestkvmgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_async_page_ready",
      "signature": "kvm_arch_async_page_ready",
      "file": "virt/kvm/async_pf.c",
      "category": "memory_read"
    },
    {
      "function": "__kvm_gmem_get_pfnstructfilefilestructkvm_memory_slotslotpgoff_tindexkvm_pfn_tpfnboolis_preparedintmax_orderstructfilegmem_fileREAD_ONCEslotgmem",
      "signature": "__kvm_gmem_get_pfnstructfilefilestructkvm_memory_slotslotpgoff_tindexkvm_pfn_tpfnboolis_preparedintmax_orderstructfilegmem_fileREAD_ONCEslotgmem",
      "file": "virt/kvm/guest_memfd.c",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_has_readonly_memstructkvmkvmreturnIS_ENABLEDCONFIG_HAVE_KVM_READONLY_MEM",
      "signature": "kvm_arch_has_readonly_memstructkvmkvmreturnIS_ENABLEDCONFIG_HAVE_KVM_READONLY_MEM",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "mmu_invalidate_retry_gfn_unsafestructkvmkvmunsignedlongmmu_seqgfn_tgfnUseREAD_ONCEtoensuretheinprogressflagandsequencecounterarealwaysreadfrommem",
      "signature": "mmu_invalidate_retry_gfn_unsafestructkvmkvmunsignedlongmmu_seqgfn_tgfnUseREAD_ONCEtoensuretheinprogressflagandsequencecounterarealwaysreadfrommem",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_get_memory_attributesstructkvmkvmgfn_tgfnreturnxa_to_valuexa_loadkvmmem",
      "signature": "kvm_get_memory_attributesstructkvmkvmgfn_tgfnreturnxa_to_valuexa_loadkvmmem",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_page",
      "signature": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset, int len); int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len); int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest",
      "signature": "int kvm_read_guest(struct kvm *kvm, gpa_t gpa, void *data, unsigned long len); int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_cached",
      "signature": "int kvm_read_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_read_guest_offset_cached",
      "signature": "int kvm_read_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_io_bus_read",
      "signature": "int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, void *val); int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr, int len, struct kvm_io_device *dev); int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx, struct kvm_io_device *dev); struct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_arch_has_readonly_mem",
      "signature": "bool kvm_arch_has_readonly_mem(struct kvm *kvm)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_rip_read",
      "signature": "kvm_rip_read",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_lock",
      "signature": "void kvm_vcpu_srcu_read_lock(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_srcu_read_unlock",
      "signature": "void kvm_vcpu_srcu_read_unlock(struct kvm_vcpu *vcpu)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_map_readonly",
      "signature": "int kvm_vcpu_map_readonly(struct kvm_vcpu *vcpu, gpa_t gpa, struct kvm_host_map *map)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_page",
      "signature": "int kvm_vcpu_read_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, void *data, int offset, int len); int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest_atomic",
      "signature": "int kvm_vcpu_read_guest_atomic(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_vcpu_read_guest",
      "signature": "int kvm_vcpu_read_guest(struct kvm_vcpu *vcpu, gpa_t gpa, void *data, unsigned long len); int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "KVM_GENERIC_DIRTYLOG_READ_PROTECT",
      "signature": "KVM_GENERIC_DIRTYLOG_READ_PROTECT",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_memory_slotatomic_long_read",
      "signature": "kvm_memory_slotatomic_long_read",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "kvm_stats_read",
      "signature": "ssize_t kvm_stats_read(char *id, const struct kvm_stats_header *header, const struct _kvm_stats_desc *desc, void *stats, size_t size_stats, char __user *user_buffer, size_t size, loff_t *offset); /** * kvm_stats_linear_hist_update() - Update bucket value for linear histogram * statistics data. * * @data: start address of the stats data * @size: the number of bucket of the stats data * @value: the new value used to update the linear histogram's bucket * @bucket_size: the size (width) of a bucket */ static inline void kvm_stats_linear_hist_update(u64 *data, size_t size, u64 value, size_t bucket_size)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "read_gueststructkvmkvmgpa_tgpa",
      "signature": "read_gueststructkvmkvmgpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "read_guest_atomicstructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_guest_atomicstructkvm_vcpuvcpugpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "read_gueststructkvm_vcpuvcpugpa_tgpa",
      "signature": "read_gueststructkvm_vcpuvcpugpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_read"
    },
    {
      "function": "KVM_MEM_READONLY",
      "signature": "define KVM_MEM_READONLY (1UL << 1) #define KVM_MEM_GUEST_MEMFD (1UL << 2)",
      "file": "include/uapi/linux/kvm.h",
      "category": "memory_read"
    },
    {
      "function": "KVM_CAP_READONLY_MEM",
      "signature": "KVM_CAP_READONLY_MEM",
      "file": "include/uapi/linux/kvm.h",
      "category": "memory_read"
    }
  ],
  "memory_write": [
    {
      "function": "guest_cpuid_hasstructkvm_vcpuvcpuunsignedintx86_featureconststructcpuid_regcpuidx86_feature_cpuidx86_featurestructkvm_cpuid_entry2entryu32regXSAVESisaspecialsnowflakeDuetolackofadedicatedinterceptonSVMKVMmustassumethatXSAVESandthusXRSTORSisusablebytheguestifthehostsupportsXSAVESandXSAVEisexposedtotheguestBecausetheguestcanexecuteXSAVESandXRSTORSiecanindirectlyconsumeXSSKVMmustensureXSSiszeroedwhenrunningtheguestiemustsetXSAVESinvCPUcapabilitiesButtorejectdirectXSSreadsandwritestominimizethevirt",
      "signature": "guest_cpuid_hasstructkvm_vcpuvcpuunsignedintx86_featureconststructcpuid_regcpuidx86_feature_cpuidx86_featurestructkvm_cpuid_entry2entryu32regXSAVESisaspecialsnowflakeDuetolackofadedicatedinterceptonSVMKVMmustassumethatXSAVESandthusXRSTORSisusablebytheguestifthehostsupportsXSAVESandXSAVEisexposedtotheguestBecausetheguestcanexecuteXSAVESandXRSTORSiecanindirectlyconsumeXSSKVMmustensureXSSiszeroedwhenrunningtheguestiemustsetXSAVESinvCPUcapabilitiesButtorejectdirectXSSreadsandwritestominimizethevirt",
      "file": "arch/x86/kvm/cpuid.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write_nodecode",
      "signature": "void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset); void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector); int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr); void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu); void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu); int kvm_x2apic_icr_write_fast(struct kvm_lapic *apic, u64 data); int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_icr_write_fast",
      "signature": "int kvm_x2apic_icr_write_fast(struct kvm_lapic *apic, u64 data); int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_msr_write",
      "signature": "int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_hv_vapic_msr_write",
      "signature": "int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data); int kvm_lapic_set_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len); void kvm_lapic_exit(void); u64 kvm_lapic_readable_reg_mask(struct kvm_lapic *apic); static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)",
      "file": "arch/x86/kvm/lapic.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "int kvm_xen_write_hypercall_page(struct kvm_vcpu *vcpu, u64 data); int kvm_xen_hvm_config(struct kvm *kvm, struct kvm_xen_hvm_config *xhc); void kvm_xen_init_vm(struct kvm *kvm); void kvm_xen_destroy_vm(struct kvm *kvm); void kvm_xen_init_vcpu(struct kvm_vcpu *vcpu); void kvm_xen_destroy_vcpu(struct kvm_vcpu *vcpu); int kvm_xen_set_evtchn_fast(struct kvm_xen_evtchn *xe, struct kvm *kvm); int kvm_xen_setup_evtchn(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e, const struct kvm_irq_routing_entry *ue); static inline void kvm_xen_sw_enable_lapic(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/xen.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_system",
      "signature": "int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception); int handle_ud(struct kvm_vcpu *vcpu); void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu, struct kvm_queued_exception *ex); int kvm_mtrr_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data); int kvm_mtrr_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata); void kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code); int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type, void *insn, int insn_len); int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, int emulation_type, void *insn, int insn_len); fastpath_t handle_fastpath_wrmsr(struct kvm_vcpu *vcpu); fastpath_t handle_fastpath_wrmsr_imm(struct kvm_vcpu *vcpu, u32 msr, int reg); fastpath_t handle_fastpath_hlt(struct kvm_vcpu *vcpu); fastpath_t handle_fastpath_invd(struct kvm_vcpu *vcpu); extern struct kvm_caps kvm_caps; extern struct kvm_host_values kvm_host; extern bool enable_pmu; /* * Get a filtered version of KVM's supported XCR0 that strips out dynamic * features for which the current process doesn't (yet)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "void kvm_register_write(struct kvm_vcpu *vcpu, int reg, unsigned long val)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write_raw",
      "signature": "return kvm_register_write_raw(vcpu, reg, val); } static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t src, unsigned int bytes, void *dst); int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size, unsigned int port, void *data, unsigned int count, int in); static inline bool user_exit_on_hypercall(struct kvm *kvm, unsigned long hc_nr)",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt",
      "signature": "write_guest_virt",
      "file": "arch/x86/kvm/x86.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_tsc_offset",
      "signature": "kvm_write_tsc_offset",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write",
      "signature": "kvm_apic_write",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write",
      "signature": "kvm_msr_write",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write_ex",
      "signature": "kvm_msr_write_ex",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_cr_write",
      "signature": "kvm_cr_write",
      "file": "arch/x86/kvm/trace.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val, sizeof(val)); } static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_lapic_msr_write",
      "signature": "int kvm_lapic_msr_write(struct kvm_lapic *apic, u32 reg, u64 data); static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_lapic_reg_write",
      "signature": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write",
      "signature": "kvm_apic_write",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_icr_write",
      "signature": "int kvm_x2apic_icr_write(struct kvm_lapic *apic, u64 data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_icr_write_fast",
      "signature": "int kvm_x2apic_icr_write_fast(struct kvm_lapic *apic, u64 data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write_nodecode",
      "signature": "void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_apic_write_nodecode",
      "signature": "KVM_INTERNALkvm_apic_write_nodecode",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_msr_write",
      "signature": "int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_hv_vapic_msr_write",
      "signature": "int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)",
      "file": "arch/x86/kvm/lapic.c",
      "category": "memory_write"
    },
    {
      "function": "em_cmpxchgstructx86_emulate_ctxtctxtSaverealsourcevaluethencompareEAXagainstdestinationctxtdstorig_valctxtdstvalctxtdstvalreg_readctxtVCPU_REGS_RAXctxtsrcorig_valctxtsrcvalctxtsrcvalctxtdstorig_valem_cmpctxtifctxteflagsX86_EFLAGS_ZFSuccesswritebacktomem",
      "signature": "em_cmpxchgstructx86_emulate_ctxtctxtSaverealsourcevaluethencompareEAXagainstdestinationctxtdstorig_valctxtdstvalctxtdstvalreg_readctxtVCPU_REGS_RAXctxtsrcorig_valctxtsrcvalctxtsrcvalctxtdstorig_valem_cmpctxtifctxteflagsX86_EFLAGS_ZFSuccesswritebacktomem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "em_xchgstructx86_emulate_ctxtctxtWritebacktheregistersourcectxtsrcvalctxtdstvalwrite_register_operandctxtsrcWritebackthemem",
      "signature": "em_xchgstructx86_emulate_ctxtctxtWritebacktheregistersourcectxtsrcvalctxtdstvalwrite_register_operandctxtsrcWritebackthemem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "em_fxsavestructx86_emulate_ctxtctxtstructfxregs_statefx_stateintrcrccheck_fxsrctxtifrcX86EMUL_CONTINUEreturnrckvm_fpu_getrcasm_safefxsavefxfxmfx_statekvm_fpu_putifrcX86EMUL_CONTINUEreturnrcreturnsegmented_write_stdctxtctxtmemopaddrmem",
      "signature": "em_fxsavestructx86_emulate_ctxtctxtstructfxregs_statefx_stateintrcrccheck_fxsrctxtifrcX86EMUL_CONTINUEreturnrckvm_fpu_getrcasm_safefxsavefxfxmfx_statekvm_fpu_putifrcX86EMUL_CONTINUEreturnrcreturnsegmented_write_stdctxtctxtmemopaddrmem",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_sse_reg",
      "signature": "kvm_write_sse_reg",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_mmx_reg",
      "signature": "kvm_write_mmx_reg",
      "file": "arch/x86/kvm/emulate.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_lname_write",
      "signature": "kvm_lname_write",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write_raw",
      "signature": "void kvm_register_write_raw(struct kvm_vcpu *vcpu, int reg, unsigned long val)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsp_write",
      "signature": "void kvm_rsp_write(struct kvm_vcpu *vcpu, unsigned long val)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_pdptr_write",
      "signature": "void kvm_pdptr_write(struct kvm_vcpu *vcpu, int index, u64 value)",
      "file": "arch/x86/kvm/kvm_cache_regs.h",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALpmc_write_counter",
      "signature": "KVM_INTERNALpmc_write_counter",
      "file": "arch/x86/kvm/pmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_helpergva_taddrvoidvalunsignedintbytesstructkvm_vcpuvcpuu64accessstructx86_exceptionexceptionstructkvm_mmummuvcpuarchwalk_mmuvoiddatavalintrX86EMUL_CONTINUEwhilebytesgpa_tgpammugva_to_gpavcpummuaddraccessexceptionunsignedoffsetaddrPAGE_SIZE1unsignedtowriteminbytesunsignedPAGE_SIZEoffsetintretifgpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULTretkvm_vcpu_write_guestvcpugpa",
      "signature": "kvm_write_guest_virt_helpergva_taddrvoidvalunsignedintbytesstructkvm_vcpuvcpuu64accessstructx86_exceptionexceptionstructkvm_mmummuvcpuarchwalk_mmuvoiddatavalintrX86EMUL_CONTINUEwhilebytesgpa_tgpammugva_to_gpavcpummuaddraccessexceptionunsignedoffsetaddrPAGE_SIZE1unsignedtowriteminbytesunsignedPAGE_SIZEoffsetintretifgpaINVALID_GPAreturnX86EMUL_PROPAGATE_FAULTretkvm_vcpu_write_guestvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "emulator_write_stdstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionboolsystemstructkvm_vcpuvcpuemul_to_vcpuctxtu64accessPFERR_WRITE_MASKifsystemaccessPFERR_IMPLICIT_ACCESSelseifkvm_x86_callget_cplvcpu3accessPFERR_USER_MASKreturnkvm_write_guest_virt",
      "signature": "emulator_write_stdstructx86_emulate_ctxtctxtgva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionboolsystemstructkvm_vcpuvcpuemul_to_vcpuctxtu64accessPFERR_WRITE_MASKifsystemaccessPFERR_IMPLICIT_ACCESSelseifkvm_x86_callget_cplvcpu3accessPFERR_USER_MASKreturnkvm_write_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_systemstructkvm_vcpuvcpugva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionkvm_write_guest_virt_systemcanpullintonsofpagesvcpuarchl1tf_flush_l1dtruereturnkvm_write_guest_virt",
      "signature": "kvm_write_guest_virt_systemstructkvm_vcpuvcpugva_taddrvoidvalunsignedintbytesstructx86_exceptionexceptionkvm_write_guest_virt_systemcanpullintonsofpagesvcpuarchl1tf_flush_l1dtruereturnkvm_write_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "emulator_write_physstructkvm_vcpuvcpugpa_tgpaconstvoidvalintbytesintretretkvm_vcpu_write_guestvcpugpavalbytesifret0return0kvm_page_track_writevcpugpa",
      "signature": "emulator_write_physstructkvm_vcpuvcpugpa_tgpaconstvoidvalintbytesintretretkvm_vcpu_write_guestvcpugpavalbytesifret0return0kvm_page_track_writevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_emulatestructkvm_vcpuvcpugpa_tgpavoidvalintbytesreturnemulator_write_physvcpugpa",
      "signature": "write_emulatestructkvm_vcpuvcpugpa_tgpavoidvalintbytesreturnemulator_write_physvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_mmiostructkvm_vcpuvcpugpa_tgpaintbytesvoidvaltrace_kvm_mmioKVM_TRACE_MMIO_WRITEbytesgpavalreturnvcpu_mmio_writevcpugpa",
      "signature": "write_mmiostructkvm_vcpuvcpugpa_tgpaintbytesvoidvaltrace_kvm_mmioKVM_TRACE_MMIO_WRITEbytesgpavalreturnvcpu_mmio_writevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_writestructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledwrite_emultorread_write_mmiovcpugpa",
      "signature": "kvm_sev_es_mmio_writestructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledwrite_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_readstructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledread_emultorread_write_mmiovcpugpa",
      "signature": "kvm_sev_es_mmio_readstructkvm_vcpuvcpugpa_tgpaunsignedintbytesvoiddatainthandledstructkvm_mmio_fragmentfragifdatareturnEINVALhandledread_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_wall_clock",
      "signature": "void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock, int sec_hi_ofs)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "kvm_write_guest",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_system_time",
      "signature": "void kvm_write_system_time(struct kvm_vcpu *vcpu, gpa_t system_time, bool old_msr, bool host_initiated)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_tsc_offset",
      "signature": "kvm_write_tsc_offset",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_helper",
      "signature": "int kvm_write_guest_virt_helper(gva_t addr, void *val, unsigned int bytes, struct kvm_vcpu *vcpu, u64 access, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_system",
      "signature": "int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "return kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &reason, sizeof(reason)); } static inline int apf_put_user_ready(struct kvm_vcpu *vcpu, u32 token)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_offset_cached",
      "signature": "return kvm_write_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data, &token, offset, sizeof(token)); } static inline bool apf_pageready_slot_free(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdx_write",
      "signature": "kvm_rdx_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write",
      "signature": "int kvm_msr_write(struct kvm_vcpu *vcpu, u32 index, u64 data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_emulate_msr_write",
      "signature": "int kvm_emulate_msr_write(struct kvm_vcpu *vcpu, u32 index, u64 data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNAL__kvm_emulate_msr_write",
      "signature": "KVM_INTERNAL__kvm_emulate_msr_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_allowedvcpuindexKVM_MSR_FILTER_WRITE",
      "signature": "kvm_msr_allowedvcpuindexKVM_MSR_FILTER_WRITE",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_emulate_msr_write",
      "signature": "KVM_INTERNALkvm_emulate_msr_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "kvm_register_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write_ex",
      "signature": "kvm_msr_write_ex",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_icr_write_fast",
      "signature": "kvm_x2apic_icr_write_fast",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_tsc_multiplier",
      "signature": "void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier); static int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_tsc_offset",
      "signature": "void kvm_vcpu_write_tsc_offset(struct kvm_vcpu *vcpu, u64 l1_offset)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "return kvm_xen_write_hypercall_page(vcpu, data); switch (msr)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_x2apic_msr_write",
      "signature": "return kvm_x2apic_msr_write(vcpu, msr, data); case MSR_IA32_TSC_DEADLINE: kvm_set_lapic_tscdeadline_msr(vcpu, data); break; case MSR_IA32_TSC_ADJUST: if (guest_cpu_cap_has(vcpu, X86_FEATURE_TSC_ADJUST))",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_iodevice_write",
      "signature": "kvm_iodevice_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "kvm_io_bus_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "gpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva, struct x86_exception *exception)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_mmu_gva_to_gpa_write",
      "signature": "KVM_INTERNALkvm_mmu_gva_to_gpa_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_virt_system",
      "signature": "KVM_INTERNALkvm_write_guest_virt_system",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "endif kvm_rip_write(vcpu, regs->rip); kvm_set_rflags(vcpu, regs->rflags | X86_EFLAGS_FIXED); vcpu->arch.exception.pending = false; vcpu->arch.exception_vmexit.pending = false; kvm_make_request(KVM_REQ_EVENT, vcpu); } int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "kvm_page_track_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "signature": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write_raw",
      "signature": "kvm_register_write_raw",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rbx_write",
      "signature": "kvm_rbx_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rcx_write",
      "signature": "kvm_rcx_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsi_write",
      "signature": "kvm_rsi_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdi_write",
      "signature": "kvm_rdi_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsp_write",
      "signature": "kvm_rsp_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rbp_write",
      "signature": "kvm_rbp_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r8_write",
      "signature": "CONFIG_X86_64 kvm_r8_write(vcpu, regs->r8); kvm_r9_write(vcpu, regs->r9); kvm_r10_write(vcpu, regs->r10); kvm_r11_write(vcpu, regs->r11); kvm_r12_write(vcpu, regs->r12); kvm_r13_write(vcpu, regs->r13); kvm_r14_write(vcpu, regs->r14); kvm_r15_write(vcpu, regs->r15); #endif kvm_rip_write(vcpu, regs->rip); kvm_set_rflags(vcpu, regs->rflags | X86_EFLAGS_FIXED); vcpu->arch.exception.pending = false; vcpu->arch.exception_vmexit.pending = false; kvm_make_request(KVM_REQ_EVENT, vcpu); } int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r9_write",
      "signature": "kvm_r9_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r10_write",
      "signature": "kvm_r10_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r11_write",
      "signature": "kvm_r11_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r12_write",
      "signature": "kvm_r12_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r13_write",
      "signature": "kvm_r13_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r14_write",
      "signature": "kvm_r14_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_r15_write",
      "signature": "kvm_r15_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_pdptr_write",
      "signature": "kvm_pdptr_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_remove_write_access",
      "signature": "kvm_mmu_slot_remove_write_access",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "int kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes, void *data)",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_sev_es_mmio_write",
      "signature": "KVM_INTERNALkvm_sev_es_mmio_write",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_wall_clockstructkvmkvmgpa",
      "signature": "write_wall_clockstructkvmkvmgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_system_timestructkvm_vcpuvcpugpa",
      "signature": "write_system_timestructkvm_vcpuvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt_helpergva",
      "signature": "write_guest_virt_helpergva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_guestvcpugpa",
      "signature": "write_guestvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_stdstructx86_emulate_ctxtctxtgva",
      "signature": "write_stdstructx86_emulate_ctxtctxtgva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt",
      "signature": "write_guest_virt",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt_systemstructkvm_vcpuvcpugva",
      "signature": "write_guest_virt_systemstructkvm_vcpuvcpugva",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_physstructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_physstructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_emulatestructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_emulatestructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_exit_mmiostructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_physvcpugpa",
      "signature": "write_physvcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_emulatevcpugpa",
      "signature": "write_emulatevcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_mmiovcpugpa",
      "signature": "write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_exit_mmiovcpugpa",
      "signature": "write_exit_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "write_emultorread_write_mmiovcpugpa",
      "signature": "write_emultorread_write_mmiovcpugpa",
      "file": "arch/x86/kvm/x86.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_sse_reg",
      "signature": "void kvm_write_sse_reg(int reg, const sse128_t *data)",
      "file": "arch/x86/kvm/fpu.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_mmx_reg",
      "signature": "void kvm_write_mmx_reg(int reg, const u64 *data)",
      "file": "arch/x86/kvm/fpu.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "kvm_rip_write",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_emulate_msr_write",
      "signature": "kvm_emulate_msr_write",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_write",
      "signature": "kvm_msr_write",
      "file": "arch/x86/kvm/smm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "kvm_write_guest",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "kvm_vcpu_write_guest_page",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_hv_vapic_msr_write",
      "signature": "return kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data); case HV_X64_MSR_ICR: return kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data); case HV_X64_MSR_TPR: return kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data); case HV_X64_MSR_VP_RUNTIME: if (!host) return 1; hv_vcpu->runtime_offset = data - current_task_runtime_100ns(); break; case HV_X64_MSR_SCONTROL: case HV_X64_MSR_SVERSION: case HV_X64_MSR_SIEFP: case HV_X64_MSR_SIMP: case HV_X64_MSR_EOM: case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: return synic_set_msr(to_hv_synic(vcpu), msr, data, host)",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdx_write",
      "signature": "kvm_rdx_write",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "write_guestkvmgfn_to_gpa",
      "signature": "write_guestkvmgfn_to_gpa",
      "file": "arch/x86/kvm/hyperv.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rbx_write",
      "signature": "kvm_rbx_write",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rcx_write",
      "signature": "kvm_rcx_write",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdx_write",
      "signature": "kvm_rdx_write",
      "file": "arch/x86/kvm/cpuid.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "void kvm_mmu_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes); static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)",
      "file": "arch/x86/kvm/mmu.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_wall_clock",
      "signature": "mirrors kvm_write_wall_clock() except that it writes * directly through the pfn cache and doesn't mark the page dirty. */ wall_nsec = kvm_get_wall_clock_epoch(kvm); /* Paranoia checks on the 32-bit struct layout */ BUILD_BUG_ON(offsetof(struct compat_shared_info, wc) != 0x900); BUILD_BUG_ON(offsetof(struct compat_shared_info, arch.wc_sec_hi) != 0x924); BUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0); #ifdef CONFIG_X86_64 /* Paranoia checks on the 64-bit struct layout */ BUILD_BUG_ON(offsetof(struct shared_info, wc) != 0xc00); BUILD_BUG_ON(offsetof(struct shared_info, wc_sec_hi) != 0xc0c); if (IS_ENABLED(CONFIG_64BIT) && kvm->arch.xen.long_mode)",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_xen_write_hypercall_page",
      "signature": "int kvm_xen_write_hypercall_page(struct kvm_vcpu *vcpu, u64 data)",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/xen.c",
      "category": "memory_write"
    },
    {
      "function": "__avic_vcpu_loadstructkvm_vcpuvcpuintcpuenumavic_vcpu_actionactionstructkvm_svmkvm_svmto_kvm_svmvcpukvminth_physical_idkvm_cpu_get_apicidcpustructvcpu_svmsvmto_svmvcpuunsignedlongflagsu64entrylockdep_assert_preemption_disabledifWARN_ONh_physical_idAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKreturnifWARN_ON_ONCEvcpuvcpu_idsizeofentryPAGE_SIZEreturnGrabthepervCPUinterruptremappinglockeveniftheVMdoesnt_currently_haveassigneddevicesasthatcanchangeHoldingir_list_lockensuresthateithersvm_ir_list_addwillconsumeuptodateentryinformationorthatthistaskwillwaituntilsvm_ir_list_addcompletestosetthenewtargetpCPUraw_spin_lock_irqsavesvmir_list_lockflagsentrysvmavic_physical_id_entryWARN_ON_ONCEentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKentryAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKAVIC_PHYSICAL_ID_ENTRY_GA_LOG_INTRentryh_physical_idAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKsvmavic_physical_id_entryentryIfIPIvirtualizationisdisabledclearIsRunningwhenupdatingtheactualPhysicalIDtablesothattheCPUneverseesIsRunning1KeeptheAPICIDuptodateintheentrytominimizethechancesofthingsgoingsidewaysifhardwarepeeksattheIDifenable_ipiventryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKWRITE_ONCEkvm_svmavic_phys",
      "signature": "__avic_vcpu_loadstructkvm_vcpuvcpuintcpuenumavic_vcpu_actionactionstructkvm_svmkvm_svmto_kvm_svmvcpukvminth_physical_idkvm_cpu_get_apicidcpustructvcpu_svmsvmto_svmvcpuunsignedlongflagsu64entrylockdep_assert_preemption_disabledifWARN_ONh_physical_idAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKreturnifWARN_ON_ONCEvcpuvcpu_idsizeofentryPAGE_SIZEreturnGrabthepervCPUinterruptremappinglockeveniftheVMdoesnt_currently_haveassigneddevicesasthatcanchangeHoldingir_list_lockensuresthateithersvm_ir_list_addwillconsumeuptodateentryinformationorthatthistaskwillwaituntilsvm_ir_list_addcompletestosetthenewtargetpCPUraw_spin_lock_irqsavesvmir_list_lockflagsentrysvmavic_physical_id_entryWARN_ON_ONCEentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKentryAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKAVIC_PHYSICAL_ID_ENTRY_GA_LOG_INTRentryh_physical_idAVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASKentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKsvmavic_physical_id_entryentryIfIPIvirtualizationisdisabledclearIsRunningwhenupdatingtheactualPhysicalIDtablesothattheCPUneverseesIsRunning1KeeptheAPICIDuptodateintheentrytominimizethechancesofthingsgoingsidewaysifhardwarepeeksattheIDifenable_ipiventryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKWRITE_ONCEkvm_svmavic_phys",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_write"
    },
    {
      "function": "__avic_vcpu_putstructkvm_vcpuvcpuenumavic_vcpu_actionactionstructkvm_svmkvm_svmto_kvm_svmvcpukvmstructvcpu_svmsvmto_svmvcpuunsignedlongflagsu64entrysvmavic_physical_id_entrylockdep_assert_preemption_disabledifWARN_ON_ONCEvcpuvcpu_idsizeofentryPAGE_SIZEreturnTakeandholdthepervCPUinterruptremappinglockwhileupdatingthePhysicalIDentryeventhoughthelockdoesntprotectagainstmultiplewritersseeaboveHoldingir_list_lockensuresthateithersvm_ir_list_addwillconsumeuptodateentryinformationorthatthistaskwillwaituntilsvm_ir_list_addcompletestomarkthevCPUasnotrunningraw_spin_lock_irqsavesvmir_list_lockflagsavic_update_iommu_vcpu_affinityvcpu1actionWARN_ON_ONCEentryAVIC_PHYSICAL_ID_ENTRY_GA_LOG_INTRKeepthepreviousAPICIDintheentrysothataroguedoorbellfromhardwareisatleastrestrictedtoaCPUassociatedwiththevCPUentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKifenable_ipivWRITE_ONCEkvm_svmavic_phys",
      "signature": "__avic_vcpu_putstructkvm_vcpuvcpuenumavic_vcpu_actionactionstructkvm_svmkvm_svmto_kvm_svmvcpukvmstructvcpu_svmsvmto_svmvcpuunsignedlongflagsu64entrysvmavic_physical_id_entrylockdep_assert_preemption_disabledifWARN_ON_ONCEvcpuvcpu_idsizeofentryPAGE_SIZEreturnTakeandholdthepervCPUinterruptremappinglockwhileupdatingthePhysicalIDentryeventhoughthelockdoesntprotectagainstmultiplewritersseeaboveHoldingir_list_lockensuresthateithersvm_ir_list_addwillconsumeuptodateentryinformationorthatthistaskwillwaituntilsvm_ir_list_addcompletestomarkthevCPUasnotrunningraw_spin_lock_irqsavesvmir_list_lockflagsavic_update_iommu_vcpu_affinityvcpu1actionWARN_ON_ONCEentryAVIC_PHYSICAL_ID_ENTRY_GA_LOG_INTRKeepthepreviousAPICIDintheentrysothataroguedoorbellfromhardwareisatleastrestrictedtoaCPUassociatedwiththevCPUentryAVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASKifenable_ipivWRITE_ONCEkvm_svmavic_phys",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write_nodecode",
      "signature": "kvm_apic_write_nodecode",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_write"
    },
    {
      "function": "WRITE_ONCEkvm_svmavic_phys",
      "signature": "WRITE_ONCEkvm_svmavic_phys",
      "file": "arch/x86/kvm/svm/avic.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "kvm_write_guest",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_emulate_msr_write",
      "signature": "kvm_emulate_msr_write",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_sev_es_mmio_write",
      "signature": "kvm_sev_es_mmio_write",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_write"
    },
    {
      "function": "write_guestkvmresp_gpa",
      "signature": "write_guestkvmresp_gpa",
      "file": "arch/x86/kvm/svm/sev.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "kvm_rip_write",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_WRITE",
      "signature": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_WRITE",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_cr_write",
      "signature": "kvm_cr_write",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "kvm_register_write",
      "file": "arch/x86/kvm/svm/svm.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsp_write",
      "signature": "kvm_rsp_write",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "kvm_rip_write",
      "file": "arch/x86/kvm/svm/nested.c",
      "category": "memory_write"
    },
    {
      "function": "__kvm_page_track_write_tracking_allocstructkvm_memory_slotslotunsignedlongnpagesconstsize_tsizesizeofslotarchgfn_write_trackifslotarchgfn_write_trackslotarchgfn_write_track__vcallocnpagessizeGFP_KERNEL_ACCOUNTreturnslotarchgfn_write_track0ENOMEM",
      "signature": "__kvm_page_track_write_tracking_allocstructkvm_memory_slotslotunsignedlongnpagesconstsize_tsizesizeofslotarchgfn_write_trackifslotarchgfn_write_trackslotarchgfn_write_track__vcallocnpagessizeGFP_KERNEL_ACCOUNTreturnslotarchgfn_write_track0ENOMEM",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "__kvm_page_track_writestructkvmkvmgpa_tgpaconstu8newintbytesstructkvm_page_track_notifier_headheadstructkvm_page_track_notifier_nodenintidxheadkvmarchtrack_notifier_headifhlist_emptyheadtrack_notifier_listreturnidxsrcu_read_lockheadtrack_srcuhlist_for_each_entry_srcunheadtrack_notifier_listnodesrcu_read_lock_heldheadtrack_srcuifntrack_writentrack_writegpa",
      "signature": "__kvm_page_track_writestructkvmkvmgpa_tgpaconstu8newintbytesstructkvm_page_track_notifier_headheadstructkvm_page_track_notifier_nodenintidxheadkvmarchtrack_notifier_headifhlist_emptyheadtrack_notifier_listreturnidxsrcu_read_lockheadtrack_srcuhlist_for_each_entry_srcunheadtrack_notifier_listnodesrcu_read_lock_heldheadtrack_srcuifntrack_writentrack_writegpa",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_add_gfn",
      "signature": "int kvm_write_track_add_gfn(struct kvm *kvm, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_remove_gfn",
      "signature": "int kvm_write_track_remove_gfn(struct kvm *kvm, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_external_write_tracking_enabled",
      "signature": "bool kvm_external_write_tracking_enabled(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_EXTERNAL_WRITE_TRACKING",
      "signature": "KVM_EXTERNAL_WRITE_TRACKING",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_enable",
      "signature": "in kvm_page_track_write_tracking_enable(). */ return smp_load_acquire(&kvm->arch.external_write_tracking_enabled); #else return false; #endif } bool kvm_page_track_write_tracking_enabled(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "bool kvm_page_track_write_tracking_enabled(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_BUG_ONkvm_page_track_write_tracking_enabled",
      "signature": "KVM_BUG_ONkvm_page_track_write_tracking_enabled",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "kvm_mmu_slot_gfn_write_protect",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_gfn_is_write_tracked",
      "signature": "bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_enable_external_write_tracking",
      "signature": "int kvm_enable_external_write_tracking(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "kvm_page_track_write",
      "file": "arch/x86/kvm/mmu/page_track.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_spte_atomic",
      "signature": "u64 kvm_tdp_mmu_write_spte_atomic(tdp_ptep_t sptep, u64 new_spte)",
      "file": "arch/x86/kvm/mmu/tdp_iter.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_spte",
      "signature": "u64 kvm_tdp_mmu_write_spte(tdp_ptep_t sptep, u64 old_spte, u64 new_spte, int level)",
      "file": "arch/x86/kvm/mmu/tdp_iter.h",
      "category": "memory_write"
    },
    {
      "function": "__kvm_mmu_unprotect_gfn_and_retrystructkvm_vcpuvcpugpa_tcr2_or_gpaboolalways_retrystructkvmkvmvcpukvmLIST_HEADinvalid_liststructkvm_mmu_pagespgpa_tgpacr2_or_gpaboolrfalseBailearlyiftherearentanywriteprotectedshadowpagestoavoidunnecessarilytakingmmu_locklockegifthegfniswritetrackedbyathirdpartyReadingindirect_shadow_pageswithoutholdingmmu_lockissafeasthisispurelyanoptimizationieafalsepositiveisbenignandafalsenegativewillsimplyresultinKVMskippingtheunprotectretrypathwhichisalsoanoptimizationifREAD_ONCEkvmarchindirect_shadow_pagesgotooutifvcpuarchmmuroot_roledirectgpakvm_mmu_gva_to_gpa_writevcpucr2_or_gpa",
      "signature": "__kvm_mmu_unprotect_gfn_and_retrystructkvm_vcpuvcpugpa_tcr2_or_gpaboolalways_retrystructkvmkvmvcpukvmLIST_HEADinvalid_liststructkvm_mmu_pagespgpa_tgpacr2_or_gpaboolrfalseBailearlyiftherearentanywriteprotectedshadowpagestoavoidunnecessarilytakingmmu_locklockegifthegfniswritetrackedbyathirdpartyReadingindirect_shadow_pageswithoutholdingmmu_lockissafeasthisispurelyanoptimizationieafalsepositiveisbenignandafalsenegativewillsimplyresultinKVMskippingtheunprotectretrypathwhichisalsoanoptimizationifREAD_ONCEkvmarchindirect_shadow_pagesgotooutifvcpuarchmmuroot_roledirectgpakvm_mmu_gva_to_gpa_writevcpucr2_or_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "mmio_info_in_cachestructkvm_vcpuvcpuu64addrbooldirectAnestedguestcannotusetheMMIOcacheifitisusingnestedpagetablesbecausecr2isanGPAwhilethecachestoresGPA",
      "signature": "mmio_info_in_cachestructkvm_vcpuvcpuu64addrbooldirectAnestedguestcannotusetheMMIOcacheifitisusingnestedpagetablesbecausecr2isanGPAwhilethecachestoresGPA",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytesgfn_tgfngpaPAGE_SHIFTstructkvm_mmu_pagespLIST_HEADinvalid_listu64entrygentryspteintnpteboolflushfalseWhenemulatingguestwritesensurethewrittenvalueisvisibletoanytaskthatishandlingpagefaultsbeforecheckingwhetherornotKVMisshadowingaguestPTEThisensureseitherKVMwillcreatethecorrectSPTEinthepagefaulthandlerorthistaskwillseeanonzeroindirect_shadow_pagesPairswiththesmp_mbinaccount_shadowedsmp_mbifvcpukvmarchindirect_shadow_pagesreturnwrite_lockvcpukvmmmu_lockgentrymmu_pte_write_fetch_gptevcpugpabytesvcpukvmstatmmu_pte_writefor_each_gfn_valid_sp_with_gptesvcpukvmspgfnifdetect_write_misalignedspgpa",
      "signature": "kvm_mmu_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytesgfn_tgfngpaPAGE_SHIFTstructkvm_mmu_pagespLIST_HEADinvalid_listu64entrygentryspteintnpteboolflushfalseWhenemulatingguestwritesensurethewrittenvalueisvisibletoanytaskthatishandlingpagefaultsbeforecheckingwhetherornotKVMisshadowingaguestPTEThisensureseitherKVMwillcreatethecorrectSPTEinthepagefaulthandlerorthistaskwillseeanonzeroindirect_shadow_pagesPairswiththesmp_mbinaccount_shadowedsmp_mbifvcpukvmarchindirect_shadow_pagesreturnwrite_lockvcpukvmmmu_lockgentrymmu_pte_write_fetch_gptevcpugpabytesvcpukvmstatmmu_pte_writefor_each_gfn_valid_sp_with_gptesvcpukvmspgfnifdetect_write_misalignedspgpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_zap_memslot_pages_and_flushstructkvmkvmstructkvm_memory_slotslotboolflushLIST_HEADinvalid_listunsignedlongiiflist_emptykvmarchactive_mmu_pagesgotoout_flushSinceaccountinginformationisstoredinstructkvm_arch_mem",
      "signature": "kvm_mmu_zap_memslot_pages_and_flushstructkvmkvmstructkvm_memory_slotslotboolflushLIST_HEADinvalid_listunsignedlongiiflist_emptykvmarchactive_mmu_pagesgotoout_flushSinceaccountinginformationisstoredinstructkvm_arch_mem",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_add_gfn",
      "signature": "kvm_write_track_add_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_remove_gfn",
      "signature": "kvm_write_track_remove_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "in kvm_mmu_track_write(). */ smp_mb(); gfn = sp->gfn; slots = kvm_memslots_for_spte_role(kvm, sp->role); slot = __gfn_to_memslot(slots, gfn); /* the non-leaf shadow pages are keeping readonly. */ if (sp->role.level > PG_LEVEL_4K) return __kvm_write_track_add_gfn(kvm, slot, gfn); kvm_mmu_gfn_disallow_lpage(slot, gfn); if (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn, PG_LEVEL_4K)) kvm_flush_remote_tlbs_gfn(kvm, gfn, PG_LEVEL_4K); } void track_possible_nx_huge_page(struct kvm *kvm, struct kvm_mmu_page *sp, enum kvm_mmu_type mmu_type)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm, struct kvm_memory_slot *slot, u64 gfn, int min_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_write_protect_pt_masked",
      "signature": "void kvm_mmu_write_protect_pt_masked(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn_offset, unsigned long mask)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_protect_gfn",
      "signature": "kvm_tdp_mmu_write_protect_gfn",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_protect_gfn",
      "signature": "bool kvm_vcpu_write_protect_gfn(struct kvm_vcpu *vcpu, u64 gfn)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "kvm_mmu_gva_to_gpa_write",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_gfn_is_write_tracked",
      "signature": "kvm_gfn_is_write_tracked",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "kvm_page_track_write_tracking_enabled",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "kvm_page_track_write_tracking_alloc",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_write_protect_fault",
      "signature": "int kvm_mmu_write_protect_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code, int *emulation_type)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_remove_write_access",
      "signature": "void kvm_mmu_slot_remove_write_access(struct kvm *kvm, const struct kvm_memory_slot *memslot, int start_level)",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_fetch_gptestructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_fetch_gptestructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_misalignedstructkvm_mmu_pagespgpa_tgpa",
      "signature": "write_misalignedstructkvm_mmu_pagespgpa_tgpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_fetch_gptevcpugpa",
      "signature": "write_fetch_gptevcpugpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_misalignedspgpa",
      "signature": "write_misalignedspgpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_protect_faultstructkvm_vcpuvcpugpa_tcr2_or_gpa",
      "signature": "write_protect_faultstructkvm_vcpuvcpugpa_tcr2_or_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "write_protect_faultvcpucr2_or_gpa",
      "signature": "write_protect_faultvcpucr2_or_gpa",
      "file": "arch/x86/kvm/mmu/mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "bool kvm_mmu_page_ad_need_write_protect(struct kvm *kvm, struct kvm_mmu_page *sp)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_slot_gfn_write_protect",
      "signature": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm, struct kvm_memory_slot *slot, u64 gfn, int min_level); /* Flush the given page (huge or not) of guest memory. */ static inline void kvm_flush_remote_tlbs_gfn(struct kvm *kvm, gfn_t gfn, int level)",
      "file": "arch/x86/kvm/mmu/mmu_internal.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "kvm_mmu_page_ad_need_write_protect",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_set_mmio_spte_maskmaskmaskACC_WRITE_MASK",
      "signature": "kvm_mmu_set_mmio_spte_maskmaskmaskACC_WRITE_MASK",
      "file": "arch/x86/kvm/mmu/spte.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_protect_gfn",
      "signature": "bool kvm_tdp_mmu_write_protect_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, int min_level); void kvm_tdp_mmu_try_split_huge_pages(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t start, gfn_t end, int target_level, bool shared); static inline void kvm_tdp_mmu_walk_lockless_begin(void)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytes__kvm_page_track_writevcpukvmgpanewbyteskvm_mmu_track_writevcpugpa",
      "signature": "kvm_page_track_writestructkvm_vcpuvcpugpa_tgpaconstu8newintbytes__kvm_page_track_writevcpukvmgpanewbyteskvm_mmu_track_writevcpugpa",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_add_gfn",
      "signature": "kvm_write_track_add_gfn",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_track_remove_gfn",
      "signature": "kvm_write_track_remove_gfn",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_enabled",
      "signature": "bool kvm_page_track_write_tracking_enabled(struct kvm *kvm); int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot); void kvm_page_track_free_memslot(struct kvm_memory_slot *slot); int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages); void __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); void __kvm_write_track_remove_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write_tracking_alloc",
      "signature": "int kvm_page_track_write_tracking_alloc(struct kvm_memory_slot *slot); void kvm_page_track_free_memslot(struct kvm_memory_slot *slot); int kvm_page_track_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot, unsigned long npages); void __kvm_write_track_add_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); void __kvm_write_track_remove_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn); bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_gfn_is_write_tracked",
      "signature": "bool kvm_gfn_is_write_tracked(struct kvm *kvm, const struct kvm_memory_slot *slot, gfn_t gfn); #ifdef CONFIG_KVM_EXTERNAL_WRITE_TRACKING int kvm_page_track_init(struct kvm *kvm); void kvm_page_track_cleanup(struct kvm *kvm); void __kvm_page_track_write(struct kvm *kvm, gpa_t gpa, const u8 *new, int bytes); void kvm_page_track_delete_slot(struct kvm *kvm, struct kvm_memory_slot *slot); static inline bool kvm_page_track_has_external_user(struct kvm *kvm)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "KVM_EXTERNAL_WRITE_TRACKING",
      "signature": "KVM_EXTERNAL_WRITE_TRACKING",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_page_track_write",
      "signature": "void kvm_page_track_write(struct kvm_vcpu *vcpu, gpa_t gpa, const u8 *new, int bytes)",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_track_write",
      "signature": "kvm_mmu_track_write",
      "file": "arch/x86/kvm/mmu/page_track.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_spte_need_atomic_write",
      "signature": "in kvm_tdp_mmu_spte_need_atomic_write(). */ #define for_each_tdp_mmu_root_rcu(_kvm, _root, _as_id, _types) \\ list_for_each_entry_rcu(_root, &_kvm->arch.tdp_mmu_roots, link) \\ if ((_as_id >= 0 && kvm_mmu_page_as_id(_root) != _as_id) || \\ !tdp_mmu_root_match((_root), (_types)))",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_spte_atomic",
      "signature": "kvm_tdp_mmu_write_spte_atomic",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_spte",
      "signature": "kvm_tdp_mmu_write_spte",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_page_ad_need_write_protect",
      "signature": "return kvm_mmu_page_ad_need_write_protect(kvm, sp) || !kvm_ad_enabled; } static void clear_dirty_gfn_range(struct kvm *kvm, struct kvm_mmu_page *root, gfn_t start, gfn_t end)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_tdp_mmu_write_protect_gfn",
      "signature": "bool kvm_tdp_mmu_write_protect_gfn(struct kvm *kvm, struct kvm_memory_slot *slot, gfn_t gfn, int min_level)",
      "file": "arch/x86/kvm/mmu/tdp_mmu.c",
      "category": "memory_write"
    },
    {
      "function": "sgx_gva_to_gpastructkvm_vcpuvcpugva_tgvaboolwritegpa_tgpastructx86_exceptionexifwritegpakvm_mmu_gva_to_gpa_writevcpugva",
      "signature": "sgx_gva_to_gpastructkvm_vcpuvcpugva_tgvaboolwritegpa_tgpastructx86_exceptionexifwritegpakvm_mmu_gva_to_gpa_writevcpugva",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmu_gva_to_gpa_write",
      "signature": "kvm_mmu_gva_to_gpa_write",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/vmx/sgx.c",
      "category": "memory_write"
    },
    {
      "function": "tdx_mmio_writestructkvm_vcpuvcpugpa_tgpaintsizeunsignedlongvalifkvm_io_bus_writevcpuKVM_FAST_MMIO_BUSgpa",
      "signature": "tdx_mmio_writestructkvm_vcpuvcpugpa_tgpaintsizeunsignedlongvalifkvm_io_bus_writevcpuKVM_FAST_MMIO_BUSgpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "tdx_emulate_mmiostructkvm_vcpuvcpustructvcpu_tdxtdxto_tdxvcpuintsizewriterunsignedlongvalgpa_tgpasizetdxvp_enter_argsr12writetdxvp_enter_argsr13gpatdxvp_enter_argsr14valwritetdxvp_enter_argsr150ifsize1size2size4size8gotoerrorifwrite0write1gotoerrorTDGVPVMCALLMMIOallowsonlysharedGPAitmakesnosensetodoMMIOemulationforprivateGPAifvt_is_tdx_private_gpavcpukvmgpavt_is_tdx_private_gpavcpukvmgpasize1gotoerrorgpagpagfn_to_gpakvm_gfn_direct_bitsvcpukvmifwritertdx_mmio_writevcpugpa",
      "signature": "tdx_emulate_mmiostructkvm_vcpuvcpustructvcpu_tdxtdxto_tdxvcpuintsizewriterunsignedlongvalgpa_tgpasizetdxvp_enter_argsr12writetdxvp_enter_argsr13gpatdxvp_enter_argsr14valwritetdxvp_enter_argsr150ifsize1size2size4size8gotoerrorifwrite0write1gotoerrorTDGVPVMCALLMMIOallowsonlysharedGPAitmakesnosensetodoMMIOemulationforprivateGPAifvt_is_tdx_private_gpavcpukvmgpavt_is_tdx_private_gpavcpukvmgpasize1gotoerrorgpagpagfn_to_gpakvm_gfn_direct_bitsvcpukvmifwritertdx_mmio_writevcpugpa",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rax_write",
      "signature": "kvm_rax_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rbx_write",
      "signature": "kvm_rbx_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rcx_write",
      "signature": "kvm_rcx_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rdx_write",
      "signature": "kvm_rdx_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsi_write",
      "signature": "kvm_rsi_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "kvm_io_bus_write",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "signature": "kvm_mmioKVM_TRACE_MMIO_WRITE",
      "file": "arch/x86/kvm/vmx/tdx.c",
      "category": "memory_write"
    },
    {
      "function": "init_vmcsstructvcpu_vmxvmxstructkvmkvmvmxvcpukvmstructkvm_vmxkvm_vmxto_kvm_vmxkvmifnestednested_vmx_set_vmcs_shadowing_bitmapifcpu_has_vmx_msr_bitmapvmcs_write64MSR_BITMAP__pavmxvmcs01msr_bitmapvmcs_write64VMCS_LINK_POINTERINVALID_GPA",
      "signature": "init_vmcsstructvcpu_vmxvmxstructkvmkvmvmxvcpukvmstructkvm_vmxkvm_vmxto_kvm_vmxkvmifnestednested_vmx_set_vmcs_shadowing_bitmapifcpu_has_vmx_msr_bitmapvmcs_write64MSR_BITMAP__pavmxvmcs01msr_bitmapvmcs_write64VMCS_LINK_POINTERINVALID_GPA",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "ifenable_pmlvmcs_write64PML_ADDRESSpage_to_phys",
      "signature": "ifenable_pmlvmcs_write64PML_ADDRESSpage_to_phys",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "handle_ept_misconfigstructkvm_vcpuvcpugpa_tgpaifvmx_check_emulate_instructionvcpuEMULTYPE_PFNULL0return1AnestedguestcannotoptimizeMMIOvmexitsbecausewehaveannGPAhereinsteadoftherequiredGPAgpavmcs_read64GUEST_PHYSICAL_ADDRESSifis_guest_modevcpukvm_io_bus_writevcpuKVM_FAST_MMIO_BUSgpa",
      "signature": "handle_ept_misconfigstructkvm_vcpuvcpugpa_tgpaifvmx_check_emulate_instructionvcpuEMULTYPE_PFNULL0return1AnestedguestcannotoptimizeMMIOvmexitsbecausewehaveannGPAhereinsteadoftherequiredGPAgpavmcs_read64GUEST_PHYSICAL_ADDRESSifis_guest_modevcpukvm_io_bus_writevcpuKVM_FAST_MMIO_BUSgpa",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "endif kvm_rip_write(vcpu, rip)",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_WRITE",
      "signature": "kvm_msr_allowedvcpumsrKVM_MSR_FILTER_WRITE",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_cr_write",
      "signature": "kvm_cr_write",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "kvm_register_write",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_apic_write_nodecode",
      "signature": "kvm_apic_write_nodecode",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "kvm_io_bus_write",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_faultin_pfnslotgfnFOLL_WRITE",
      "signature": "kvm_faultin_pfnslotgfnFOLL_WRITE",
      "file": "arch/x86/kvm/vmx/vmx.c",
      "category": "memory_write"
    },
    {
      "function": "vmx_disable_shadow_vmcsstructvcpu_vmxvmxsecondary_exec_controls_clearbitvmxSECONDARY_EXEC_SHADOW_VMCSvmcs_write64VMCS_LINK_POINTERINVALID_GPA",
      "signature": "vmx_disable_shadow_vmcsstructvcpu_vmxvmxsecondary_exec_controls_clearbitvmxSECONDARY_EXEC_SHADOW_VMCSvmcs_write64VMCS_LINK_POINTERINVALID_GPA",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "prepare_vmcs02_early_rarestructvcpu_vmxvmxstructvmcs12vmcs12prepare_vmcs02_constant_statevmxvmcs_write64VMCS_LINK_POINTERINVALID_GPAIfVPIDisdisabledthenguestTLBaccessesuseVPID0iethesameVPIDasthehostEmulatethisbehaviorbyusingvpid01forL2ifVPIDisdisabledinvmcs12NoteifVPIDisdisabledVMEnterandVMExitarearchitecturallyrequiredtoflushVPID0butonlyVPID0Ieusingvpid02wouldbeoksolongasKVMemulatestherequiredflushesbutdoingsowouldcauseKVMtooverflushEgifL1runsL2XwithVPID121thenrunsL2YwithVPID12disabledandthenrunsL2XagainthenKVMcanandshouldretainTLBentriesforVPID121ifenable_vpidifnested_cpu_has_vpidvmcs12vmxnestedvpid02vmcs_write16VIRTUAL_PROCESSOR_IDvmxnestedvpid02elsevmcs_write16VIRT",
      "signature": "prepare_vmcs02_early_rarestructvcpu_vmxvmxstructvmcs12vmcs12prepare_vmcs02_constant_statevmxvmcs_write64VMCS_LINK_POINTERINVALID_GPAIfVPIDisdisabledthenguestTLBaccessesuseVPID0iethesameVPIDasthehostEmulatethisbehaviorbyusingvpid01forL2ifVPIDisdisabledinvmcs12NoteifVPIDisdisabledVMEnterandVMExitarearchitecturallyrequiredtoflushVPID0butonlyVPID0Ieusingvpid02wouldbeoksolongasKVMemulatestherequiredflushesbutdoingsowouldcauseKVMtooverflushEgifL1runsL2XwithVPID121thenrunsL2YwithVPID12disabledandthenrunsL2XagainthenKVMcanandshouldretainTLBentriesforVPID121ifenable_vpidifnested_cpu_has_vpidvmcs12vmxnestedvpid02vmcs_write16VIRTUAL_PROCESSOR_IDvmxnestedvpid02elsevmcs_write16VIRT",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "handle_vmptrststructkvm_vcpuvcpuunsignedlongexit_qualvmx_get_exit_qualvcpuu32instr_infovmcs_read32VMX_INSTRUCTION_INFOgpa_tcurrent_vmptrto_vmxvcpunestedcurrent_vmptrstructx86_exceptionegva_tgvaintrifnested_vmx_check_permissionvcpureturn1ifunlikelynested_vmx_is_evmptr12_validto_vmxvcpureturn1ifget_vmx_mem_addressvcpuexit_qualinstr_infotruesizeofgpa_tgvareturn1_systemoknested_vmx_check_permissionhasverifiedcpl0rkvm_write_guest_virt_systemvcpugva",
      "signature": "handle_vmptrststructkvm_vcpuvcpuunsignedlongexit_qualvmx_get_exit_qualvcpuu32instr_infovmcs_read32VMX_INSTRUCTION_INFOgpa_tcurrent_vmptrto_vmxvcpunestedcurrent_vmptrstructx86_exceptionegva_tgvaintrifnested_vmx_check_permissionvcpureturn1ifunlikelynested_vmx_is_evmptr12_validto_vmxvcpureturn1ifget_vmx_mem_addressvcpuexit_qualinstr_infotruesizeofgpa_tgvareturn1_systemoknested_vmx_check_permissionhasverifiedcpl0rkvm_write_guest_virt_systemvcpugva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "kvm_write_guest_cached",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "kvm_write_guest_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_virt_system",
      "signature": "kvm_write_guest_virt_system",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_emulate_msr_write",
      "signature": "kvm_emulate_msr_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "kvm_vcpu_write_guest",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rsp_write",
      "signature": "kvm_rsp_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_rip_write",
      "signature": "kvm_rip_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "kvm_vcpu_write_guest_page",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_register_write",
      "signature": "kvm_register_write",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "write_pml_bufferstructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_pml_bufferstructkvm_vcpuvcpugpa_tgpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_pagevcpukvmgpa_to_gfndstgpa",
      "signature": "write_guest_pagevcpukvmgpa_to_gfndstgpa",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "write_guest_virt_systemvcpugva",
      "signature": "write_guest_virt_systemvcpugva",
      "file": "arch/x86/kvm/vmx/nested.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_swap_active_memslotsstructkvmkvmintas_idstructkvm_memslotsslotskvm_get_inactive_memslotskvmas_idGrabthegenerationfromtheactivatememslotsu64gen__kvm_memslotskvmas_idgenerationWARN_ONgenKVM_MEMSLOT_GEN_UPDATE_IN_PROGRESSslotsgenerationgenKVM_MEMSLOT_GEN_UPDATE_IN_PROGRESSDonotstorethenewmem",
      "signature": "kvm_swap_active_memslotsstructkvmkvmintas_idstructkvm_memslotsslotskvm_get_inactive_memslotskvmas_idGrabthegenerationfromtheactivatememslotsu64gen__kvm_memslotskvmas_idgenerationWARN_ONgenKVM_MEMSLOT_GEN_UPDATE_IN_PROGRESSslotsgenerationgenKVM_MEMSLOT_GEN_UPDATE_IN_PROGRESSDonotstorethenewmem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_invalidate_memslotstructkvmkvmstructkvm_memory_slotoldstructkvm_memory_slotinvalid_slotMarkthecurrentslotINVALIDAswithallmemslotmodificationsthismustbedoneonanunreachableslottoavoidmodifyingthecurrentslotintheactivetreekvm_copy_memslotinvalid_slotoldinvalid_slotflagsKVM_MEMSLOT_INVALIDkvm_replace_memslotkvmoldinvalid_slotActivatetheslotthatisnowmarkedINVALIDbutdontpropagatetheslottothenowinactiveslotsTheslotiseithergoingtobedeletedorrecreatedasanewslotkvm_swap_active_memslotskvmoldas_idFromthispointnonewshadowpagespointingtoadeletedormovedmemslotwillbecreatedValidationofspgfnhappensingfn_to_hvakvm_read_guestgfn_to_pfnkvm_is_visible_gfnmmu_check_rootkvm_arch_flush_shadow_memslotkvmoldkvm_arch_guest_memory_reclaimedkvmWasreleasedbykvm_swap_active_memslotsreacquiremutex_lockkvmslots_arch_lockCopythearchspecificfieldofthenewlyinstalledslotbacktotheoldslotasthearchdatacouldhavechangedbetweenreleasingslots_arch_lockinkvm_swap_active_memslotsandreacquiringthelockaboveWritersarerequiredtoretrievemem",
      "signature": "kvm_invalidate_memslotstructkvmkvmstructkvm_memory_slotoldstructkvm_memory_slotinvalid_slotMarkthecurrentslotINVALIDAswithallmemslotmodificationsthismustbedoneonanunreachableslottoavoidmodifyingthecurrentslotintheactivetreekvm_copy_memslotinvalid_slotoldinvalid_slotflagsKVM_MEMSLOT_INVALIDkvm_replace_memslotkvmoldinvalid_slotActivatetheslotthatisnowmarkedINVALIDbutdontpropagatetheslottothenowinactiveslotsTheslotiseithergoingtobedeletedorrecreatedasanewslotkvm_swap_active_memslotskvmoldas_idFromthispointnonewshadowpagespointingtoadeletedormovedmemslotwillbecreatedValidationofspgfnhappensingfn_to_hvakvm_read_guestgfn_to_pfnkvm_is_visible_gfnmmu_check_rootkvm_arch_flush_shadow_memslotkvmoldkvm_arch_guest_memory_reclaimedkvmWasreleasedbykvm_swap_active_memslotsreacquiremutex_lockkvmslots_arch_lockCopythearchspecificfieldofthenewlyinstalledslotbacktotheoldslotasthearchdatacouldhavechangedbetweenreleasingslots_arch_lockinkvm_swap_active_memslotsandreacquiringthelockaboveWritersarerequiredtoretrievemem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "foristartiendirxa_errxa_storekvmmem",
      "signature": "foristartiendirxa_errxa_storekvmmem",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_disable_virtualization_cpuvoidignif__this_cpu_readvirtualization_enabledreturnkvm_arch_disable_virtualization_cpu__this_cpu_writevirt",
      "signature": "kvm_disable_virtualization_cpuvoidignif__this_cpu_readvirtualization_enabledreturnkvm_arch_disable_virtualization_cpu__this_cpu_writevirt",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_offset_cached",
      "signature": "int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_resolve_pfnkfppageNULLflagsFOLL_WRITE",
      "signature": "kvm_resolve_pfnkfppageNULLflagsFOLL_WRITE",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_page",
      "signature": "KVM_INTERNALkvm_write_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_write_guest_page",
      "signature": "KVM_INTERNALkvm_vcpu_write_guest_page",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest",
      "signature": "KVM_INTERNALkvm_write_guest",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_vcpu_write_guest",
      "signature": "KVM_INTERNALkvm_vcpu_write_guest",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_offset_cached",
      "signature": "KVM_INTERNALkvm_write_guest_offset_cached",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_write_guest_cached",
      "signature": "KVM_INTERNALkvm_write_guest_cached",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_arch_allow_write_without_running_vcpu",
      "signature": "kvm_arch_allow_write_without_running_vcpu",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_iodevice_write",
      "signature": "kvm_iodevice_write",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "KVM_INTERNALkvm_io_bus_write",
      "signature": "KVM_INTERNALkvm_io_bus_write",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write_cookie",
      "signature": "int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val, long cookie)",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "write_gueststructkvmkvmgpa_tgpa",
      "signature": "write_gueststructkvmkvmgpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "write_gueststructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_gueststructkvm_vcpuvcpugpa_tgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "write_guestkvmgpa",
      "signature": "write_guestkvmgpa",
      "file": "virt/kvm/kvm_main.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_arch_allow_write_without_running_vcpu",
      "signature": "bool kvm_arch_allow_write_without_running_vcpu(struct kvm *kvm)",
      "file": "virt/kvm/dirty_ring.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_gmem_releasestructinodeinodestructfilefilestructkvm_gmemgmemfileprivate_datastructkvm_memory_slotslotstructkvmkvmgmemkvmunsignedlongindexPreventconcurrentattemptstounbindamemslotThisisthelastreferencetothefileandthusnonewbindingscanbecreatedbutdereferencingtheslotforexistingbindingsneedstobeprotectedagainstmemslotupdatesspecificallysothatunbinddoesntraceandfreethememslotkvm_gmem_get_filewillreturnNULLSincereleaseiscalledonlywhenthereferencecountiszeroafterwhichfile_ref_getandget_file_activefailkvm_gmem_get_pfncannotbeusingthefileconcurrentlyfile_ref_putprovidesafullbarrierandget_file_activethematchingacquirebarriermutex_lockkvmslots_lockfilemap_invalidate_lockinodei_mappingxa_for_eachgmembindingsindexslotWRITE_ONCEslotgmem",
      "signature": "kvm_gmem_releasestructinodeinodestructfilefilestructkvm_gmemgmemfileprivate_datastructkvm_memory_slotslotstructkvmkvmgmemkvmunsignedlongindexPreventconcurrentattemptstounbindamemslotThisisthelastreferencetothefileandthusnonewbindingscanbecreatedbutdereferencingtheslotforexistingbindingsneedstobeprotectedagainstmemslotupdatesspecificallysothatunbinddoesntraceandfreethememslotkvm_gmem_get_filewillreturnNULLSincereleaseiscalledonlywhenthereferencecountiszeroafterwhichfile_ref_getandget_file_activefailkvm_gmem_get_pfncannotbeusingthefileconcurrentlyfile_ref_putprovidesafullbarrierandget_file_activethematchingacquirebarriermutex_lockkvmslots_lockfilemap_invalidate_lockinodei_mappingxa_for_eachgmembindingsindexslotWRITE_ONCEslotgmem",
      "file": "virt/kvm/guest_memfd.c",
      "category": "memory_write"
    },
    {
      "function": "__kvm_gmem_unbindstructkvm_memory_slotslotstructkvm_gmemgmemunsignedlongstartslotgmempgoffunsignedlongendstartslotnpagesxa_store_rangegmembindingsstartend1NULLGFP_KERNELsynchronize_srcukvmsrcuensuredthatkvm_gmem_get_pfncannotseethismemslotWRITE_ONCEslotgmem",
      "signature": "__kvm_gmem_unbindstructkvm_memory_slotslotstructkvm_gmemgmemunsignedlongstartslotgmempgoffunsignedlongendstartslotnpagesxa_store_rangegmembindingsstartend1NULLGFP_KERNELsynchronize_srcukvmsrcuensuredthatkvm_gmem_get_pfncannotseethismemslotWRITE_ONCEslotgmem",
      "file": "virt/kvm/guest_memfd.c",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_page",
      "signature": "int kvm_write_guest_page(struct kvm *kvm, gfn_t gfn, const void *data, int offset, int len); int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest",
      "signature": "int kvm_write_guest(struct kvm *kvm, gpa_t gpa, const void *data, unsigned long len); int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_cached",
      "signature": "int kvm_write_guest_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned long len); int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_write_guest_offset_cached",
      "signature": "int kvm_write_guest_offset_cached(struct kvm *kvm, struct gfn_to_hva_cache *ghc, void *data, unsigned int offset, unsigned long len); int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc, gpa_t gpa, unsigned long len); #define __kvm_get_guest(kvm, gfn, offset, v)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write",
      "signature": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val); int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val, long cookie); int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, void *val); int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr, int len, struct kvm_io_device *dev); int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx, struct kvm_io_device *dev); struct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_io_bus_write_cookie",
      "signature": "int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, const void *val, long cookie); int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr, int len, void *val); int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr, int len, struct kvm_io_device *dev); int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx, struct kvm_io_device *dev); struct kvm_io_device *kvm_io_bus_get_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest_page",
      "signature": "int kvm_vcpu_write_guest_page(struct kvm_vcpu *vcpu, gfn_t gfn, const void *data, int offset, int len); int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "kvm_vcpu_write_guest",
      "signature": "int kvm_vcpu_write_guest(struct kvm_vcpu *vcpu, gpa_t gpa, const void *data, unsigned long len); void kvm_vcpu_mark_page_dirty(struct kvm_vcpu *vcpu, gfn_t gfn); /** * kvm_gpc_init - initialize gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @kvm: pointer to kvm instance. * * This sets up a gfn_to_pfn_cache by initializing locks and assigning the * immutable attributes. Note, the cache must be zero-allocated (or zeroed by * the caller before init). */ void kvm_gpc_init(struct gfn_to_pfn_cache *gpc, struct kvm *kvm); /** * kvm_gpc_activate - prepare a cached kernel mapping and HPA for a given guest * physical address. * * @gpc: struct gfn_to_pfn_cache object. * @gpa: guest physical address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This primes a gfn_to_pfn_cache and links it into the @gpc->kvm's list for * invalidations to be processed. Callers are required to use kvm_gpc_check() * to ensure that the cache is valid before accessing the target page. */ int kvm_gpc_activate(struct gfn_to_pfn_cache *gpc, gpa_t gpa, unsigned long len); /** * kvm_gpc_activate_hva - prepare a cached kernel mapping and HPA for a given HVA. * * @gpc: struct gfn_to_pfn_cache object. * @hva: userspace virtual address to map. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * The semantics of this function are the same as those of kvm_gpc_activate(). It * merely bypasses a layer of address translation. */ int kvm_gpc_activate_hva(struct gfn_to_pfn_cache *gpc, unsigned long hva, unsigned long len); /** * kvm_gpc_check - check validity of a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: %true if the cache is still valid and the address matches. * %false if the cache is not valid. * * Callers outside IN_GUEST_MODE context should hold a read lock on @gpc->lock * while calling this function, and then continue to hold the lock until the * access is complete. * * Callers in IN_GUEST_MODE may do so without locking, although they should * still hold a read lock on kvm->scru for the memslot checks. */ bool kvm_gpc_check(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_refresh - update a previously initialized cache. * * @gpc: struct gfn_to_pfn_cache object. * @len: sanity check; the range being access must fit a single page. * * @return: 0 for success. * -EINVAL for a mapping which would cross a page boundary. * -EFAULT for an untranslatable guest physical address. * * This will attempt to refresh a gfn_to_pfn_cache. Note that a successful * return from this function does not mean the page can be immediately * accessed because it may have raced with an invalidation. Callers must * still lock and check the cache status, as this function does not return * with the lock still held to permit access. */ int kvm_gpc_refresh(struct gfn_to_pfn_cache *gpc, unsigned long len); /** * kvm_gpc_deactivate - deactivate and unlink a gfn_to_pfn_cache. * * @gpc: struct gfn_to_pfn_cache object. * * This removes a cache from the VM's list to be processed on MMU notifier * invocation. */ void kvm_gpc_deactivate(struct gfn_to_pfn_cache *gpc); static inline bool kvm_gpc_is_gpa_active(struct gfn_to_pfn_cache *gpc)",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "write_gueststructkvmkvmgpa_tgpa",
      "signature": "write_gueststructkvmkvmgpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
    {
      "function": "write_gueststructkvm_vcpuvcpugpa_tgpa",
      "signature": "write_gueststructkvm_vcpuvcpugpa_tgpa",
      "file": "include/linux/kvm_host.h",
      "category": "memory_write"
    },
]

{
    "continued": "continue on next page...."
}
